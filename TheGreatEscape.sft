@start
@writer=~/.skoolkit:TheGreatEscape.TheGreatEscapeAsmWriter
@set-line-width=240
@set-warnings=1
@replace=/#FACT(?![A-Z])/#LINK:Facts
;
; SkoolKit disassembly of The Great Escape by Denton Designs.
; https://github.com/dpt/The-Great-Escape
;
; Copyright 1986 Ocean Software Ltd. (The Great Escape)
; Copyright 2012-2018 David Thomas <dave@davespace.co.uk> (this disassembly)
;
@ofix+begin
; This disassembly contains ofix changes (operand fixes):
;
@ofix+end
@bfix+begin
; This disassembly contains bfix changes (bug fixes):
;   * Fix the $A2C6 incorrect iteration count resulting in a ROM write to $1A42.
;   * Makes unconditional a needless conditional return at $7CAF.
;   * Corrects the exterior_mask_data iteration count in render_mask_buffer/$B935.
;
@bfix+end
@rfix+begin
; This disassembly contains rfix changes (code movement):
;   * Removes the redundant self-modifying code at $6B19.
;   * Removes a redundant jump at $7AFB.
;   * Removes a redundant jump at $A0B8.
;   * Inserts the missing RET at the end of render_mask_buffer/$B916.
;   * $CCED potential bug fix for is_item_discoverable.
;
@rfix+end
;
; //////////////////////////////////////////////////////////////////////////////
; THE DISASSEMBLY
; //////////////////////////////////////////////////////////////////////////////
;
; * This is a disassembly of the game when it has been loaded and relocated,
;   but not yet invoked: every byte is in its pristine state.
;
; * Any terminology used herein such as 'super tiles' or 'vischars' is my own
;   and has been invented for the purposes of the disassembly. I have seen none
;   of the original source, nor know anything of how it was built.
;
;   When I contacted the author he informed me that the original source is
;   probably now lost forever. :-(
;
; * The md5sum of the original tape image this disassembly was taken from is
;   a6e5d50ab065accb017ecc957a954b53 and was sourced from
;   http://www.worldofspectrum.org/pub/sinclair/games/g/GreatEscapeThe.tzx.zip
;   but you may see slight differences towards the end of the file if you
;   attempt to recreate the disassembly yourself.
;
;
; //////////////////////////////////////////////////////////////////////////////
; STYLE
; //////////////////////////////////////////////////////////////////////////////
;
; The disassembly is (presently) not written as a plain English explanation but
; instead in a C style of pseudocode.
;
; Using C style braces { } conflict with SkoolKit's own use of braces, so we
; use the C99 digraphs <% and %> instead.
;
; Braces, 'do' keywords and the like are syntactic sugar and have no
; corresponding assembly instruction so must share a line with another op. For
; this reason the C style pseudocode is formatted in an uneven way to best fit
; the lines to which it is assigned.
; e.g.
;     if (condition) <%
;         statement; %>
;     else <% statement;
;     %>
;
; I replace registers with constants when the value is used only once (e.g. for
; strides when walking through arrays).
;
;
; //////////////////////////////////////////////////////////////////////////////
; ASSEMBLY PATTERNS
; //////////////////////////////////////////////////////////////////////////////
;
; Here are a selection of Z80 assembly language patterns which occur throughout
; the code.
;
; Multiply A by 2^N:
;   ADD A,A ; A += A (repeated N times)
; Note that this disposes of the topmost bit of A. Some routines discard flag
; bits this way.
;
; Increment HL by an 8-bit delta:
;   A = L
;   A += delta
;   L = A
;   JR NC,skip
;   H++
;   skip:
; Q: Does this only work for HL?
;
; if-else:
;   CP <value>
;   JR <cond>,elsepart;
;   <ifwork>
;   JR endifpart;
;   elsepart: <elsework>
;   endifpart:
;
; Jump if less than or equal:
;   CP $0F
;   JP Z,$C8F1
;   JP C,$C8F1
;
; Transfer between awkward registers:
;   PUSH reg
;   POP anotherreg
;
; Increment (HL) by -1 or +1:
;   BIT 7,A
;   JR Z,inc
;   DEC (HL)
;   DEC (HL)
;   inc: INC (HL)
;
;
; //////////////////////////////////////////////////////////////////////////////
; ZX SPECTRUM BASIC DEFINITIONS
; //////////////////////////////////////////////////////////////////////////////
;
; These are here for information only and are not used by any of the
; directives.
;
; attribute_BLUE_OVER_BLACK                     = 1,
; attribute_RED_OVER_BLACK                      = 2,
; attribute_PURPLE_OVER_BLACK                   = 3,
; attribute_GREEN_OVER_BLACK                    = 4,
; attribute_CYAN_OVER_BLACK                     = 5,
; attribute_YELLOW_OVER_BLACK                   = 6,
; attribute_WHITE_OVER_BLACK                    = 7,
; attribute_BRIGHT_BLUE_OVER_BLACK              = 65,
; attribute_BRIGHT_RED_OVER_BLACK               = 66,
; attribute_BRIGHT_PURPLE_OVER_BLACK            = 67,
; attribute_BRIGHT_GREEN_OVER_BLACK             = 68,
; attribute_BRIGHT_CYAN_OVER_BLACK              = 69,
; attribute_BRIGHT_YELLOW_OVER_BLACK            = 70,
; attribute_BRIGHT_WHITE_OVER_BLACK             = 71,
;
; port_KEYBOARD_SHIFTZXCV                       = $FEFE,
; port_KEYBOARD_ASDFG                           = $FDFE,
; port_KEYBOARD_QWERT                           = $FBFE,
; port_KEYBOARD_12345                           = $F7FE,
; port_KEYBOARD_09876                           = $EFFE,
; port_KEYBOARD_POIUY                           = $DFFE,
; port_KEYBOARD_ENTERLKJH                       = $BFFE,
; port_KEYBOARD_SPACESYMSHFTMNB                 = $7FFE,
;
;
; //////////////////////////////////////////////////////////////////////////////
; ENUMERATIONS
; //////////////////////////////////////////////////////////////////////////////
;
; These are here for information only and are not used by any of the
; directives.
;
; character_0_COMMANDANT                        = 0,
; character_1_GUARD_1                           = 1,
; character_2_GUARD_2                           = 2,
; character_3_GUARD_3                           = 3,
; character_4_GUARD_4                           = 4,
; character_5_GUARD_5                           = 5,
; character_6_GUARD_6                           = 6,
; character_7_GUARD_7                           = 7,
; character_8_GUARD_8                           = 8,
; character_9_GUARD_9                           = 9,
; character_10_GUARD_10                         = 10,
; character_11_GUARD_11                         = 11,
; character_12_GUARD_12                         = 12,
; character_13_GUARD_13                         = 13,
; character_14_GUARD_14                         = 14,
; character_15_GUARD_15                         = 15,
; character_16_GUARD_DOG_1                      = 16,
; character_17_GUARD_DOG_2                      = 17,
; character_18_GUARD_DOG_3                      = 18,
; character_19_GUARD_DOG_4                      = 19,
; character_20_PRISONER_1                       = 20,
; character_21_PRISONER_2                       = 21,
; character_22_PRISONER_3                       = 22,
; character_23_PRISONER_4                       = 23,
; character_24_PRISONER_5                       = 24,
; character_25_PRISONER_6                       = 25,
; character_26_STOVE_1                          = 26,   ; movable item
; character_27_STOVE_2                          = 27,   ; movable item
; character_28_CRATE                            = 28,   ; movable item
; character_NONE                                = 255,
;
; room_0_OUTDOORS                               = 0,
; room_1_HUT1RIGHT                              = 1,
; room_2_HUT2LEFT                               = 2,
; room_3_HUT2RIGHT                              = 3,
; room_4_HUT3LEFT                               = 4,
; room_5_HUT3RIGHT                              = 5,
; room_6                                        = 6,    ; unused room index
; room_7_CORRIDOR                               = 7,
; room_8_CORRIDOR                               = 8,
; room_9_CRATE                                  = 9,
; room_10_LOCKPICK                              = 10,
; room_11_PAPERS                                = 11,
; room_12_CORRIDOR                              = 12,
; room_13_CORRIDOR                              = 13,
; room_14_TORCH                                 = 14,
; room_15_UNIFORM                               = 15,
; room_16_CORRIDOR                              = 16,
; room_17_CORRIDOR                              = 17,
; room_18_RADIO                                 = 18,
; room_19_FOOD                                  = 19,
; room_20_REDCROSS                              = 20,
; room_21_CORRIDOR                              = 21,
; room_22_REDKEY                                = 22,
; room_23_BREAKFAST                             = 23,
; room_24_SOLITARY                              = 24,
; room_25_BREAKFAST                             = 25,
; room_26                                       = 26,   ; unused room index
; room_27                                       = 27,   ; unused room index
; room_28_HUT1LEFT                              = 28,
; room_29_SECOND_TUNNEL_START                   = 29,   ; first of the tunnel rooms
; room_30                                       = 30,
; room_31                                       = 31,
; room_32                                       = 32,
; room_33                                       = 33,
; room_34                                       = 34,
; room_35                                       = 35,
; room_36                                       = 36,
; room_37                                       = 37,
; room_38                                       = 38,
; room_39                                       = 39,
; room_40                                       = 40,
; room_41                                       = 41,
; room_42                                       = 42,
; room_43                                       = 43,
; room_44                                       = 44,
; room_45                                       = 45,
; room_46                                       = 46,
; room_47                                       = 47,
; room_48                                       = 48,
; room_49                                       = 49,
; room_50_BLOCKED_TUNNEL                        = 50,
; room_51                                       = 51,
; room_52                                       = 52,
; room_NONE                                     = 255,
;
; item_WIRESNIPS                                = 0,
; item_SHOVEL                                   = 1,
; item_LOCKPICK                                 = 2,
; item_PAPERS                                   = 3,
; item_TORCH                                    = 4,
; item_BRIBE                                    = 5,
; item_UNIFORM                                  = 6,
; item_FOOD                                     = 7,
; item_POISON                                   = 8,
; item_RED_KEY                                  = 9,
; item_YELLOW_KEY                               = 10,
; item_GREEN_KEY                                = 11,
; item_RED_CROSS_PARCEL                         = 12,
; item_RADIO                                    = 13,
; item_PURSE                                    = 14,
; item_COMPASS                                  = 15,
; item__LIMIT                                   = 16,
; item_NONE                                     = 255,
;
; zoombox_tile_TL                               = 0,    ; top left
; zoombox_tile_HZ                               = 1,    ; horizontal
; zoombox_tile_TR                               = 2,    ; top right
; zoombox_tile_VT                               = 3,    ; vertical
; zoombox_tile_BR                               = 4,    ; bottom right
; zoombox_tile_BL                               = 5,    ; bottom left
;
; message_MISSED_ROLL_CALL                      = 0,
; message_TIME_TO_WAKE_UP                       = 1,
; message_BREAKFAST_TIME                        = 2,
; message_EXERCISE_TIME                         = 3,
; message_TIME_FOR_BED                          = 4,
; message_THE_DOOR_IS_LOCKED                    = 5,
; message_IT_IS_OPEN                            = 6,
; message_INCORRECT_KEY                         = 7,
; message_ROLL_CALL                             = 8,
; message_RED_CROSS_PARCEL                      = 9,
; message_PICKING_THE_LOCK                      = 10,
; message_CUTTING_THE_WIRE                      = 11,
; message_YOU_OPEN_THE_BOX                      = 12,
; message_YOU_ARE_IN_SOLITARY                   = 13,
; message_WAIT_FOR_RELEASE                      = 14,
; message_MORALE_IS_ZERO                        = 15,
; message_ITEM_DISCOVERED                       = 16,
; message_HE_TAKES_THE_BRIBE                    = 17,
; message_AND_ACTS_AS_DECOY                     = 18,
; message_ANOTHER_DAY_DAWNS                     = 19,
; message_QUEUE_END                             = 255,
;
; interiorobject_STRAIGHT_TUNNEL_SW_NE          = 0,
; interiorobject_SMALL_TUNNEL_ENTRANCE          = 1,
; interiorobject_ROOM_OUTLINE_22x12_A           = 2,
; interiorobject_STRAIGHT_TUNNEL_NW_SE          = 3,
; interiorobject_TUNNEL_T_JOIN_NW_SE            = 4,
; interiorobject_PRISONER_SAT_MID_TABLE         = 5,
; interiorobject_TUNNEL_T_JOIN_SW_NE            = 6,
; interiorobject_TUNNEL_CORNER_SW_SE            = 7,
; interiorobject_WIDE_WINDOW_FACING_SE          = 8,
; interiorobject_EMPTY_BED_FACING_SE            = 9,
; interiorobject_SHORT_WARDROBE_FACING_SW       = 10,
; interiorobject_CHEST_OF_DRAWERS_FACING_SW     = 11,
; interiorobject_TUNNEL_CORNER_NW_NE            = 12,
; interiorobject_EMPTY_BENCH                    = 13,
; interiorobject_TUNNEL_CORNER_NE_SE            = 14,
; interiorobject_DOOR_FRAME_SE                  = 15,
; interiorobject_DOOR_FRAME_SW                  = 16,
; interiorobject_TUNNEL_CORNER_NW_SW            = 17,
; interiorobject_TUNNEL_ENTRANCE                = 18,
; interiorobject_PRISONER_SAT_END_TABLE         = 19,
; interiorobject_COLLAPSED_TUNNEL_SW_NE         = 20,
; interiorobject_UNUSED_21                      = 21,   ; object unused by game, draws as interiorobject_ROOM_OUTLINE_22x12_A
; interiorobject_CHAIR_FACING_SE                = 22,
; interiorobject_OCCUPIED_BED                   = 23,
; interiorobject_ORNATE_WARDROBE_FACING_SW      = 24,
; interiorobject_CHAIR_FACING_SW                = 25,
; interiorobject_CUPBOARD_FACING_SE             = 26,
; interiorobject_ROOM_OUTLINE_18x10_A           = 27,
; interiorobject_UNUSED_28                      = 28,   ; object unused by game, draws as interiorobject_TABLE
; interiorobject_TABLE                          = 29,
; interiorobject_STOVE_PIPE                     = 30,
; interiorobject_PAPERS_ON_FLOOR                = 31,
; interiorobject_TALL_WARDROBE_FACING_SW        = 32,
; interiorobject_SMALL_SHELF_FACING_SE          = 33,
; interiorobject_SMALL_CRATE                    = 34,
; interiorobject_SMALL_WINDOW_WITH_BARS_FACING_SE = 35
; interiorobject_TINY_DOOR_FRAME_NE             = 36,   ; tunnel entrance
; interiorobject_NOTICEBOARD_FACING_SE          = 37,
; interiorobject_DOOR_FRAME_NW                  = 38,
; interiorobject_UNUSED_39                      = 39,   ; object unused by game, draws as interiorobject_END_DOOR_FRAME_NW_SE
; interiorobject_DOOR_FRAME_NE                  = 40,
; interiorobject_ROOM_OUTLINE_15x8              = 41,
; interiorobject_CUPBOARD_FACING_SW             = 42,
; interiorobject_MESS_BENCH                     = 43,
; interiorobject_MESS_TABLE                     = 44,
; interiorobject_MESS_BENCH_SHORT               = 45,
; interiorobject_ROOM_OUTLINE_18x10_B           = 46,
; interiorobject_ROOM_OUTLINE_22x12_B           = 47,
; interiorobject_TINY_TABLE                     = 48,
; interiorobject_TINY_DRAWERS_FACING_SE         = 49,
; interiorobject_TALL_DRAWERS_FACING_SW         = 50,
; interiorobject_DESK_FACING_SW                 = 51,
; interiorobject_SINK_FACING_SE                 = 52,
; interiorobject_KEY_RACK_FACING_SE             = 53,
; interiorobject__LIMIT                         = 54
;
; interiorobjecttile_MAX                        = 194,  ; number of tiles at $9768 interior_tiles
; interiorobjecttile_ESCAPE                     = 255,  ; escape character
;
; location_000E                                 = $000E,
; location_0010                                 = $0010,
; location_002A                                 = $002A,
; location_002B                                 = $002B,
; location_002C                                 = $002C,
; location_002D                                 = $002D,
; location_012C                                 = $012C,
; location_0285                                 = $0285,
; location_0390                                 = $0390,
; location_048E                                 = $048E,
;
; sound_CHARACTER_ENTERS_1                      = $2030,
; sound_CHARACTER_ENTERS_2                      = $2040,
; sound_BELL_RINGER                             = $2530,
; sound_PICK_UP_ITEM                            = $3030,
; sound_DROP_ITEM                               = $3040,
;
; morale_MIN                                    = 0,
; morale_MAX                                    = 112,
;
;
; //////////////////////////////////////////////////////////////////////////////
; FLAGS
; //////////////////////////////////////////////////////////////////////////////
;
; These are here for information only and are not used by any of the
; directives.
;
; input_NONE                                    = 0,
; input_UP                                      = 1,
; input_DOWN                                    = 2,
; input_LEFT                                    = 3,
; input_RIGHT                                   = 6,
; input_FIRE                                    = 9,
; input_UP_FIRE                                 = input_UP    + input_FIRE,
; input_DOWN_FIRE                               = input_DOWN  + input_FIRE,
; input_LEFT_FIRE                               = input_LEFT  + input_FIRE,
; input_RIGHT_FIRE                              = input_RIGHT + input_FIRE,
;
; ; $8000, $8020, $8040, ...
; vischar_CHARACTER_MASK                        = $1F,          ; character index mask. this is used in a couple of places but it's not consistently applied. i've not spotted anything else sharing the this field.
;
; ; $8001, $8021, $8041, ...
; vischar_FLAGS_EMPTY_SLOT                      = $FF,
; vischar_FLAGS_MASK                            = $3F,
; vischar_FLAGS_PICKING_LOCK                    = 1 << 0,       ; hero only
; vischar_FLAGS_CUTTING_WIRE                    = 1 << 1,       ; hero only
;
; Four pursuit modes:
; vischar_FLAGS_PURSUE                          = 1 << 0,       ; non-hero only. this flag is set when a visible friendly was nearby when a bribe was used. it's also set by hostiles_pursue
; vischar_FLAGS_HASSLE                          = 2 << 0,       ; this flag is set in guards_follow_suspicious_character when a hostile is following the hero
; vischar_FLAGS_DOG_FOOD                        = 3 << 0,       ; set when food is in the vicinity of a dog
; vischar_FLAGS_SAW_BRIBE                       = 4 << 0,       ; this flag is set when a visible hostile was nearby when a bribe was used. perhaps it distracts the guards?
;
; vischar_FLAGS_TARGET_IS_DOOR                  = 1 << 6,       ; affects scaling
; vischar_FLAGS_NO_COLLIDE                      = 1 << 7,       ; don't do collision() for this vischar
;
; ; $8002, $8022, $8042, ...
; route_REVERSED                                = 1 << 7,       ; set if the route is to be followed in reverse order
;
; ; $8007, $8027, $8047, ...
; vischar_BYTE7_MASK_LO                         = $0F,
; vischar_BYTE7_MASK_HI                         = $F0,
; vischar_BYTE7_Y_DOMINANT                      = 1 << 5,       ; set when hero hits an obstacle
; vischar_BYTE7_TOUCHING                        = 1 << 6,       ; set while touch() entered
; vischar_BYTE7_LOCATABLE                       = 1 << 7,       ; stops locate_vischar_or_itemstruct considering a vischar
;
; ; $800C, $802C, $804C, ...
; vischar_ANIMINDEX_BIT7                        = 1 << 7,       ; is this a kick flag?
;
; ; $800E, $802E, $804E, ...
; vischar_DIRECTION_MASK                        = $03,
; vischar_DIRECTION_CRAWL                       = 1 << 2,
;
; itemstruct_ITEM_MASK                          = $0F,
; itemstruct_ITEM_FLAG_POISONED                 = 1 << 5,
; itemstruct_ITEM_FLAG_HELD                     = 1 << 7,       ; set when the item has been encountered
; itemstruct_ROOM_MASK                          = $3F,
; itemstruct_ROOM_FLAG_NEARBY_6                 = 1 << 6,       ; unknown
; itemstruct_ROOM_FLAG_NEARBY_7                 = 1 << 7,       ; set when the item is nearby
;
; door_REVERSE                                  = 1 << 7,       ; used to reverse door transitions
; door_LOCKED                                   = 1 << 7,       ; used to lock doors in locked_doors[]
; door_NONE                                     = $FF
;
; characterstruct_FLAG_DISABLED                 = 1 << 6,       ; this disables the character
; characterstruct_CHARACTER_MASK                = $1F,
; characterstruct_BYTE5_MASK                    = $7F,
; characterstruct_BYTE6_MASK_LO                 = $07,
;
; door_FLAGS_MASK_DIRECTION                     = $03,          ; up/down or direction field?
;
; searchlight_STATE_CAUGHT                      = $1F,
; searchlight_STATE_SEARCHING                   = $FF,          ; hunting for hero
;
; bell_RING_PERPETUAL                           = $00,
; bell_RING_40_TIMES                            = $28,
; bell_STOP                                     = $FF,
;
; escapeitem_COMPASS                            = 1,
; escapeitem_PAPERS                             = 2,
; escapeitem_PURSE                              = 4,
; escapeitem_UNIFORM                            = 8,
;
; statictiles_COUNT_MASK                        = $7F,
; statictiles_VERTICAL                          = 1 << 7,       ; otherwise horizontal
;
; map_MAIN_GATE_X                               = $696D,        ; coords: $69..$6D
; map_MAIN_GATE_Y                               = $494B,
; map_ROLL_CALL_X                               = $727C,
; map_ROLL_CALL_Y                               = $6A72,
;
; inputdevice_KEYBOARD                          = 0,
;
;
; //////////////////////////////////////////////////////////////////////////////
; ROOMS
; //////////////////////////////////////////////////////////////////////////////
;
; Key
;
;   '' => door (up/down)
;   =  => door (left/right)
;   in => entrance
;   [] => exit
;   ~  => void / ground
;
; Map of rooms' indices
;
;   +--------+--------+----+----+----+
;   |   25   =   23   = 19 = 18 = 12 |
;   +--------+-+-''-+-+----+    +-''-+
;    | 24 = 22 = 21 | | 20 +    + 17 |
;    +----+----+-''-+ +-''-+----+-''-+
;                          = 15 |  7 |
;       +----+------+      +-''-+-''-+
;       = 28 =   1  |      | 14 = 16 |
;       +----+--''--+      +----+-''-+
;                               = 13 |
;       +----+------+           +-''-+
;       =  2 =   3  |           | 11 |
;       +----+--''--+           |    |
;                          +----+----+
;       +----+------+      | 10 |  9 |
;       =  4 =   5  |      |    |    |
;       +----+--''--+      +-''-+-''-+
;                          =    8    |
;                          +----+----+
;
; Map of tunnels' indices 1
;
;   ~~~~~~~~~~~~~~~~~~~~+---------+----+
;   ~~~~~~~~~~~~~~~~~~~~|    49   = 50 |
;   ~~~~~~~~~~~~~~~~~~~~+-''-+----+-''-+
;   ~~~~~~~~~~~~~~~~~~~~| 48 |~~~~| 47 |
;   ~~~~~~~~~~~~~~~~~~~~+-[]-+~~~~|    |
;   +------+-------+----+----+----+    |
;   |  45  =   41  =    40   | 46 =    |
;   +-''-+-+--+-''-+------''-+-''-+----+
;   | 44 = 43 = 42 |~~~~| 38 = 39 |~~~~~
;   +----+----+----+~~~~+-''-+----+~~~~~
;   ~~~~~~~~~~~~~~~~~~~~| 37 |~~~~~~~~~~
;   ~~~~~~~~~~~~~~~~~~~~+-in-+~~~~~~~~~~
;
; Map of tunnels' indices 2
;
;   +----------+--------+--------+
;   |    36    =   30   =   52   |
;   +-''-+-----+--''----+---+-''-+
;   | 35 |~~~~~~| 31 |~~~~~~| 51 |
;   |    +------+-''-+~~~~~~|    |
;   |    =  33  = 32 |~~~~~~|    |
;   |    +------+----+~~~~~~|    |
;   |    |~~~~~~~~~~~~~+----+    |
;   +-''-+~~~~~~~~~~~~in 29 =    |
;   | 34 |~~~~~~~~~~~~~+----+----+
;   +-[]-+~~~~~~~~~~~~~~~~~~~~~~~~
;
; I'm fairly sure that the visual of the above layout is actually topologically
; impossible. e.g. if you take screenshots of every room and attempt to combine
; them in an image editor it won't join up.
;
; Unused room indices: 6, 26, 27
;
;
; //////////////////////////////////////////////////////////////////////////////
; GAME STATE
; //////////////////////////////////////////////////////////////////////////////
;
; There are eight visible character (vischar) structures living at $8000
; onwards. The game therefore supports up to eight characters on-screen at
; once. The stove and crate items count as characters too.
;
; These structures occupy the same addresses as some of the static tiles. This
; is fine as the static tiles are never referenced once they're plotted to the
; screen at startup.
;
; The structures are 32 bytes long. Each structure is laid out as follows:
;
; +-----+---------+-------------------------------------------------------------------------------+
; | off | size    | purpose                                                                       |
; +-----+---------+-------------------------------------------------------------------------------+
; | $00 | byte    | character index, or $FF for none                                              |
; | $01 | byte    | flags                                                                         |
; | $02 | byte[2] | route                                                                         |
; | $04 | byte[3] | position                                                                      |
; | $07 | byte    | top nibble = flags, bottom nibble = counter used by character_behaviour only  |
; | $08 | pointer | pointer to animations                                                         |
; | $0A | pointer | pointer to value in animations                                                |
; | $0C | byte    | bit 7 is up/down flag, other bits are a counter                               |
; | $0D | byte    | input .. previous direction?                                                  |
; | $0E | byte    | direction and walk/crawl flag                                                 |
; | $0F | movitem | movable item struct (pos, cur sprite, sprite index)                           |
; | $18 | word[2] | screen x, y coord                                                             |
; | $1C | byte    | current room index                                                            |
; | $1D | byte    | (unused)                                                                      |
; | $1E | byte    | copy of sprite width in bytes + 1                                             |
; | $1F | byte    | copy of sprite height in rows                                                 |
; +-----+---------+-------------------------------------------------------------------------------+
;
; The first entry in the array is the hero.
;
; Further notes:
;
; b $8001 flags: bit 6 gets toggled in set_hero_route /  bit 0: picking lock /  bit 1: cutting wire  ($FF when reset)
; w $8002 route (set in set_hero_route, process_player_input)
; b*3 $8004 (<- process_player_input) a coordinate? (i see it getting scaled in #R$CA11)
; b $8007 bits 5/6/7: flags  (suspect bit 4 is a flag too) ($00 when reset)
; w $8008 (read by animate)
; w $800A (read/written by animate)
; b $800C (read/written by animate)
; b $800D tunnel related (<- process_player_input, cutting_wire, process_player_input) assigned from cutting_wire_new_inputs table.  causes movement when set. but not when in solitary.
;            $81 -> move toward top left,
;            $82 -> move toward bottom right,
;            $83 -> move toward bottom left,
;            $84 -> TL (again)
;            $85 ->
; b $800E tunnel related, direction (bottom 2 bits index cutting_wire_new_inputs) bit 2 is walk/crawl flag
; set to - $00 -> character faces top left
;          $01 -> character faces top right
;          $02 -> character faces bottom right
;          $03 -> character faces bottom left
;          $04 -> character faces top left     (crawling)
;          $05 -> character faces top right    (crawling)
;          $06 -> character faces bottom right (crawling)
;          $07 -> character faces bottom left  (crawling)
; w $800F position on X axis (along the line of - bottom right to top left of screen) (set by process_player_input)
; w $8011 position on Y axis (along the line of - bottom left to top right of screen) (set by process_player_input)  i think this might be relative to the current size of the map. each step seems to be two pixels.
; w $8013 character's height // set to 24 in process_player_input, cutting_wire,  set to 12 in action_wiresnips,  reset in calc_vischar_iso_pos_from_vischar,  read by animate ($B68C) (via IY), locate_vischar_or_itemstruct ($B8DE), setup_vischar_plotting ($E433), in_permitted_area ($9F4F)  written by touch ($AFD5)  often written as a byte, but suspect it's a word-sized value
; w $8015 pointer to current character sprite set (gets pointed to the 'tl_4' sprite)
; b $8017 touch sets this to touch_stashed_A
; w $8018 points to something (gets $06C8 subtracted from it) (<- in_permitted_area)
; w $801A points to something (gets $0448 subtracted from it) (<- in_permitted_area)
; b $801C room index: cleared to zero by action_papers, set to room_24_SOLITARY by solitary, copied to room_index by transition
;
; Other things:
;
; b $8100 mask buffer (0xA0 bytes - 4 * 8 * 5)
; w $81A0 mask buffer pointer
; w $81A2 screen buffer pointer
;
;
; //////////////////////////////////////////////////////////////////////////////
; ROUTES
; //////////////////////////////////////////////////////////////////////////////
;
; Each vischar has a "route" structure that guides its pathfinding. The route
; is composed of an index and a step (the first and second bytes respectively).
; The index selects a route from the table at #R$7738. The step is the index
; into that route. If the top bit of the route index is set then the route is
; followed in reverse order.
;
;
; //////////////////////////////////////////////////////////////////////////////
; HUTS
; //////////////////////////////////////////////////////////////////////////////
;
; Hut 1 is the hut at the 'top' of the map.
; Hut 2 is the middle hut.
; Hut 3 is the bottom hut.
;
; These identifiers for the huts are my own convention - as with all things in
; this disassembly it was determined from scratch.
;
;
; //////////////////////////////////////////////////////////////////////////////
; HUT INTERIORS
; //////////////////////////////////////////////////////////////////////////////
;
; Hut 1 is composed of room 28 on the left and room 1 on the right.
; Hut 2 is composed of room  2 on the left and room 3 on the right.
; Hut 3 is composed of room  4 on the left and room 5 on the right.
;
;
; //////////////////////////////////////////////////////////////////////////////
; SLEEPING CHARACTERS
; //////////////////////////////////////////////////////////////////////////////
;
; Three of the four beds in hut 1 are occupied by sleeping figures who -
; creepily - never rise from their slumber. Perhaps more concurrent prisoner
; characters were originally planned - there's capacity in the room layout for
; eleven - but machine limits prevented more than six being used.
;
; In hut 2, our hero sleeps in the left hand room and three active characters
; (20..22) slumber in the right hand room.
;
; Hut 3 has no character sleeping in its left hand room and three active
; characters (23..25) sleep in the right hand room.
;
;       |-- Left room --|----------------- Right room -----------------|
;       |---------------|-- Left bed --|-- Middle bed -|-- Right bed --|
; Hut 1 | Always asleep | Always empty | Always asleep | Always asleep |
; Hut 2 | Hero          | 22           | 21            | 20            |
; Hut 3 | Always empty  | 25           | 24            | 23            |
;
@org=$4000

; Loading screen.
;
; #UDGTABLE
; { #SCR(loading) | This is the loading screen. }
; TABLE#
@label=screen
bB$4000,32;140 {Pixels.
 B$4020,32*190
 B$57E0,32;140 }
 B$5800,32;140 {Attributes.
 B$5820,32*22
 B$5AE0,32;140 }

; Super tiles.
;
; The game's exterior map (at #R$BCEE) is constructed of references to these
; "super tiles" which are in turn a 4x4 array of tile indices.
@label=super_tiles
bB$5B00,4;28 {super_tile $00 #HTML[#CALL:supertile($5B00, 0)]
 B$5B04,4*2
 B$5B0C,4;28 }
 B$5B10,4;28 {super_tile $01 #HTML[#CALL:supertile($5B10, 0)]
 B$5B14,4*2
 B$5B1C,4;28 }
 B$5B20,4;28 {super_tile $02 #HTML[#CALL:supertile($5B20, 0)]
 B$5B24,4*2
 B$5B2C,4;28 }
 B$5B30,4;28 {super_tile $03 #HTML[#CALL:supertile($5B30, 0)]
 B$5B34,4*2
 B$5B3C,4;28 }
 B$5B40,4;28 {super_tile $04 #HTML[#CALL:supertile($5B40, 0)]
 B$5B44,4*2
 B$5B4C,4;28 }
 B$5B50,4;28 {super_tile $05 #HTML[#CALL:supertile($5B50, 0)]
 B$5B54,4*2
 B$5B5C,4;28 }
 B$5B60,4;28 {super_tile $06 #HTML[#CALL:supertile($5B60, 0)]
 B$5B64,4*2
 B$5B6C,4;28 }
 B$5B70,4;28 {super_tile $07 #HTML[#CALL:supertile($5B70, 0)]
 B$5B74,4*2
 B$5B7C,4;28 }
 B$5B80,4;28 {super_tile $08 #HTML[#CALL:supertile($5B80, 0)]
 B$5B84,4*2
 B$5B8C,4;28 }
 B$5B90,4;28 {super_tile $09 #HTML[#CALL:supertile($5B90, 0)]
 B$5B94,4*2
 B$5B9C,4;28 }
 B$5BA0,4;28 {super_tile $0A #HTML[#CALL:supertile($5BA0, 0)]
 B$5BA4,4*2
 B$5BAC,4;28 }
 B$5BB0,4;28 {super_tile $0B #HTML[#CALL:supertile($5BB0, 0)]
 B$5BB4,4*2
 B$5BBC,4;28 }
 B$5BC0,4;28 {super_tile $0C #HTML[#CALL:supertile($5BC0, 0)]
 B$5BC4,4*2
 B$5BCC,4;28 }
 B$5BD0,4;28 {super_tile $0D #HTML[#CALL:supertile($5BD0, 0)]
 B$5BD4,4*2
 B$5BDC,4;28 }
 B$5BE0,4;28 {super_tile $0E #HTML[#CALL:supertile($5BE0, 0)]
 B$5BE4,4*2
 B$5BEC,4;28 }
 B$5BF0,4;28 {super_tile $0F #HTML[#CALL:supertile($5BF0, 0)]
 B$5BF4,4*2
 B$5BFC,4;28 }
 B$5C00,4;28 {super_tile $10 #HTML[#CALL:supertile($5C00, 0)]
 B$5C04,4*2
 B$5C0C,4;28 }
 B$5C10,4;28 {super_tile $11 #HTML[#CALL:supertile($5C10, 0)]
 B$5C14,4*2
 B$5C1C,4;28 }
 B$5C20,4;28 {super_tile $12 #HTML[#CALL:supertile($5C20, 0)]
 B$5C24,4*2
 B$5C2C,4;28 }
 B$5C30,4;28 {super_tile $13 #HTML[#CALL:supertile($5C30, 0)]
 B$5C34,4*2
 B$5C3C,4;28 }
 B$5C40,4;28 {super_tile $14 #HTML[#CALL:supertile($5C40, 0)]
 B$5C44,4*2
 B$5C4C,4;28 }
 B$5C50,4;28 {super_tile $15 #HTML[#CALL:supertile($5C50, 0)]
 B$5C54,4*2
 B$5C5C,4;28 }
 B$5C60,4;28 {super_tile $16 #HTML[#CALL:supertile($5C60, 0)]
 B$5C64,4*2
 B$5C6C,4;28 }
 B$5C70,4;28 {super_tile $17 #HTML[#CALL:supertile($5C70, 0)]
 B$5C74,4*2
 B$5C7C,4;28 }
 B$5C80,4;28 {super_tile $18 #HTML[#CALL:supertile($5C80, 0)]
 B$5C84,4*2
 B$5C8C,4;28 }
 B$5C90,4;28 {super_tile $19 #HTML[#CALL:supertile($5C90, 0)]
 B$5C94,4*2
 B$5C9C,4;28 }
 B$5CA0,4;28 {super_tile $1A #HTML[#CALL:supertile($5CA0, 0)]
 B$5CA4,4*2
 B$5CAC,4;28 }
 B$5CB0,4;28 {super_tile $1B #HTML[#CALL:supertile($5CB0, 0)]
 B$5CB4,4*2
 B$5CBC,4;28 }
 B$5CC0,4;28 {super_tile $1C #HTML[#CALL:supertile($5CC0, 0)]
 B$5CC4,4*2
 B$5CCC,4;28 }
 B$5CD0,4;28 {super_tile $1D #HTML[#CALL:supertile($5CD0, 0)]
 B$5CD4,4*2
 B$5CDC,4;28 }
 B$5CE0,4;28 {super_tile $1E #HTML[#CALL:supertile($5CE0, 0)]
 B$5CE4,4*2
 B$5CEC,4;28 }
 B$5CF0,4;28 {super_tile $1F #HTML[#CALL:supertile($5CF0, 0)]
 B$5CF4,4*2
 B$5CFC,4;28 }
 B$5D00,4;28 {super_tile $20 #HTML[#CALL:supertile($5D00, 0)]
 B$5D04,4*2
 B$5D0C,4;28 }
 B$5D10,4;28 {super_tile $21 #HTML[#CALL:supertile($5D10, 0)]
 B$5D14,4*2
 B$5D1C,4;28 }
 B$5D20,4;28 {super_tile $22 #HTML[#CALL:supertile($5D20, 0)]
 B$5D24,4*2
 B$5D2C,4;28 }
 B$5D30,4;28 {super_tile $23 #HTML[#CALL:supertile($5D30, 0)]
 B$5D34,4*2
 B$5D3C,4;28 }
 B$5D40,4;28 {super_tile $24 #HTML[#CALL:supertile($5D40, 0)]
 B$5D44,4*2
 B$5D4C,4;28 }
 B$5D50,4;28 {super_tile $25 #HTML[#CALL:supertile($5D50, 0)]
 B$5D54,4*2
 B$5D5C,4;28 }
 B$5D60,4;28 {super_tile $26 #HTML[#CALL:supertile($5D60, 0)]
 B$5D64,4*2
 B$5D6C,4;28 }
 B$5D70,4;28 {super_tile $27 #HTML[#CALL:supertile($5D70, 0)]
 B$5D74,4*2
 B$5D7C,4;28 }
 B$5D80,4;28 {super_tile $28 #HTML[#CALL:supertile($5D80, 0)]
 B$5D84,4*2
 B$5D8C,4;28 }
 B$5D90,4;28 {super_tile $29 #HTML[#CALL:supertile($5D90, 0)]
 B$5D94,4*2
 B$5D9C,4;28 }
 B$5DA0,4;28 {super_tile $2A #HTML[#CALL:supertile($5DA0, 0)]
 B$5DA4,4*2
 B$5DAC,4;28 }
 B$5DB0,4;28 {super_tile $2B #HTML[#CALL:supertile($5DB0, 0)]
 B$5DB4,4*2
 B$5DBC,4;28 }
 B$5DC0,4;28 {super_tile $2C #HTML[#CALL:supertile($5DC0, 0)]
 B$5DC4,4*2
 B$5DCC,4;28 }
 B$5DD0,4;28 {super_tile $2D #HTML[#CALL:supertile($5DD0, 0)]
 B$5DD4,4*2
 B$5DDC,4;28 }
 B$5DE0,4;28 {super_tile $2E #HTML[#CALL:supertile($5DE0, 0)]
 B$5DE4,4*2
 B$5DEC,4;28 }
 B$5DF0,4;28 {super_tile $2F #HTML[#CALL:supertile($5DF0, 0)]
 B$5DF4,4*2
 B$5DFC,4;28 }
 B$5E00,4;28 {super_tile $30 #HTML[#CALL:supertile($5E00, 0)]
 B$5E04,4*2
 B$5E0C,4;28 }
 B$5E10,4;28 {super_tile $31 #HTML[#CALL:supertile($5E10, 0)]
 B$5E14,4*2
 B$5E1C,4;28 }
 B$5E20,4;28 {super_tile $32 #HTML[#CALL:supertile($5E20, 0)]
 B$5E24,4*2
 B$5E2C,4;28 }
 B$5E30,4;28 {super_tile $33 #HTML[#CALL:supertile($5E30, 0)]
 B$5E34,4*2
 B$5E3C,4;28 }
 B$5E40,4;28 {super_tile $34 #HTML[#CALL:supertile($5E40, 0)]
 B$5E44,4*2
 B$5E4C,4;28 }
 B$5E50,4;28 {super_tile $35 #HTML[#CALL:supertile($5E50, 0)]
 B$5E54,4*2
 B$5E5C,4;28 }
 B$5E60,4;28 {super_tile $36 #HTML[#CALL:supertile($5E60, 0)]
 B$5E64,4*2
 B$5E6C,4;28 }
 B$5E70,4;28 {super_tile $37 #HTML[#CALL:supertile($5E70, 0)]
 B$5E74,4*2
 B$5E7C,4;28 }
 B$5E80,4;28 {super_tile $38 #HTML[#CALL:supertile($5E80, 0)]
 B$5E84,4*2
 B$5E8C,4;28 }
 B$5E90,4;28 {super_tile $39 #HTML[#CALL:supertile($5E90, 0)]
 B$5E94,4*2
 B$5E9C,4;28 }
 B$5EA0,4;28 {super_tile $3A #HTML[#CALL:supertile($5EA0, 0)]
 B$5EA4,4*2
 B$5EAC,4;28 }
 B$5EB0,4;28 {super_tile $3B #HTML[#CALL:supertile($5EB0, 0)]
 B$5EB4,4*2
 B$5EBC,4;28 }
 B$5EC0,4;28 {super_tile $3C #HTML[#CALL:supertile($5EC0, 0)]
 B$5EC4,4*2
 B$5ECC,4;28 }
 B$5ED0,4;28 {super_tile $3D #HTML[#CALL:supertile($5ED0, 0)]
 B$5ED4,4*2
 B$5EDC,4;28 }
 B$5EE0,4;28 {super_tile $3E #HTML[#CALL:supertile($5EE0, 0)]
 B$5EE4,4*2
 B$5EEC,4;28 }
 B$5EF0,4;28 {super_tile $3F #HTML[#CALL:supertile($5EF0, 0)]
 B$5EF4,4*2
 B$5EFC,4;28 }
 B$5F00,4;28 {super_tile $40 #HTML[#CALL:supertile($5F00, 0)]
 B$5F04,4*2
 B$5F0C,4;28 }
 B$5F10,4;28 {super_tile $41 #HTML[#CALL:supertile($5F10, 0)]
 B$5F14,4*2
 B$5F1C,4;28 }
 B$5F20,4;28 {super_tile $42 #HTML[#CALL:supertile($5F20, 0)]
 B$5F24,4*2
 B$5F2C,4;28 }
 B$5F30,4;28 {super_tile $43 #HTML[#CALL:supertile($5F30, 0)]
 B$5F34,4*2
 B$5F3C,4;28 }
 B$5F40,4;28 {super_tile $44 #HTML[#CALL:supertile($5F40, 0)]
 B$5F44,4*2
 B$5F4C,4;28 }
 B$5F50,4;28 {super_tile $45 #HTML[#CALL:supertile($5F50, 0)]
 B$5F54,4*2
 B$5F5C,4;28 }
 B$5F60,4;28 {super_tile $46 #HTML[#CALL:supertile($5F60, 0)]
 B$5F64,4*2
 B$5F6C,4;28 }
 B$5F70,4;28 {super_tile $47 #HTML[#CALL:supertile($5F70, 0)]
 B$5F74,4*2
 B$5F7C,4;28 }
 B$5F80,4;28 {super_tile $48 #HTML[#CALL:supertile($5F80, 0)]
 B$5F84,4*2
 B$5F8C,4;28 }
 B$5F90,4;28 {super_tile $49 #HTML[#CALL:supertile($5F90, 0)]
 B$5F94,4*2
 B$5F9C,4;28 }
 B$5FA0,4;28 {super_tile $4A #HTML[#CALL:supertile($5FA0, 0)]
 B$5FA4,4*2
 B$5FAC,4;28 }
 B$5FB0,4;28 {super_tile $4B #HTML[#CALL:supertile($5FB0, 0)]
 B$5FB4,4*2
 B$5FBC,4;28 }
 B$5FC0,4;28 {super_tile $4C #HTML[#CALL:supertile($5FC0, 0)]
 B$5FC4,4*2
 B$5FCC,4;28 }
 B$5FD0,4;28 {super_tile $4D #HTML[#CALL:supertile($5FD0, 0)]
 B$5FD4,4*2
 B$5FDC,4;28 }
 B$5FE0,4;28 {super_tile $4E #HTML[#CALL:supertile($5FE0, 0)]
 B$5FE4,4*2
 B$5FEC,4;28 }
 B$5FF0,4;28 {super_tile $4F #HTML[#CALL:supertile($5FF0, 0)]
 B$5FF4,4;28 [unused by map]
 B$5FF8,4
 B$5FFC,4;28 }
 B$6000,4;28 {super_tile $50 #HTML[#CALL:supertile($6000, 0)]
 B$6004,4*2
 B$600C,4;28 }
 B$6010,4;28 {super_tile $51 #HTML[#CALL:supertile($6010, 0)]
 B$6014,4*2
 B$601C,4;28 }
 B$6020,4;28 {super_tile $52 #HTML[#CALL:supertile($6020, 0)]
 B$6024,4*2
 B$602C,4;28 }
 B$6030,4;28 {super_tile $53 #HTML[#CALL:supertile($6030, 0)]
 B$6034,4*2
 B$603C,4;28 }
 B$6040,4;28 {super_tile $54 #HTML[#CALL:supertile($6040, 0)]
 B$6044,4*2
 B$604C,4;28 }
 B$6050,4;28 {super_tile $55 #HTML[#CALL:supertile($6050, 0)]
 B$6054,4*2
 B$605C,4;28 }
 B$6060,4;28 {super_tile $56 #HTML[#CALL:supertile($6060, 0)]
 B$6064,4*2
 B$606C,4;28 }
 B$6070,4;28 {super_tile $57 #HTML[#CALL:supertile($6070, 0)]
 B$6074,4*2
 B$607C,4;28 }
 B$6080,4;28 {super_tile $58 #HTML[#CALL:supertile($6080, 0)]
 B$6084,4*2
 B$608C,4;28 }
 B$6090,4;28 {super_tile $59 #HTML[#CALL:supertile($6090, 0)]
 B$6094,4*2
 B$609C,4;28 }
 B$60A0,4;28 {super_tile $5A #HTML[#CALL:supertile($60A0, 0)]
 B$60A4,4*2
 B$60AC,4;28 }
 B$60B0,4;28 {super_tile $5B #HTML[#CALL:supertile($60B0, 0)]
 B$60B4,4*2
 B$60BC,4;28 }
 B$60C0,4;28 {super_tile $5C #HTML[#CALL:supertile($60C0, 0)]
 B$60C4,4*2
 B$60CC,4;28 }
 B$60D0,4;28 {super_tile $5D #HTML[#CALL:supertile($60D0, 0)]
 B$60D4,4*2
 B$60DC,4;28 }
 B$60E0,4;28 {super_tile $5E #HTML[#CALL:supertile($60E0, 0)]
 B$60E4,4*2
 B$60EC,4;28 }
 B$60F0,4;28 {super_tile $5F #HTML[#CALL:supertile($60F0, 0)]
 B$60F4,4*2
 B$60FC,4;28 }
 B$6100,4;28 {super_tile $60 #HTML[#CALL:supertile($6100, 0)]
 B$6104,4*2
 B$610C,4;28 }
 B$6110,4;28 {super_tile $61 #HTML[#CALL:supertile($6110, 0)]
 B$6114,4*2
 B$611C,4;28 }
 B$6120,4;28 {super_tile $62 #HTML[#CALL:supertile($6120, 0)]
 B$6124,4*2
 B$612C,4;28 }
 B$6130,4;28 {super_tile $63 #HTML[#CALL:supertile($6130, 0)]
 B$6134,4*2
 B$613C,4;28 }
 B$6140,4;28 {super_tile $64 #HTML[#CALL:supertile($6140, 0)]
 B$6144,4*2
 B$614C,4;28 }
 B$6150,4;28 {super_tile $65 #HTML[#CALL:supertile($6150, 0)]
 B$6154,4*2
 B$615C,4;28 }
 B$6160,4;28 {super_tile $66 #HTML[#CALL:supertile($6160, 0)]
 B$6164,4*2
 B$616C,4;28 }
 B$6170,4;28 {super_tile $67 #HTML[#CALL:supertile($6170, 0)]
 B$6174,4*2
 B$617C,4;28 }
 B$6180,4;28 {super_tile $68 #HTML[#CALL:supertile($6180, 0)]
 B$6184,4*2
 B$618C,4;28 }
 B$6190,4;28 {super_tile $69 #HTML[#CALL:supertile($6190, 0)]
 B$6194,4*2
 B$619C,4;28 }
 B$61A0,4;28 {super_tile $6A #HTML[#CALL:supertile($61A0, 0)]
 B$61A4,4*2
 B$61AC,4;28 }
 B$61B0,4;28 {super_tile $6B #HTML[#CALL:supertile($61B0, 0)]
 B$61B4,4*2
 B$61BC,4;28 }
 B$61C0,4;28 {super_tile $6C #HTML[#CALL:supertile($61C0, 0)]
 B$61C4,4*2
 B$61CC,4;28 }
 B$61D0,4;28 {super_tile $6D #HTML[#CALL:supertile($61D0, 0)]
 B$61D4,4*2
 B$61DC,4;28 }
 B$61E0,4;28 {super_tile $6E #HTML[#CALL:supertile($61E0, 0)]
 B$61E4,4*2
 B$61EC,4;28 }
 B$61F0,4;28 {super_tile $6F #HTML[#CALL:supertile($61F0, 0)]
 B$61F4,4*2
 B$61FC,4;28 }
 B$6200,4;28 {super_tile $70 #HTML[#CALL:supertile($6200, 0)]
 B$6204,4*2
 B$620C,4;28 }
 B$6210,4;28 {super_tile $71 #HTML[#CALL:supertile($6210, 0)]
 B$6214,4*2
 B$621C,4;28 }
 B$6220,4;28 {super_tile $72 #HTML[#CALL:supertile($6220, 0)]
 B$6224,4*2
 B$622C,4;28 }
 B$6230,4;28 {super_tile $73 #HTML[#CALL:supertile($6230, 0)]
 B$6234,4*2
 B$623C,4;28 }
 B$6240,4;28 {super_tile $74 #HTML[#CALL:supertile($6240, 0)]
 B$6244,4*2
 B$624C,4;28 }
 B$6250,4;28 {super_tile $75 #HTML[#CALL:supertile($6250, 0)]
 B$6254,4*2
 B$625C,4;28 }
 B$6260,4;28 {super_tile $76 #HTML[#CALL:supertile($6260, 0)]
 B$6264,4*2
 B$626C,4;28 }
 B$6270,4;28 {super_tile $77 #HTML[#CALL:supertile($6270, 0)]
 B$6274,4*2
 B$627C,4;28 }
 B$6280,4;28 {super_tile $78 #HTML[#CALL:supertile($6280, 0)]
 B$6284,4*2
 B$628C,4;28 }
 B$6290,4;28 {super_tile $79 #HTML[#CALL:supertile($6290, 0)]
 B$6294,4*2
 B$629C,4;28 }
 B$62A0,4;28 {super_tile $7A #HTML[#CALL:supertile($62A0, 0)]
 B$62A4,4*2
 B$62AC,4;28 }
 B$62B0,4;28 {super_tile $7B #HTML[#CALL:supertile($62B0, 0)]
 B$62B4,4*2
 B$62BC,4;28 }
 B$62C0,4;28 {super_tile $7C #HTML[#CALL:supertile($62C0, 0)]
 B$62C4,4*2
 B$62CC,4;28 }
 B$62D0,4;28 {super_tile $7D #HTML[#CALL:supertile($62D0, 0)]
 B$62D4,4*2
 B$62DC,4;28 }
 B$62E0,4;28 {super_tile $7E #HTML[#CALL:supertile($62E0, 0)]
 B$62E4,4*2
 B$62EC,4;28 }
 B$62F0,4;28 {super_tile $7F #HTML[#CALL:supertile($62F0, 0)]
 B$62F4,4*2
 B$62FC,4;28 }
 B$6300,4;28 {super_tile $80 #HTML[#CALL:supertile($6300, 0)]
 B$6304,4*2
 B$630C,4;28 }
 B$6310,4;28 {super_tile $81 #HTML[#CALL:supertile($6310, 0)]
 B$6314,4*2
 B$631C,4;28 }
 B$6320,4;28 {super_tile $82 #HTML[#CALL:supertile($6320, 0)]
 B$6324,4*2
 B$632C,4;28 }
 B$6330,4;28 {super_tile $83 #HTML[#CALL:supertile($6330, 0)]
 B$6334,4*2
 B$633C,4;28 }
 B$6340,4;28 {super_tile $84 #HTML[#CALL:supertile($6340, 0)]
 B$6344,4*2
 B$634C,4;28 }
 B$6350,4;28 {super_tile $85 #HTML[#CALL:supertile($6350, 0)]
 B$6354,4*2
 B$635C,4;28 }
 B$6360,4;28 {super_tile $86 #HTML[#CALL:supertile($6360, 0)]
 B$6364,4*2
 B$636C,4;28 }
 B$6370,4;28 {super_tile $87 #HTML[#CALL:supertile($6370, 0)]
 B$6374,4*2
 B$637C,4;28 }
 B$6380,4;28 {super_tile $88 #HTML[#CALL:supertile($6380, 0)]
 B$6384,4*2
 B$638C,4;28 }
 B$6390,4;28 {super_tile $89 #HTML[#CALL:supertile($6390, 0)]
 B$6394,4*2
 B$639C,4;28 }
 B$63A0,4;28 {super_tile $8A #HTML[#CALL:supertile($63A0, 0)]
 B$63A4,4*2
 B$63AC,4;28 }
 B$63B0,4;28 {super_tile $8B #HTML[#CALL:supertile($63B0, 0)]
 B$63B4,4*2
 B$63BC,4;28 }
 B$63C0,4;28 {super_tile $8C #HTML[#CALL:supertile($63C0, 0)]
 B$63C4,4*2
 B$63CC,4;28 }
 B$63D0,4;28 {super_tile $8D #HTML[#CALL:supertile($63D0, 0)]
 B$63D4,4*2
 B$63DC,4;28 }
 B$63E0,4;28 {super_tile $8E #HTML[#CALL:supertile($63E0, 0)]
 B$63E4,4*2
 B$63EC,4;28 }
 B$63F0,4;28 {super_tile $8F #HTML[#CALL:supertile($63F0, 0)]
 B$63F4,4*2
 B$63FC,4;28 }
 B$6400,4;28 {super_tile $90 #HTML[#CALL:supertile($6400, 0)]
 B$6404,4*2
 B$640C,4;28 }
 B$6410,4;28 {super_tile $91 #HTML[#CALL:supertile($6410, 0)]
 B$6414,4*2
 B$641C,4;28 }
 B$6420,4;28 {super_tile $92 #HTML[#CALL:supertile($6420, 0)]
 B$6424,4*2
 B$642C,4;28 }
 B$6430,4;28 {super_tile $93 #HTML[#CALL:supertile($6430, 0)]
 B$6434,4*2
 B$643C,4;28 }
 B$6440,4;28 {super_tile $94 #HTML[#CALL:supertile($6440, 0)]
 B$6444,4*2
 B$644C,4;28 }
 B$6450,4;28 {super_tile $95 #HTML[#CALL:supertile($6450, 0)]
 B$6454,4*2
 B$645C,4;28 }
 B$6460,4;28 {super_tile $96 #HTML[#CALL:supertile($6460, 0)]
 B$6464,4*2
 B$646C,4;28 }
 B$6470,4;28 {super_tile $97 #HTML[#CALL:supertile($6470, 0)]
 B$6474,4*2
 B$647C,4;28 }
 B$6480,4;28 {super_tile $98 #HTML[#CALL:supertile($6480, 0)]
 B$6484,4*2
 B$648C,4;28 }
 B$6490,4;28 {super_tile $99 #HTML[#CALL:supertile($6490, 0)]
 B$6494,4*2
 B$649C,4;28 }
 B$64A0,4;28 {super_tile $9A #HTML[#CALL:supertile($64A0, 0)]
 B$64A4,4;28 [unused by map]
 B$64A8,4
 B$64AC,4;28 }
 B$64B0,4;28 {super_tile $9B #HTML[#CALL:supertile($64B0, 0)]
 B$64B4,4*2
 B$64BC,4;28 }
 B$64C0,4;28 {super_tile $9C #HTML[#CALL:supertile($64C0, 0)]
 B$64C4,4*2
 B$64CC,4;28 }
 B$64D0,4;28 {super_tile $9D #HTML[#CALL:supertile($64D0, 0)]
 B$64D4,4*2
 B$64DC,4;28 }
 B$64E0,4;28 {super_tile $9E #HTML[#CALL:supertile($64E0, 0)]
 B$64E4,4*2
 B$64EC,4;28 }
 B$64F0,4;28 {super_tile $9F #HTML[#CALL:supertile($64F0, 0)]
 B$64F4,4*2
 B$64FC,4;28 }
 B$6500,4;28 {super_tile $A0 #HTML[#CALL:supertile($6500, 0)]
 B$6504,4*2
 B$650C,4;28 }
 B$6510,4;28 {super_tile $A1 #HTML[#CALL:supertile($6510, 0)]
 B$6514,4*2
 B$651C,4;28 }
 B$6520,4;28 {super_tile $A2 #HTML[#CALL:supertile($6520, 0)]
 B$6524,4*2
 B$652C,4;28 }
 B$6530,4;28 {super_tile $A3 #HTML[#CALL:supertile($6530, 0)]
 B$6534,4*2
 B$653C,4;28 }
 B$6540,4;28 {super_tile $A4 #HTML[#CALL:supertile($6540, 0)]
 B$6544,4*2
 B$654C,4;28 }
 B$6550,4;28 {super_tile $A5 #HTML[#CALL:supertile($6550, 0)]
 B$6554,4*2
 B$655C,4;28 }
 B$6560,4;28 {super_tile $A6 #HTML[#CALL:supertile($6560, 0)]
 B$6564,4*2
 B$656C,4;28 }
 B$6570,4;28 {super_tile $A7 #HTML[#CALL:supertile($6570, 0)]
 B$6574,4*2
 B$657C,4;28 }
 B$6580,4;28 {super_tile $A8 #HTML[#CALL:supertile($6580, 0)]
 B$6584,4*2
 B$658C,4;28 }
 B$6590,4;28 {super_tile $A9 #HTML[#CALL:supertile($6590, 0)]
 B$6594,4*2
 B$659C,4;28 }
 B$65A0,4;28 {super_tile $AA #HTML[#CALL:supertile($65A0, 0)]
 B$65A4,4*2
 B$65AC,4;28 }
 B$65B0,4;28 {super_tile $AB #HTML[#CALL:supertile($65B0, 0)]
 B$65B4,4*2
 B$65BC,4;28 }
 B$65C0,4;28 {super_tile $AC #HTML[#CALL:supertile($65C0, 0)]
 B$65C4,4*2
 B$65CC,4;28 }
 B$65D0,4;28 {super_tile $AD #HTML[#CALL:supertile($65D0, 0)]
 B$65D4,4*2
 B$65DC,4;28 }
 B$65E0,4;28 {super_tile $AE #HTML[#CALL:supertile($65E0, 0)]
 B$65E4,4*2
 B$65EC,4;28 }
 B$65F0,4;28 {super_tile $AF #HTML[#CALL:supertile($65F0, 0)]
 B$65F4,4*2
 B$65FC,4;28 }
 B$6600,4;28 {super_tile $B0 #HTML[#CALL:supertile($6600, 0)]
 B$6604,4*2
 B$660C,4;28 }
 B$6610,4;28 {super_tile $B1 #HTML[#CALL:supertile($6610, 0)]
 B$6614,4*2
 B$661C,4;28 }
 B$6620,4;28 {super_tile $B2 #HTML[#CALL:supertile($6620, 0)]
 B$6624,4*2
 B$662C,4;28 }
 B$6630,4;28 {super_tile $B3 #HTML[#CALL:supertile($6630, 0)]
 B$6634,4*2
 B$663C,4;28 }
 B$6640,4;28 {super_tile $B4 #HTML[#CALL:supertile($6640, 0)]
 B$6644,4*2
 B$664C,4;28 }
 B$6650,4;28 {super_tile $B5 #HTML[#CALL:supertile($6650, 0)]
 B$6654,4*2
 B$665C,4;28 }
 B$6660,4;28 {super_tile $B6 #HTML[#CALL:supertile($6660, 0)]
 B$6664,4*2
 B$666C,4;28 }
 B$6670,4;28 {super_tile $B7 #HTML[#CALL:supertile($6670, 0)]
 B$6674,4*2
 B$667C,4;28 }
 B$6680,4;28 {super_tile $B8 #HTML[#CALL:supertile($6680, 0)]
 B$6684,4*2
 B$668C,4;28 }
 B$6690,4;28 {super_tile $B9 #HTML[#CALL:supertile($6690, 0)]
 B$6694,4*2
 B$669C,4;28 }
 B$66A0,4;28 {super_tile $BA #HTML[#CALL:supertile($66A0, 0)]
 B$66A4,4*2
 B$66AC,4;28 }
 B$66B0,4;28 {super_tile $BB #HTML[#CALL:supertile($66B0, 0)]
 B$66B4,4*2
 B$66BC,4;28 }
 B$66C0,4;28 {super_tile $BC #HTML[#CALL:supertile($66C0, 0)]
 B$66C4,4*2
 B$66CC,4;28 }
 B$66D0,4;28 {super_tile $BD #HTML[#CALL:supertile($66D0, 0)]
 B$66D4,4*2
 B$66DC,4;28 }
 B$66E0,4;28 {super_tile $BE #HTML[#CALL:supertile($66E0, 0)]
 B$66E4,4*2
 B$66EC,4;28 }
 B$66F0,4;28 {super_tile $BF #HTML[#CALL:supertile($66F0, 0)]
 B$66F4,4*2
 B$66FC,4;28 }
 B$6700,4;28 {super_tile $C0 #HTML[#CALL:supertile($6700, 0)]
 B$6704,4*2
 B$670C,4;28 }
 B$6710,4;28 {super_tile $C1 #HTML[#CALL:supertile($6710, 0)]
 B$6714,4*2
 B$671C,4;28 }
 B$6720,4;28 {super_tile $C2 #HTML[#CALL:supertile($6720, 0)]
 B$6724,4*2
 B$672C,4;28 }
 B$6730,4;28 {super_tile $C3 #HTML[#CALL:supertile($6730, 0)]
 B$6734,4*2
 B$673C,4;28 }
 B$6740,4;28 {super_tile $C4 #HTML[#CALL:supertile($6740, 0)]
 B$6744,4*2
 B$674C,4;28 }
 B$6750,4;28 {super_tile $C5 #HTML[#CALL:supertile($6750, 0)]
 B$6754,4*2
 B$675C,4;28 }
 B$6760,4;28 {super_tile $C6 #HTML[#CALL:supertile($6760, 0)]
 B$6764,4*2
 B$676C,4;28 }
 B$6770,4;28 {super_tile $C7 #HTML[#CALL:supertile($6770, 0)]
 B$6774,4*2
 B$677C,4;28 }
 B$6780,4;28 {super_tile $C8 #HTML[#CALL:supertile($6780, 0)]
 B$6784,4*2
 B$678C,4;28 }
 B$6790,4;28 {super_tile $C9 #HTML[#CALL:supertile($6790, 0)]
 B$6794,4*2
 B$679C,4;28 }
 B$67A0,4;28 {super_tile $CA #HTML[#CALL:supertile($67A0, 0)]
 B$67A4,4*2
 B$67AC,4;28 }
 B$67B0,4;28 {super_tile $CB #HTML[#CALL:supertile($67B0, 0)]
 B$67B4,4*2
 B$67BC,4;28 }
 B$67C0,4;28 {super_tile $CC #HTML[#CALL:supertile($67C0, 0)]
 B$67C4,4*2
 B$67CC,4;28 }
 B$67D0,4;28 {super_tile $CD #HTML[#CALL:supertile($67D0, 0)]
 B$67D4,4*2
 B$67DC,4;28 }
 B$67E0,4;28 {super_tile $CE #HTML[#CALL:supertile($67E0, 0)]
 B$67E4,4*2
 B$67EC,4;28 }
 B$67F0,4;28 {super_tile $CF #HTML[#CALL:supertile($67F0, 0)]
 B$67F4,4*2
 B$67FC,4;28 }
 B$6800,4;28 {super_tile $D0 #HTML[#CALL:supertile($6800, 0)]
 B$6804,4*2
 B$680C,4;28 }
 B$6810,4;28 {super_tile $D1 #HTML[#CALL:supertile($6810, 0)]
 B$6814,4*2
 B$681C,4;28 }
 B$6820,4;28 {super_tile $D2 #HTML[#CALL:supertile($6820, 0)]
 B$6824,4*2
 B$682C,4;28 }
 B$6830,4;28 {super_tile $D3 #HTML[#CALL:supertile($6830, 0)]
 B$6834,4*2
 B$683C,4;28 }
 B$6840,4;28 {super_tile $D4 #HTML[#CALL:supertile($6840, 0)]
 B$6844,4*2
 B$684C,4;28 }
 B$6850,4;28 {super_tile $D5 #HTML[#CALL:supertile($6850, 0)]
 B$6854,4*2
 B$685C,4;28 }
 B$6860,4;28 {super_tile $D6 #HTML[#CALL:supertile($6860, 0)]
 B$6864,4*2
 B$686C,4;28 }
 B$6870,4;28 {super_tile $D7 #HTML[#CALL:supertile($6870, 0)]
 B$6874,4*2
 B$687C,4;28 }
 B$6880,4;28 {super_tile $D8 #HTML[#CALL:supertile($6880, 0)]
 B$6884,4*2
 B$688C,4;28 }
 B$6890,4;28 {super_tile $D9 #HTML[#CALL:supertile($6890, 0)]
 B$6894,4*2
 B$689C,4;28 }

; Index of the current room, or 0 when outside.
@label=room_index
gB$68A0,1

; The current door id.
@label=current_door
gB$68A1,1

; The current visible character is made to change room.
;
; Used by the routines at #R$B1F5, #R$B32D, #R$CA81, #R$CB98 and #R$EFCB.
;
;!I:HL Pointer to position. FIXME: Specify type.
; I:IY Pointer to current visible character.
@label=transition
cC$68A2,1;21 Save position into #REGde
 C$68A3,2;21 {Copy the current visible character pointer into #REGhl
 C$68A5,1;21 }
 C$68A6,1;21 Extract visible character's offset
 C$68A7,1;21 Save it for later.
 C$68A8,2;21 {Point #REGhl at the visible character's position
 C$68AA,1;21 }
 C$68AB,3;21 Fetch the visible character's current room index
 C$68AE,1;21 Are we outdoors?
 C$68AF,3;21 Jump if not
; We're outdoors.
; .
; Set position on X, Y axis and height by multiplying by 4.
 C$68B2,2;21 Iterate thrice: X, Y and height fields
*C$68B4,1;21 Save #REGbc - #R$B295's output register
 C$68B5,1;21 Fetch a position byte
 C$68B6,3;21 Multiply it by 4, widening it to a word in #REGbc
 C$68B9,1;21 {Store it to visible character's position and increment pointers
 C$68BA,3;21
 C$68BD,1;21 }
 C$68BE,1;21 Restore
 C$68BF,2;21 Loop
 C$68C1,2;21 !Jump over indoors case (ELSE part)
; We're indoors.
; .
; Set position on X, Y axis and height by copying.
*C$68C3,2;21 Iterate thrice: X, Y and height fields
*C$68C5,1;21 {Widen position bytes to words, store and increment pointers
 C$68C6,5;21
 C$68CB,1;21 }
 C$68CC,2;21 Loop
*C$68CE,1;21 Retrieve vischar index/offset stacked at $68A7
 C$68CF,1
 C$68D0,1;21 Is it the hero?
 C$68D1,3;21 Jump if so
; Not the hero.
; .
; This is an unusual construct. Why did the author not use JP NZ,$C5D3 above and fallthrough otherwise?
 C$68D4,3;21 If not, exit via #R$C5D3 resetting the visible character
; Hero only.
; .
; #REGhl points to the hero's visible character at this point.
*C$68D7,1;21 Point #REGhl at the visible character's flags field (always $8001)
 C$68D8,2;21 Clear vischar_FLAGS_NO_COLLIDE in flags
 C$68DA,3;21 Get the visible character's room index
 C$68DD,3;21 Set the global current room index
 C$68E0,1;21 Are we outdoors?
 C$68E1,3;21 Jump if not
; We're outdoors.
 C$68E4,2;21 {Point #REGhl at the visible character's input field (always $800D)
 C$68E6,1;21
 C$68E7,1;21 }
 C$68E8,2;21 !Set input to input_KICK (so the character is reset???)
 C$68EA,1;21 Point #REGhl at the visible character's direction field (always $800E)
 C$68EB,1;21 {Fetch the direction field and clear the non-direction bits, resetting the crawl flag
 C$68EC,2;21
 C$68EE,1;21 }
 C$68EF,3;21 Reset the hero's position, redraw the scene then zoombox it onto the screen
 C$68F2,2;21 Restart from main loop

; The hero enters a room.
;
; Used by the routines at #R$68A2, #R$9D78, #R$9DE5 and #R$B75A.
@label=enter_room
cC$68F4,3;21 {Reset the game_window_offset X and Y coordinates to zero
 C$68F7,3;21 }
 C$68FA,3;21 Setup the room
 C$68FD,3;21 Expand tile buffer into screen buffer
 C$6900,3;21 {Set the map_position to (116,234)
 C$6903,3;21 }
 C$6906,3;21 Set appropriate sprite for the room (standing or crawl)
 C$6909,3;21 {Reset the hero's screen position
 C$690C,3;21 }
 C$690F,3;21 Setup movable items
 C$6912,3;21 Zoombox the scene onto the screen
 C$6915,2;21 {Increment score by one
 C$6917,3;21 }
; FALL THROUGH into squash_stack_goto_main.

; Squash the stack then jump into the game's main loop.
;
; Used by the routines at #R$68A2 and #R$68F4 (a fall through).
@label=squash_stack_goto_main
cC$691A,3;21 Set stack to the very top of RAM
 C$691D,3;21 Jump to the start of the game's main loop

; Set appropriate hero sprite for room.
;
; Used by the routine at #R$68F4.
; .
; Called when changing rooms.
@label=set_hero_sprite_for_room
@nowarn
cC$6920,3;21 {Set the hero's visible character input field to input_KICK
 C$6923,2;21 }
 C$6925,1;21 Point #REGhl at vischar.direction ($800E)
; vischar_DIRECTION_CRAWL is set, or cleared, here but not tested directly
; anywhere else so it must be an offset into animindices[].
; .
; When in tunnel rooms force the hero sprite to 'prisoner' and set the crawl
; flag appropriately.
 C$6926,3;21 {If the global current room index is room_29_SECOND_TUNNEL_START or above...
 C$6929,2;21
 C$692B,2;21 }
; We're in a tunnel room.
 C$692D,2;21 Set the vischar_DIRECTION_CRAWL bit on vischar.direction
 C$692F,3;21 {Set vischar.mi.sprite to the prisoner sprite set
 C$6932,3;21 }
 C$6935,1;21 Return
; We're not in a tunnel room.
*C$6936,2;21 Clear the vischar_DIRECTION_CRAWL bit from vischar.direction
 C$6938,1;21 Return

; Setup movable items.
;
; "Movable items" are the stoves and the crate which appear in three rooms in the game. Unlike ordinary items such as keys and the radio the movable items can be pushed around by the hero character walking into them. Internally they use the second visible character slot.
; .
; Used by the routines at #R$68F4 and #R$B2FC.
@label=setup_movable_items
cC$6939,3;24 Reset all non-player visible characters
 C$693C,3;24 Get global current room index
 C$693F,2;24 {If current room index is room_2_HUT2LEFT then jump to setup_stove1
 C$6941,6;24
 C$6947,2;24 }
*C$6949,2;24 {If current room index is room_4_HUT3LEFT then jump to setup_stove2
 C$694B,6;24
 C$6951,2;24 }
*C$6953,2;24 {If current room index is room_9_CRATE then jump to setup_crate
 C$6955,3;24
 C$6958,3;24 }
*C$695B,3;24 Spawn characters
 C$695E,3;24 Mark nearby items
 C$6961,3;24 Animate all visible characters
 C$6964,3;24 Move the map
 C$6967,3;24 Plot vischars and items
@label=setup_crate
*C$696A,3;24 Point #REGhl at movable_item_crate
 C$696D,2;24 Set #REGa to character index character_28_CRATE
 C$696F,2;24 Jump to setup_movable_item
@label=setup_stove2
*C$6971,3;24 Point #REGhl at movable_item_stove2
 C$6974,2;24 Set #REGa to character index character_27_STOVE_2
 C$6976,2;24 Jump to setup_movable_item
@label=setup_stove1
*C$6978,3;24 Point #REGhl at movable_item_stove1
 C$697B,2;24 Set #REGa to character index character_26_STOVE_1
; Using the movable item specific data and a generic item reset data, setup the second visible character as a movable item.
@label=setup_movable_item
@nowarn
 C$697D,3;24 Assign the character index in #REGa to the second visible character's character field
 C$6980,3;24 {Copy nine bytes of item-specific movable item data over the second visible character data
 C$6983,3;24
 C$6986,2;24 }
@nowarn
 C$6988,3;24 {Copy fourteen bytes of visible character data over the vischar
 C$698B,6;24
 C$6991,2;24 }
 C$6993,3;24 {Set the visible character's room index to the global current room index
 C$6996,3;24 }
@nowarn
 C$6999,3;24 Point #REGhl at the second visible character
 C$699C,3;24 Set saved_pos
 C$699F,1;24 Return
; Fourteen bytes of visible character reset data.
@label=movable_item_reset_data
 B$69A0,1;24 Flags
 W$69A1,2;24 Route
 B$69A3,3;24 Position
 B$69A6,1;24 Counter and flags
 W$69A7,2;24 Animation base = &animations[0]
 W$69A9,2;24 Animation      = animations[8] // anim_wait_tl animation
 B$69AB,1;24 Animation index
 B$69AC,1;24 Input
 B$69AD,1;24 Direction
; Movable items.
;
; struct movable_item { word x_coord, y_coord, height; const sprite *; byte index; };
; .
; Sub-struct of vischar ($802F..$8038).
@label=movable_item_stove1
 W$69AE,6;30 Position (62, 35, 16)
 W$69B4,2;30 Sprite: sprite_stove
 B$69B6,1;30 Index: 0
@label=movable_item_crate
 W$69B7,6;30 Position (55, 54, 14)
 W$69BD,2;30 Sprite: sprite_crate
 B$69BF,1;30 Index: 0
@label=movable_item_stove2
 W$69C0,6;30 Position (62, 35, 16)
 W$69C6,2;30 Sprite: sprite_stove
 B$69C8,1;30 Index: 0

; Reset all seven non-player visible characters.
;
; Used by the routine at #R$6939 only. (!could merge into the above)
@label=reset_nonplayer_visible_characters
@nowarn
cC$69C9,3;21 Start at the first visible character (hero is the zeroth)
 C$69CC,3;21 Set #REGb for seven iterations and set #REGc for a 32 byte stride simultaneously
; Start loop
*C$69CF,1;21 {Reset the visible character at #REGhl
 C$69D0,5;21
 C$69D5,1;21 }
 C$69D6,1;21 {Step #REGhl to the next visible character
 C$69D7,1;21
 C$69D8,1;21 }
 C$69D9,2;21 ...loop
 C$69DB,1;21 Return

; Setup interior doors.
;
; Used by the routine at #R$6A35 only.
;
; .
;
@label=setup_doors
; Clear the interior_doors[] array with door_NONE ($FF).
cC$69DC,2;21 Set #REGa to door_NONE
 C$69DE,3;21 Set #REGde to the final byte of interior_doors[] (byte 4)
 C$69E1,2;21 {Set all four bytes to door_NONE
*C$69E3,1;21
 C$69E4,1;21
 C$69E5,2;21 }
; Setup to populate interior_doors[].
 C$69E7,1;21 Set #REGde to the first interior_doors[] byte
 C$69E8,3;21 {Fetch and shift the global current room index up by two bits, to match door_flags, then store it in #REGb
 C$69EB,2;21
 C$69ED,1;21 }
 C$69EE,2;21 Initialise the door index
 C$69F0,1;21 Switch register banks for the iteration
; We're about to walk through doors[] and extract the indices of the doors relevant to the current room.
 C$69F1,3;21 Point #REGhl' to the first byte of doors[]
 C$69F4,2;21 Set #REGb' to the number of entries in doors[] (124)
 C$69F6,3;21 Set #REGde' to the stride of four bytes (each door is a room_and_direction byte followed by a 3-byte position)
; Start loop
; .
; Save any door index which matches the current room.
*C$69F9,1;21 Fetch door's room_and_direction
 C$69FA,1;21 Switch registers back to the set used on entry to the routine
 C$69FB,2;21 Clear room_and_direction's direction bits (door_FLAGS_MASK_DIRECTION)
 C$69FD,1;21 Is it the current room?
 C$69FE,2;21 Jump if not
; This is the current room.
 C$6A00,1;21 {Write to #REGde register #REGc toggled with door_REVERSE
 C$6A01,3;21
 C$6A04,1;21 }
*C$6A05,1;21 {Toggle door_REVERSE in #REGc for the next iteration
 C$6A06,2;21 }
 C$6A08,3;21 Jump if (#REGc >= door_REVERSE)
 C$6A0B,1;21 {Increment the door index once every two steps through the array
*C$6A0C,1;21 }
 C$6A0D,1;21 Switch registers again
 C$6A0E,1;21 Step #REGhl' to the next door
 C$6A0F,2;21 ...loop
 C$6A11,1;21 Return

; Turn a door index into a door_t pointer.
;
; Used by the routines at #R$B32D, #R$B4D0, #R$C651 and #R$CA81.
;
; I:A  Index of door + reverse flag in bit 7.
; O:HL Pointer to door_t.
@label=get_door
cC$6A12,1;21 Save the original #REGa so we can test its flag bit in a moment
 C$6A13,1;21 First double #REGa since doors[] contains pairs of doors. This also discards the flag in bit 7
 C$6A14,1;21 {Form the address of doors[#REGa] in #REGhl
 C$6A15,7;21
 C$6A1C,1;21 }
 C$6A1D,2;21 Was the door_REVERSE flag bit set on entry?
 C$6A1F,1;21 If not, return with #REGhl pointing to the entry
 C$6A20,1;21 {Otherwise, point to the next entry along
 C$6A21,4;21
 C$6A25,1;21 }
 C$6A26,1;21 Return

; Wipe the visible tiles array.
;
; Used by the routines at #R$6A35, #R$A50B and #R$AB6B.
@label=wipe_visible_tiles
cC$6A27,3;21 {Set all RAM from $F0F8 to $F0F8 + 24 * 17 - 1 to zero
 C$6A2A,8;21
 C$6A32,2;21 }
 C$6A34,1;21 Return

; Expand out the room definition for room_index.
;
; Used by the routines at #R$68F4, #R$7B36, #R$9E07, #R$A289, #R$A2E2, #R$A479
; and #R$B3F6.
@label=setup_room
cC$6A35,3;21 Wipe the visible tiles array
; Form the address of rooms_and_tunnels[room_index - 1] in #REGhl.
 C$6A38,3;21 Fetch the global current room index
 C$6A3B,1;21 Double it so we can index rooms_and_tunnels[]
@isub=LD HL,rooms_and_tunnels - 2
 C$6A3C,3;21 Point #REGhl at #R$6BAD rooms_and_tunnels[-1]
 C$6A3F,1;21 {#REGhl + #REGa
 C$6A40,3;21
 C$6A43,1;21 }
*C$6A44,1;21 {Fetch room pointer in #REGhl
 C$6A45,2;21
 C$6A47,1;21 }
 C$6A48,1;21 Push it
 C$6A49,3;21 Setup interior doors
 C$6A4C,1;21 Pop it
; Copy the count of boundaries into state.
 C$6A4D,3;21 Point DE at #R$81BE roomdef_bounds_index
 C$6A50,2;21 Copy first byte of roomdef into roomdef_bounds_index. (DE, HL incremented).
; DE now points to #R$81BF
; .
; Copy all boundary structures into state, if any.
 C$6A52,1;21 Fetch count of boundaries
 C$6A53,1;21 Is it zero?
 C$6A54,1;21 Store it irrespectively.
 C$6A55,2;21 No, jump to copying step
 C$6A57,1;21 Skip roomdef count of boundaries
 C$6A58,2;21 Jump to mask copying
*C$6A5A,1;21 {Multiply #REGa by four (size of boundary structures) then add one (skip current counter) == size of boundary structures
 C$6A5B,1;21
 C$6A5C,1;21 }
 C$6A5D,1;21 {Copy all boundary structures
 C$6A5E,2;21
 C$6A60,2;21 }
; Copy interior mask into interior_mask_data.
*C$6A62,3;21 Point #REGde at interior_mask_data
 C$6A65,1;21 Get count of interior masks
 C$6A66,1;21 Step
 C$6A67,1;21 Write it out
 C$6A68,1;21 Is the count non-zero?
 C$6A69,2;21 Jump if not
 C$6A6B,1;21 Skip over the written count
 C$6A6C,1;21 #REGb is our loop counter
; Start loop
; .
; interior_mask_data holds indices into interior_mask_data_source[].
*C$6A6D,1;21
 C$6A6E,1;21
 C$6A6F,1;21 {Fetch an index (from roomdef?)
 C$6A70,2;21 }
 C$6A72,1;21 {#REGbc = #REGhl
 C$6A73,1;21 }
 C$6A74,1;21 {Multiply it by eight
 C$6A75,1;21
 C$6A76,1;21 }
 C$6A77,1;21 Clear the carry flag
 C$6A78,2;21 Final offset is index * 7
 C$6A7A,3;21 Point at interior_mask_data_source
 C$6A7D,1;21 Form the address of the mask data
 C$6A7E,3;21 Width of mask data
 C$6A81,2;21 Copy it
 C$6A83,2;21 {Constant final byte is always 32
 C$6A85,1;21
 C$6A86,1;21 }
 C$6A87,3;21
 C$6A8A,2;21 ...loop
; Plot all objects (as tiles).
*C$6A8C,1;21 Count of objects
 C$6A8D,1;21
 C$6A8E,1;21 Is it zero?
 C$6A8F,1;21 Return if so
 C$6A90,1;21 Skip the count
; Start loop: for every object in the roomdef
*C$6A91,1
 C$6A92,1;21 Fetch the object index
 C$6A93,1;21
 C$6A94,1;21 Fetch the column
 C$6A95,3;21
; Plot the object into the visible tiles array
 C$6A98,2;21 {#REGde = $F0F8 + row * 24 + column.
 C$6A9A,12;21
*C$6AA6,3;21
 C$6AA9,1;21
 C$6AAA,1;21 }
 C$6AAB,1;21
 C$6AAC,3;21 Expand RLE-encoded object out to a set of tile references
 C$6AAF,3;21
 C$6AB2,2;21 ...loop
 C$6AB4,1;21 Return

; Expands RLE-encoded objects to a full set of tile references.
;
; Used by the routine at #R$6A35.
; .
; Object format:
; #TABLE(default)
; { =c2 Each object starts with two bytes which specify its dimensions: }
; { <w> <h>               | Width in tiles, Height in tiles }
; { =c2 Which are then followed by a repetition of the following bytes: }
; { <t>                   | Literal: Emit tile <t> }
; { <0xFF> <0xFF>         | Escape: Emit <0xFF> }
; { <0xFF> <128..254> <t> | Repetition: Emit tile <t> up to 126 times }
; { <0xFF> <64..79> <t>   | Range: Emit tile <t> <t+1> <t+2> .. up to <t+15> }
; { <0xFF> <other>        | Other encodings are not used }
; TABLE#
; .
; Tile references of zero produce no output.
;
; I:A  Object index.
; I:DE Tile buffer location to expand to.
@label=expand_object
cC$6AB5,1;21 {Fetch the object pointer from #R$7095[A] into #REGhl
 C$6AB6,10;21
 C$6AC0,1;21 }
 C$6AC1,1;21 {Fetch the object's width (in tiles)
 C$6AC2,1;21 }
 C$6AC3,1;21 {Fetch the object's height (in tiles)
 C$6AC4,1;21 }
 C$6AC5,1;21 {Self modify the "LD B,$xx" at #R$6AE6 to load the tile-width into #REGb
@isub=LD (end_of_row + 1),A
 C$6AC6,3;21 }
; Start main expand loop
@label=expand
*C$6AC9,1;21 Fetch the next byte
 C$6ACA,2;21 Is it an escape byte? (interiorobjecttile_ESCAPE/$FF)
 C$6ACC,2;21 Jump if not
; Handle an escape byte - indicating an encoded sequence
 C$6ACE,1;21 Step over the escape byte
 C$6ACF,1;21 Fetch the next byte
 C$6AD0,2;21 Is it also an escape byte?
 C$6AD2,2;21 Jump to tile write op if so - we'll emit $FF (Note: Could jump two instructions later)
 C$6AD4,2;21 Isolate the top nibble - the top two bits are flags (Note: This could move down to before the $40 test without affecting anything)
 C$6AD6,2;21 Is it >= 128?
 C$6AD8,2;21 Jump to repetition handling if so
 C$6ADA,2;21 Is it == 64?
 C$6ADC,2;21 Jump to range handling if so
@label=write_tile
*C$6ADE,1;21 {Write out the tile if it's non-zero
 C$6ADF,2;21
 C$6AE1,1;21 }
*C$6AE2,1;21 Move to next input byte
 C$6AE3,1;21 Move to next output byte
 C$6AE4,2;21 ...loop while width counter #REGb is non-zero
@label=end_of_row
 C$6AE6,2;21 Reset width counter. Self modified by #R$6AC5
 C$6AE8,2;21 Width of tile buffer is 24
 C$6AEA,1;21 Tile buffer width minus width of object gives the rowskip
 C$6AEB,1;21 {Add #REGa to #REGde to move by rowskip
 C$6AEC,3;21
 C$6AEF,1;21 }
*C$6AF0,1;21 Decrement row counter
 C$6AF1,2;21 ...loop to expand while row > 0
 C$6AF3,1;21 Return
; Escape + 128..255 case: emit a repetition of the same byte
@label=repetition
*C$6AF4,1;21 Fetch flags+count byte
 C$6AF5,2;21 Mask off top bit to get repetition counter/length
 C$6AF7,1;21 Bank repetition counter
 C$6AF8,1;21 Move to the next tile value
 C$6AF9,1;21 Fetch a tile value
 C$6AFA,1;21 Unbank repetition counter ready for the next bank
; Start of repetition loop
@label=repetition_loop
*C$6AFB,1;21 Bank the repetition counter
 C$6AFC,1;21 Is the tile value zero?
 C$6AFD,2;21 Jump if so, avoiding the write
 C$6AFF,1;21 Write it
*C$6B00,1;21 Move to next tile output byte
 C$6B01,2;21 Decrement the width counter. Jump over the end-of-row code to #R$6B12 if it's non-zero
; Ran out of width / end of row
@isub=LD A,(end_of_row + 1)
 C$6B03,3;21 Fetch width (from self modified instruction) into #REGa'
 C$6B06,1;21 Reset width counter
 C$6B07,2;21 Width of tile buffer is 24
 C$6B09,1;21 Tile buffer width minus width of object gives the rowskip
 C$6B0A,1;21 {Add #REGa to #REGde to move by rowskip
 C$6B0B,3;21
 C$6B0E,1;21 }
*C$6B0F,1;21 Fetch the next tile value (reload)
 C$6B10,1;21 Decrement the row counter
 C$6B11,1;21 Return if it hit zero
@label=repetition_end
*C$6B12,1;21 Unbank the repetition counter
 C$6B13,1;21 Decrement the repetition counter
 C$6B14,2;21 ...loop if non-zero
 C$6B16,1;21 Advance the data pointer
 C$6B17,2;21 Jump to main expand loop
; Escape + 64..79 case: emit an ascending range of bytes
@label=range
@rfix-begin
; .
; Bug: This self-modifies the INC A at #R$6B28 at the end of the loop body, but
; nothing else in the code modifies it! Possible evidence that other encodings
; (e.g. 'DEC A') were attempted.
*C$6B19,2;21 {Make the instruction at #R$6B28 an 'INC A'
@nowarn
 C$6B1B,3;21 }
@rfix-end
 C$6B1E,1;21 Fetch flags+count byte
 C$6B1F,2;21 Mask off the bottom nibble which contains the range counter
 C$6B21,1;21 Bank the range counter
 C$6B22,1;21 Move to the first tile value
 C$6B23,1;21 Get the first tile value
 C$6B24,1;21 Unbank the range counter ready for the next bank
; Start of range loop
@label=range_loop
*C$6B25,1;21 Bank the range counter
 C$6B26,1;21 Write the tile value (Note: We assume it's non-zero)
 C$6B27,1;21 Move to the next tile output byte
@label=expand_object_increment
 C$6B28,1;21 Increment the tile value. Self modified by #R$6B1B
 C$6B29,2;21 Decrement width counter. Jump over the end-of-row code to #R$6B3B if it's non-zero
; Ran out of width / end of row
 C$6B2B,1;21 Stash the tile value
@isub=LD A,(reset_width + 1)
 C$6B2C,3;21 Fetch width (from self modified instruction) into #REGa'
 C$6B2F,1;21 Reset width counter
 C$6B30,2;21 Width of tile buffer is 24
 C$6B32,1;21 Tile buffer width minus width of object gives the rowskip
 C$6B33,1;21 {Add #REGa to #REGde to move by rowskip
 C$6B34,3;21
 C$6B37,1;21 }
*C$6B38,1;21 Unstash the tile value
 C$6B39,1;21 Decrement row counter
 C$6B3A,1;21 Return if it hit zero
@label=range_end
*C$6B3B,1;21 Unbank the range counter
 C$6B3C,1;21 Decrement the range counter
 C$6B3D,2;21 ...loop if non-zero
 C$6B3F,1;21 Advance the data pointer
 C$6B40,2;21 Jump to main expand loop

; Expand all of the tile indices in the tiles buffer to full tiles in the
; screen buffer.
;
; Used by the routines at #R$68F4, #R$7B36, #R$9E07, #R$A289, #R$A2E2, #R$A479,
; #R$A50B, #R$AB6B and #R$B3F6.
@label=plot_interior_tiles
cC$6B42,3;21 Point #REGhl at the screen buffer's start address
 C$6B45,3;21 Point #REGde at the visible tiles array
 C$6B48,2;21 Set row counter to 16
; For every row
@label=row_loop
*C$6B4A,2;21 Set column counter to 24
; For every column
@label=column_loop
*C$6B4C,1;21 Stack screen buffer pointer while we form a tile pointer
 C$6B4D,1;21 Load a tile index
 C$6B4E,1;21 Bank outer registers
 C$6B4F,1;21 {Point #REGhl at interior_tiles[tile index]
 C$6B50,8;21
 C$6B58,1;21 }
 C$6B59,1;21 Unstack screen buffer pointer
 C$6B5A,3;21 Simultaneously set #REGb for eight iterations and #REGc for a 24 byte stride
@label=tile_loop
*C$6B5D,1;21 {Transfer a byte (a row) of tile across
 C$6B5E,1;21 }
 C$6B5F,1;21 {Advance the screen buffer pointer by the stride
 C$6B60,4;21
*C$6B64,1;21
 C$6B65,1;21 }
 C$6B66,2;21 ...loop for each byte of the tile
; End of column
 C$6B68,1;21 Unbank outer registers
 C$6B69,1;21 Move to next input tile
 C$6B6A,1;21 Move to next screen buffer output
 C$6B6B,2;21 ...loop for each column
; End of row
 C$6B6D,2;21 {Move to the next screen buffer row (seven rows down)
 C$6B6F,4;21
*C$6B73,1;21 }
 C$6B74,1;21 {...loop for each row
 C$6B75,3;21 }
; End
 C$6B78,1;21 Return

; Locations of beds.
;
; 6x pointers to bed. These are the beds of active prisoners.
; .
; Note that the top hut has prisoners permanently in bed.
@label=beds
wW$6B79,2;21 &roomdef_3_hut2_right[29]
 W$6B7B,2;21 &roomdef_3_hut2_right[32]
 W$6B7D,2;21 &roomdef_3_hut2_right[35]
 W$6B7F,2;21 &roomdef_5_hut3_right[29]
 W$6B81,2;21 &roomdef_5_hut3_right[32]
 W$6B83,2;21 &roomdef_5_hut3_right[35]

; Room dimensions.
;
; The room definitions specify their dimensions via an index into this table.
; .
; #TABLE(default)
; { =h Type | =h Bytes | =h Name | =h Meaning }
; { Byte    |        1 | x1      | Maximum x }
; { Byte    |        1 | x0      | Minimum x }
; { Byte    |        1 | y1      | Maximum y }
; { Byte    |        1 | y0      | Minimum y }
; TABLE#
; .
; Used by #R$B29F only.
@label=roomdef_dimensions
bB$6B85,4;28 ( 66, 26,  70, 22)
 B$6B89,4;28 ( 62, 22,  58, 26)
 B$6B8D,4;28 ( 54, 30,  66, 18)
 B$6B91,4;28 ( 62, 30,  58, 34)
 B$6B95,4;28 ( 74, 18,  62, 30)
 B$6B99,4;28 ( 56, 50, 100, 10)
 B$6B9D,4;28 (104,  6,  56, 50)
 B$6BA1,4;28 ( 56, 50, 100, 26)
 B$6BA5,4;28 (104, 28,  56, 50)
 B$6BA9,4;28 ( 56, 50,  88, 10)

; Room and tunnel definitions.
;
; Array of pointers to rooms (starting with room 1).
@label=rooms_and_tunnels
wW$6BAD,2;21 &roomdef_1_hut1_right,
 W$6BAF,2;21 &roomdef_2_hut2_left,
 W$6BB1,2;21 &roomdef_3_hut2_right,
 W$6BB3,2;21 &roomdef_4_hut3_left,
 W$6BB5,2;21 &roomdef_5_hut3_right,
 W$6BB7,2;21 &roomdef_8_corridor, // room 6 unused
 W$6BB9,2;21 &roomdef_7_corridor,
 W$6BBB,2;21 &roomdef_8_corridor,
 W$6BBD,2;21 &roomdef_9_crate,
 W$6BBF,2;21 &roomdef_10_lockpick,
 W$6BC1,2;21 &roomdef_11_papers,
 W$6BC3,2;21 &roomdef_12_corridor,
 W$6BC5,2;21 &roomdef_13_corridor,
 W$6BC7,2;21 &roomdef_14_torch,
 W$6BC9,2;21 &roomdef_15_uniform,
 W$6BCB,2;21 &roomdef_16_corridor,
 W$6BCD,2;21 &roomdef_7_corridor, // room 17 same defn as room 7
 W$6BCF,2;21 &roomdef_18_radio,
 W$6BD1,2;21 &roomdef_19_food,
 W$6BD3,2;21 &roomdef_20_redcross,
 W$6BD5,2;21 &roomdef_16_corridor, // room 21 same defn as room 16
 W$6BD7,2;21 &roomdef_22_red_key,
 W$6BD9,2;21 &roomdef_23_breakfast,
 W$6BDB,2;21 &roomdef_24_solitary,
 W$6BDD,2;21 &roomdef_25_breakfast,
 W$6BDF,2;21 &roomdef_28_hut1_left, // room 26 unused
 W$6BE1,2;21 &roomdef_28_hut1_left, // room 27 unused
 W$6BE3,2;21 &roomdef_28_hut1_left,
; Array of pointers to tunnels.
 W$6BE5,2;21 &roomdef_29_second_tunnel_start,
 W$6BE7,2;21 &roomdef_30,
 W$6BE9,2;21 &roomdef_31,
 W$6BEB,2;21 &roomdef_32,
 W$6BED,2;21 &roomdef_29_second_tunnel_start, // room 33 same defn as room 29
 W$6BEF,2;21 &roomdef_34,
 W$6BF1,2;21 &roomdef_35,
 W$6BF3,2;21 &roomdef_36,
 W$6BF5,2;21 &roomdef_34, // room 37 same defn as 34
 W$6BF7,2;21 &roomdef_35, // room 38 same defn as 35
 W$6BF9,2;21 &roomdef_32, // room 39 same defn as 32
 W$6BFB,2;21 &roomdef_40,
 W$6BFD,2;21 &roomdef_30, // room 41 same defn as 30
 W$6BFF,2;21 &roomdef_32, // room 42 same defn as 32
 W$6C01,2;21 &roomdef_29_second_tunnel_start, // room 43 same defn as 29
 W$6C03,2;21 &roomdef_44,
 W$6C05,2;21 &roomdef_36, // room 45 same defn as 36
 W$6C07,2;21 &roomdef_36, // room 46 same defn as 36
 W$6C09,2;21 &roomdef_32, // room 47 same defn as 32
 W$6C0B,2;21 &roomdef_34, // room 48 same defn as 34
 W$6C0D,2;21 &roomdef_36, // room 49 same defn as 36
 W$6C0F,2;21 &roomdef_50_blocked_tunnel,
 W$6C11,2;21 &roomdef_32, // room 51 same defn as 32
 W$6C13,2;21 &roomdef_40, // room 52 same defn as 40

; Room 1: Hut 1, far side.
@label=roomdef_1_hut1_right
bB$6C15,1;40 0
 B$6C16,1;40 3 // count of boundaries
 B$6C17,4;40 { 54, 68, 23, 34 }, // boundary
 B$6C1B,4;40 { 54, 68, 39, 50 }, // boundary
 B$6C1F,4;40 { 54, 68, 55, 68 }, // boundary
 B$6C23,1;40 4 // count of mask bytes
 B$6C24,4;40 [0, 1, 3, 10] // data mask bytes
 B$6C28,1;40 10 // count of objects
 B$6C29,3;40 { interiorobject_ROOM_OUTLINE_22x12_A,         1,  4 },
 B$6C2C,3;40 { interiorobject_WIDE_WINDOW,                  8,  0 },
 B$6C2F,3;40 { interiorobject_WIDE_WINDOW,                  2,  3 },
 B$6C32,3;40 { interiorobject_OCCUPIED_BED,                10,  5 },
 B$6C35,3;40 { interiorobject_OCCUPIED_BED,                 6,  7 },
 B$6C38,3;40 { interiorobject_DOOR_FRAME_SW_NE,            15,  8 },
 B$6C3B,3;40 { interiorobject_ORNATE_WARDROBE_FACING_SW,   18,  5 },
 B$6C3E,3;40 { interiorobject_ORNATE_WARDROBE_FACING_SW,   20,  6 },
 B$6C41,3;40 { interiorobject_EMPTY_BED,                    2,  9 },
 B$6C44,3;40 { interiorobject_DOOR_FRAME_NW_SE,             7, 10 },

; Room 2: Hut 2, near side.
@label=roomdef_2_hut2_left
bB$6C47,1;40 1
 B$6C48,1;40 2 // count of boundaries
 B$6C49,4;40 { 48, 64, 43, 56 }, // boundary
 B$6C4D,4;40 { 24, 38, 26, 40 }, // boundary
 B$6C51,1;40 2 // count of mask bytes
 B$6C52,2;40 [13, 8] // data mask bytes
 B$6C54,1;40 8 // count of objects
 B$6C55,3;40 { interiorobject_ROOM_OUTLINE_18x10_A,         3,  6 },
 B$6C58,3;40 { interiorobject_WIDE_WINDOW,                  6,  2 },
 B$6C5B,3;40 { interiorobject_END_DOOR_FRAME_NW_SE,        16,  5 },
 B$6C5E,3;40 { interiorobject_STOVE_PIPE,                   4,  5 },
@label=roomdef_2_hut2_left_heros_bed
 B$6C61,3;40 { interiorobject_OCCUPIED_BED,                 8,  7 },
 B$6C64,3;40 { interiorobject_DOOR_FRAME_NW_SE,             7,  9 },
 B$6C67,3;40 { interiorobject_TABLE,                       11, 12 },
 B$6C6A,3;40 { interiorobject_SMALL_TUNNEL_ENTRANCE,        5,  9 },

; Room 3: Hut 2, far side.
@label=roomdef_3_hut2_right
bB$6C6D,1;40 0
 B$6C6E,1;40 3 // count of boundaries
 B$6C6F,4;40 { 54, 68, 23, 34 }, // boundary
 B$6C73,4;40 { 54, 68, 39, 50 }, // boundary
 B$6C77,4;40 { 54, 68, 55, 68 }, // boundary
 B$6C7B,1;40 4 // count of mask bytes
 B$6C7C,4;40 [0, 1, 3, 10] // data mask bytes
 B$6C80,1;40 10 // count of objects
 B$6C81,3;40 { interiorobject_ROOM_OUTLINE_22x12_A,         1,  4 },
 B$6C84,3;40 { interiorobject_WIDE_WINDOW,                  8,  0 },
 B$6C87,3;40 { interiorobject_WIDE_WINDOW,                  2,  3 },
@label=roomdef_3_hut2_right_bed_A
 B$6C8A,3;40 { interiorobject_OCCUPIED_BED,                10,  5 },
@label=roomdef_3_hut2_right_bed_B
 B$6C8D,3;40 { interiorobject_OCCUPIED_BED,                 6,  7 },
@label=roomdef_3_hut2_right_bed_C
 B$6C90,3;40 { interiorobject_OCCUPIED_BED,                 2,  9 },
 B$6C93,3;40 { interiorobject_CHEST_OF_DRAWERS,            16,  5 },
 B$6C96,3;40 { interiorobject_DOOR_FRAME_SW_NE,            15,  8 },
 B$6C99,3;40 { interiorobject_SHORT_WARDROBE,              18,  5 },
 B$6C9C,3;40 { interiorobject_DOOR_FRAME_NW_SE,             7, 10 },

; Room 4: Hut 3, near side.
@label=roomdef_4_hut3_left
bB$6C9F,1;40 1
 B$6CA0,1;40 2 // count of boundaries
 B$6CA1,4;40 { 24, 40, 24, 42 }, // boundary
 B$6CA5,4;40 { 48, 64, 43, 56 }, // boundary
 B$6CA9,1;40 3 // count of mask bytes
 B$6CAA,3;40 [18, 20, 8] // data mask bytes
 B$6CAD,1;40 9 // count of objects
 B$6CAE,3;40 { interiorobject_ROOM_OUTLINE_18x10_A,         3,  6 },
 B$6CB1,3;40 { interiorobject_END_DOOR_FRAME_NW_SE,        16,  5 },
 B$6CB4,3;40 { interiorobject_WIDE_WINDOW,                  6,  2 },
 B$6CB7,3;40 { interiorobject_STOVE_PIPE,                   4,  5 },
 B$6CBA,3;40 { interiorobject_EMPTY_BED,                    8,  7 },
 B$6CBD,3;40 { interiorobject_DOOR_FRAME_NW_SE,             7,  9 },
 B$6CC0,3;40 { interiorobject_CHAIR_FACING_SE,             11, 11 },
 B$6CC3,3;40 { interiorobject_CHAIR_FACING_SW,             13, 10 },
 B$6CC6,3;40 { interiorobject_STUFF,                       14, 14 },

; Room 5: Hut 3, far side.
@label=roomdef_5_hut3_right
bB$6CC9,1;40 0
 B$6CCA,1;40 3 // count of boundaries
 B$6CCB,4;40 { 54, 68, 23, 34 }, // boundary
 B$6CCF,4;40 { 54, 68, 39, 50 }, // boundary
 B$6CD3,4;40 { 54, 68, 55, 68 }, // boundary
 B$6CD7,1;40 4 // count of mask bytes
 B$6CD8,4;40 [0, 1, 3, 10] // data mask bytes
 B$6CDC,1;40 10 // count of objects
 B$6CDD,3;40 { interiorobject_ROOM_OUTLINE_22x12_A,         1,  4 },
 B$6CE0,3;40 { interiorobject_WIDE_WINDOW,                  8,  0 },
 B$6CE3,3;40 { interiorobject_WIDE_WINDOW,                  2,  3 },
@label=roomdef_5_hut2_right_bed_D
 B$6CE6,3;40 { interiorobject_OCCUPIED_BED,                10,  5 },
@label=roomdef_5_hut2_right_bed_E
 B$6CE9,3;40 { interiorobject_OCCUPIED_BED,                 6,  7 },
@label=roomdef_5_hut2_right_bed_F
 B$6CEC,3;40 { interiorobject_OCCUPIED_BED,                 2,  9 },
 B$6CEF,3;40 { interiorobject_DOOR_FRAME_SW_NE,            15,  8 },
 B$6CF2,3;40 { interiorobject_CHEST_OF_DRAWERS,            16,  5 },
 B$6CF5,3;40 { interiorobject_CHEST_OF_DRAWERS,            20,  7 },
 B$6CF8,3;40 { interiorobject_DOOR_FRAME_NW_SE,             7, 10 },

; Room 8: Corridor.
@label=roomdef_8_corridor
bB$6CFB,1;40 2
 B$6CFC,1;40 0 // count of boundaries
 B$6CFD,1;40 1 // count of mask bytes
 B$6CFE,1;40 [9] // data mask bytes
 B$6CFF,1;40 5 // count of objects
 B$6D00,3;40 { interiorobject_ROOM_OUTLINE_18x10_B,         3,  6 },
 B$6D03,3;40 { interiorobject_END_DOOR_FRAME_SW_NE,        10,  3 },
 B$6D06,3;40 { interiorobject_END_DOOR_FRAME_SW_NE,         4,  6 },
 B$6D09,3;40 { interiorobject_DOOR_FRAME_NW_SE,             5, 10 },
 B$6D0C,3;40 { interiorobject_SHORT_WARDROBE,              18,  6 },

; Room 9: Room with crate.
@label=roomdef_9_crate
bB$6D0F,1;40 1
 B$6D10,1;40 1 // count of boundaries
 B$6D11,4;40 { 58, 64, 28, 42 }, // boundary
 B$6D15,1;40 2 // count of mask bytes
 B$6D16,2;40 [4, 21] // data mask bytes
 B$6D18,1;40 10 // count of objects
 B$6D19,3;40 { interiorobject_ROOM_OUTLINE_18x10_A,         3,  6 },
 B$6D1C,3;40 { interiorobject_SMALL_WINDOW,                 6,  3 },
 B$6D1F,3;40 { interiorobject_SMALL_SHELF,                  9,  4 },
 B$6D22,3;40 { interiorobject_TINY_DOOR_FRAME_NW_SE,       12,  6 },
 B$6D25,3;40 { interiorobject_DOOR_FRAME_SW_NE,            13, 10 },
 B$6D28,3;40 { interiorobject_TALL_WARDROBE,               16,  6 },
 B$6D2B,3;40 { interiorobject_SHORT_WARDROBE,              18,  8 },
 B$6D2E,3;40 { interiorobject_CUPBOARD,                     3,  6 },
 B$6D31,3;40 { interiorobject_SMALL_CRATE,                  6,  8 },
 B$6D34,3;40 { interiorobject_SMALL_CRATE,                  4,  9 },

; Room 10: Room with lockpick.
@label=roomdef_10_lockpick
bB$6D37,1;40 4
 B$6D38,1;40 2 // count of boundaries
 B$6D39,4;40 { 69, 75, 32, 54 }, // boundary
 B$6D3D,4;40 { 36, 47, 48, 60 }, // boundary
 B$6D41,1;40 3 // count of mask bytes
 B$6D42,3;40 [6, 14, 22] // data mask bytes
 B$6D45,1;40 14 // count of objects
 B$6D46,3;40 { interiorobject_ROOM_OUTLINE_22x12_B,         1,  4 },
 B$6D49,3;40 { interiorobject_DOOR_FRAME_SW_NE,            15, 10 },
 B$6D4C,3;40 { interiorobject_SMALL_WINDOW,                 4,  1 },
 B$6D4F,3;40 { interiorobject_KEY_RACK,                     2,  3 },
 B$6D52,3;40 { interiorobject_KEY_RACK,                     7,  2 },
 B$6D55,3;40 { interiorobject_TALL_WARDROBE,               10,  2 },
 B$6D58,3;40 { interiorobject_CUPBOARD_42,                 13,  3 },
 B$6D5B,3;40 { interiorobject_CUPBOARD_42,                 15,  4 },
 B$6D5E,3;40 { interiorobject_CUPBOARD_42,                 17,  5 },
 B$6D61,3;40 { interiorobject_TABLE,                       14,  8 },
 B$6D64,3;40 { interiorobject_CHEST_OF_DRAWERS,            18,  8 },
 B$6D67,3;40 { interiorobject_CHEST_OF_DRAWERS,            20,  9 },
 B$6D6A,3;40 { interiorobject_SMALL_CRATE,                  6,  5 },
 B$6D6D,3;40 { interiorobject_TABLE,                        2,  6 },

; Room 11: Room with papers.
@label=roomdef_11_papers
bB$6D70,1;40 4
 B$6D71,1;40 1 // count of boundaries
 B$6D72,4;40 { 27, 44, 36, 48 }, // boundary
 B$6D76,1;40 1 // count of mask bytes
 B$6D77,1;40 [23] // data mask bytes
 B$6D78,1;40 9 // count of objects
 B$6D79,3;40 { interiorobject_ROOM_OUTLINE_22x12_B,         1,  4 },
 B$6D7C,3;40 { interiorobject_SMALL_SHELF,                  6,  3 },
 B$6D7F,3;40 { interiorobject_TALL_WARDROBE,               12,  3 },
 B$6D82,3;40 { interiorobject_TALL_DRAWERS,                10,  3 },
 B$6D85,3;40 { interiorobject_SHORT_WARDROBE,              14,  5 },
 B$6D88,3;40 { interiorobject_END_DOOR_FRAME_SW_NE,         2,  2 },
 B$6D8B,3;40 { interiorobject_TALL_DRAWERS,                18,  7 },
 B$6D8E,3;40 { interiorobject_TALL_DRAWERS,                20,  8 },
 B$6D91,3;40 { interiorobject_DESK,                        12, 10 },

; Room 12: Corridor.
@label=roomdef_12_corridor
bB$6D94,1;40 1
 B$6D95,1;40 0 // count of boundaries
 B$6D96,1;40 2 // count of mask bytes
 B$6D97,2;40 [4, 7] // data mask bytes
 B$6D99,1;40 4 // count of objects
 B$6D9A,3;40 { interiorobject_ROOM_OUTLINE_18x10_A,         3,  6 },
 B$6D9D,3;40 { interiorobject_SMALL_WINDOW,                 6,  3 },
 B$6DA0,3;40 { interiorobject_DOOR_FRAME_NW_SE,             9, 10 },
 B$6DA3,3;40 { interiorobject_DOOR_FRAME_SW_NE,            13, 10 },

; Room 13: Corridor.
@label=roomdef_13_corridor
bB$6DA6,1;40 1
 B$6DA7,1;40 0 // count of boundaries
 B$6DA8,1;40 2 // count of mask bytes
 B$6DA9,2;40 [4, 8] // data mask bytes
 B$6DAB,1;40 6 // count of objects
 B$6DAC,3;40 { interiorobject_ROOM_OUTLINE_18x10_A,         3,  6 },
 B$6DAF,3;40 { interiorobject_END_DOOR_FRAME_SW_NE,         6,  3 },
 B$6DB2,3;40 { interiorobject_DOOR_FRAME_NW_SE,             7,  9 },
 B$6DB5,3;40 { interiorobject_DOOR_FRAME_SW_NE,            13, 10 },
 B$6DB8,3;40 { interiorobject_TALL_DRAWERS,                12,  5 },
 B$6DBB,3;40 { interiorobject_CHEST_OF_DRAWERS,            14,  7 },

; Room 14: Room with torch.
@label=roomdef_14_torch
bB$6DBE,1;40 0
 B$6DBF,1;40 3 // count of boundaries
 B$6DC0,4;40 { 54, 68, 22, 32 }, // boundary
 B$6DC4,4;40 { 62, 68, 48, 58 }, // boundary
 B$6DC8,4;40 { 54, 68, 54, 68 }, // boundary
 B$6DCC,1;40 1 // count of mask bytes
 B$6DCD,1;40 [1] // data mask bytes
 B$6DCE,1;40 9 // count of objects
 B$6DCF,3;40 { interiorobject_ROOM_OUTLINE_22x12_A,         1,  4 },
 B$6DD2,3;40 { interiorobject_END_DOOR_FRAME_SW_NE,         4,  3 },
 B$6DD5,3;40 { interiorobject_TINY_DRAWERS,                 8,  5 },
 B$6DD8,3;40 { interiorobject_EMPTY_BED,                   10,  5 },
 B$6DDB,3;40 { interiorobject_CHEST_OF_DRAWERS,            16,  5 },
 B$6DDE,3;40 { interiorobject_SHORT_WARDROBE,              18,  5 },
 B$6DE1,3;40 { interiorobject_END_DOOR_FRAME_NW_SE,        20,  4 },
 B$6DE4,3;40 { interiorobject_SMALL_SHELF,                  2,  7 },
 B$6DE7,3;40 { interiorobject_EMPTY_BED,                    2,  9 },

; Room 15: Room with uniform.
@label=roomdef_15_uniform
bB$6DEA,1;40 0
 B$6DEB,1;40 4 // count of boundaries
 B$6DEC,4;40 { 54, 68, 22, 32 }, // boundary
 B$6DF0,4;40 { 54, 68, 54, 68 }, // boundary
 B$6DF4,4;40 { 62, 68, 40, 58 }, // boundary
 B$6DF8,4;40 { 30, 40, 56, 67 }, // boundary
 B$6DFC,1;40 4 // count of mask bytes
 B$6DFD,4;40 [1, 5, 10, 15] // data mask bytes
 B$6E01,1;40 10 // count of objects
 B$6E02,3;40 { interiorobject_ROOM_OUTLINE_22x12_A,         1,  4 },
 B$6E05,3;40 { interiorobject_SHORT_WARDROBE,              16,  4 },
 B$6E08,3;40 { interiorobject_EMPTY_BED,                   10,  5 },
 B$6E0B,3;40 { interiorobject_TINY_DRAWERS,                 8,  5 },
 B$6E0E,3;40 { interiorobject_TINY_DRAWERS,                 6,  6 },
 B$6E11,3;40 { interiorobject_SMALL_SHELF,                  2,  7 },
 B$6E14,3;40 { interiorobject_EMPTY_BED,                    2,  9 },
 B$6E17,3;40 { interiorobject_DOOR_FRAME_NW_SE,             7, 10 },
 B$6E1A,3;40 { interiorobject_DOOR_FRAME_SW_NE,            13,  9 },
 B$6E1D,3;40 { interiorobject_TABLE,                       18,  8 },

; Room 16: Corridor.
@label=roomdef_16_corridor
bB$6E20,1;40 1
 B$6E21,1;40 0 // count of boundaries
 B$6E22,1;40 2 // count of mask bytes
 B$6E23,2;40 [4, 7] // data mask bytes
 B$6E25,1;40 4 // count of objects
 B$6E26,3;40 { interiorobject_ROOM_OUTLINE_18x10_A,         3,  6 },
 B$6E29,3;40 { interiorobject_END_DOOR_FRAME_SW_NE,         4,  4 },
 B$6E2C,3;40 { interiorobject_DOOR_FRAME_NW_SE,             9, 10 },
 B$6E2F,3;40 { interiorobject_DOOR_FRAME_SW_NE,            13, 10 },

; Room 7: Corridor.
@label=roomdef_7_corridor
bB$6E32,1;40 1
 B$6E33,1;40 0 // count of boundaries
 B$6E34,1;40 1 // count of mask bytes
 B$6E35,1;40 [4] // data mask bytes
 B$6E36,1;40 4 // count of objects
 B$6E37,3;40 { interiorobject_ROOM_OUTLINE_18x10_A,         3,  6 },
 B$6E3A,3;40 { interiorobject_END_DOOR_FRAME_SW_NE,         4,  4 },
 B$6E3D,3;40 { interiorobject_DOOR_FRAME_SW_NE,            13, 10 },
 B$6E40,3;40 { interiorobject_TALL_WARDROBE,               12,  4 },

; Room 18: Room with radio.
@label=roomdef_18_radio
bB$6E43,1;40 4
 B$6E44,1;40 3 // count of boundaries
 B$6E45,4;40 { 38, 56, 48, 60 }, // boundary
 B$6E49,4;40 { 38, 46, 39, 60 }, // boundary
 B$6E4D,4;40 { 22, 32, 48, 60 }, // boundary
 B$6E51,1;40 5 // count of mask bytes
 B$6E52,5;40 [11, 17, 16, 24, 25] // data mask bytes
 B$6E57,1;40 10 // count of objects
 B$6E58,3;40 { interiorobject_ROOM_OUTLINE_22x12_B,         1,  4 },
 B$6E5B,3;40 { interiorobject_CUPBOARD,                     1,  4 },
 B$6E5E,3;40 { interiorobject_SMALL_WINDOW,                 4,  1 },
 B$6E61,3;40 { interiorobject_SMALL_SHELF,                  7,  2 },
 B$6E64,3;40 { interiorobject_END_DOOR_FRAME_NW_SE,        10,  1 },
 B$6E67,3;40 { interiorobject_TABLE,                       12,  7 },
 B$6E6A,3;40 { interiorobject_MESS_BENCH_SHORT,            12,  9 },
 B$6E6D,3;40 { interiorobject_TABLE,                       18, 10 },
 B$6E70,3;40 { interiorobject_TINY_TABLE,                  16, 12 },
 B$6E73,3;40 { interiorobject_DOOR_FRAME_NW_SE,             5,  7 },

; Room 19: Room with food.
@label=roomdef_19_food
bB$6E76,1;40 1
 B$6E77,1;40 1 // count of boundaries
 B$6E78,4;40 { 52, 64, 47, 56 }, // boundary
 B$6E7C,1;40 1 // count of mask bytes
 B$6E7D,1;40 [7] // data mask bytes
 B$6E7E,1;40 11 // count of objects
 B$6E7F,3;40 { interiorobject_ROOM_OUTLINE_18x10_A,         3,  6 },
 B$6E82,3;40 { interiorobject_SMALL_WINDOW,                 6,  3 },
 B$6E85,3;40 { interiorobject_CUPBOARD,                     9,  3 },
 B$6E88,3;40 { interiorobject_CUPBOARD_42,                 12,  3 },
 B$6E8B,3;40 { interiorobject_CUPBOARD_42,                 14,  4 },
 B$6E8E,3;40 { interiorobject_TABLE,                        9,  6 },
 B$6E91,3;40 { interiorobject_SMALL_SHELF,                  3,  5 },
 B$6E94,3;40 { interiorobject_SINK,                         3,  7 },
 B$6E97,3;40 { interiorobject_CHEST_OF_DRAWERS,            14,  7 },
 B$6E9A,3;40 { interiorobject_END_DOOR_FRAME_NW_SE,        16,  5 },
 B$6E9D,3;40 { interiorobject_DOOR_FRAME_NW_SE,             9, 10 },

; Room 20: Room with red cross parcel.
@label=roomdef_20_redcross
bB$6EA0,1;40 1
 B$6EA1,1;40 2 // count of boundaries
 B$6EA2,4;40 { 58, 64, 26, 42 }, // boundary
 B$6EA6,4;40 { 50, 64, 46, 54 }, // boundary
 B$6EAA,1;40 2 // count of mask bytes
 B$6EAB,2;40 [21, 4] // data mask bytes
 B$6EAD,1;40 11 // count of objects
 B$6EAE,3;40 { interiorobject_ROOM_OUTLINE_18x10_A,         3,  6 },
 B$6EB1,3;40 { interiorobject_DOOR_FRAME_SW_NE,            13, 10 },
 B$6EB4,3;40 { interiorobject_SMALL_SHELF,                  9,  4 },
 B$6EB7,3;40 { interiorobject_CUPBOARD,                     3,  6 },
 B$6EBA,3;40 { interiorobject_SMALL_CRATE,                  6,  8 },
 B$6EBD,3;40 { interiorobject_SMALL_CRATE,                  4,  9 },
 B$6EC0,3;40 { interiorobject_TABLE,                        9,  6 },
 B$6EC3,3;40 { interiorobject_TALL_WARDROBE,               14,  5 },
 B$6EC6,3;40 { interiorobject_TALL_WARDROBE,               16,  6 },
 B$6EC9,3;40 { interiorobject_ORNATE_WARDROBE_FACING_SW,   18,  8 },
 B$6ECC,3;40 { interiorobject_TINY_TABLE,                  11,  8 },

; Room 22: Room with red key.
@label=roomdef_22_red_key
bB$6ECF,1;40 3
 B$6ED0,1;40 2 // count of boundaries
 B$6ED1,4;40 { 54, 64, 46, 56 }, // boundary
 B$6ED5,4;40 { 58, 64, 36, 44 }, // boundary
 B$6ED9,1;40 2 // count of mask bytes
 B$6EDA,2;40 [12, 21] // data mask bytes
 B$6EDC,1;40 7 // count of objects
 B$6EDD,3;40 { interiorobject_ROOM_OUTLINE_15x8,            5,  6 },
 B$6EE0,3;40 { interiorobject_NOTICEBOARD,                  4,  4 },
 B$6EE3,3;40 { interiorobject_SMALL_SHELF,                  9,  4 },
 B$6EE6,3;40 { interiorobject_SMALL_CRATE,                  6,  8 },
 B$6EE9,3;40 { interiorobject_DOOR_FRAME_NW_SE,             9,  8 },
 B$6EEC,3;40 { interiorobject_TABLE,                        9,  6 },
 B$6EEF,3;40 { interiorobject_END_DOOR_FRAME_NW_SE,        14,  4 },

; Room 23: Breakfast room.
@label=roomdef_23_breakfast
bB$6EF2,1;40 0
 B$6EF3,1;40 1 // count of boundaries
 B$6EF4,4;40 { 54, 68, 34, 68 }, // boundary
 B$6EF8,1;40 2 // count of mask bytes
 B$6EF9,2;40 [10, 3] // data mask bytes
 B$6EFB,1;40 12 // count of objects
 B$6EFC,3;40 { interiorobject_ROOM_OUTLINE_22x12_A,         1,  4 },
 B$6EFF,3;40 { interiorobject_SMALL_WINDOW,                 8,  0 },
 B$6F02,3;40 { interiorobject_SMALL_WINDOW,                 2,  3 },
 B$6F05,3;40 { interiorobject_DOOR_FRAME_NW_SE,             7, 10 },
 B$6F08,3;40 { interiorobject_MESS_TABLE,                   5,  4 },
 B$6F0B,3;40 { interiorobject_CUPBOARD_42,                 18,  4 },
 B$6F0E,3;40 { interiorobject_END_DOOR_FRAME_NW_SE,        20,  4 },
 B$6F11,3;40 { interiorobject_DOOR_FRAME_SW_NE,            15,  8 },
 B$6F14,3;40 { interiorobject_MESS_BENCH,                   7,  6 },
@label=roomdef_23_breakfast_bench_A
 B$6F17,3;40 { interiorobject_EMPTY_BENCH,                 12,  5 },
@label=roomdef_23_breakfast_bench_B
 B$6F1A,3;40 { interiorobject_EMPTY_BENCH,                 10,  6 },
@label=roomdef_23_breakfast_bench_C
 B$6F1D,3;40 { interiorobject_EMPTY_BENCH,                  8,  7 },

; Room 24: Solitary confinement cell.
@label=roomdef_24_solitary
bB$6F20,1;40 3
 B$6F21,1;40 1 // count of boundaries
 B$6F22,4;40 { 48, 54, 38, 46 }, // boundary
 B$6F26,1;40 1 // count of mask bytes
 B$6F27,1;40 [26] // data mask bytes
 B$6F28,1;40 3 // count of objects
 B$6F29,3;40 { interiorobject_ROOM_OUTLINE_15x8,            5,  6 },
 B$6F2C,3;40 { interiorobject_END_DOOR_FRAME_NW_SE,        14,  4 },
 B$6F2F,3;40 { interiorobject_TINY_TABLE,                  10,  9 },

; Room 25: Breakfast room.
@label=roomdef_25_breakfast
bB$6F32,1;40 0
 B$6F33,1;40 1 // count of boundaries
 B$6F34,4;40 { 54, 68, 34, 68 }, // boundary
 B$6F38,1;40 0 // count of mask bytes
 B$6F39,1;40 11 // count of objects
 B$6F3A,3;40 { interiorobject_ROOM_OUTLINE_22x12_A,         1,  4 },
 B$6F3D,3;40 { interiorobject_SMALL_WINDOW,                 8,  0 },
 B$6F40,3;40 { interiorobject_CUPBOARD,                     5,  3 },
 B$6F43,3;40 { interiorobject_SMALL_WINDOW,                 2,  3 },
 B$6F46,3;40 { interiorobject_END_DOOR_FRAME_NW_SE,        18,  3 },
 B$6F49,3;40 { interiorobject_MESS_TABLE,                   5,  4 },
 B$6F4C,3;40 { interiorobject_MESS_BENCH,                   7,  6 },
@label=roomdef_25_breakfast_bench_D
 B$6F4F,3;40 { interiorobject_EMPTY_BENCH,                 12,  5 },
@label=roomdef_25_breakfast_bench_E
 B$6F52,3;40 { interiorobject_EMPTY_BENCH,                 10,  6 },
@label=roomdef_25_breakfast_bench_F
 B$6F55,3;40 { interiorobject_EMPTY_BENCH,                  8,  7 },
@label=roomdef_25_breakfast_bench_G
 B$6F58,3;40 { interiorobject_EMPTY_BENCH,                 14,  4 },

; Room 28: Hut 1, near side.
@label=roomdef_28_hut1_left
bB$6F5B,1;40 1
 B$6F5C,1;40 2 // count of boundaries
 B$6F5D,4;40 { 28, 40, 28, 52 }, // boundary
 B$6F61,4;40 { 48, 63, 44, 56 }, // boundary
 B$6F65,1;40 3 // count of mask bytes
 B$6F66,3;40 [8, 13, 19] // data mask bytes
 B$6F69,1;40 8 // count of objects
 B$6F6A,3;40 { interiorobject_ROOM_OUTLINE_18x10_A,         3,  6 },
 B$6F6D,3;40 { interiorobject_WIDE_WINDOW,                  6,  2 },
 B$6F70,3;40 { interiorobject_END_DOOR_FRAME_NW_SE,        14,  4 },
 B$6F73,3;40 { interiorobject_CUPBOARD,                     3,  6 },
 B$6F76,3;40 { interiorobject_OCCUPIED_BED,                 8,  7 },
 B$6F79,3;40 { interiorobject_DOOR_FRAME_NW_SE,             7,  9 },
 B$6F7C,3;40 { interiorobject_CHAIR_FACING_SW,             15, 10 },
 B$6F7F,3;40 { interiorobject_TABLE,                       11, 12 },

; Room 29: Start of second tunnel.
@label=roomdef_29_second_tunnel_start
bB$6F82,1;40 5
 B$6F83,1;40 0 // count of boundaries
 B$6F84,1;40 6 // count of mask bytes
 B$6F85,6;40 [30, 31, 32, 33, 34, 35] // data mask bytes
 B$6F8B,1;40 6 // count of objects
 B$6F8C,3;40 { interiorobject_TUNNEL_SW_NE,                20,  0 },
 B$6F8F,3;40 { interiorobject_TUNNEL_SW_NE,                16,  2 },
 B$6F92,3;40 { interiorobject_TUNNEL_SW_NE,                12,  4 },
 B$6F95,3;40 { interiorobject_TUNNEL_SW_NE,                 8,  6 },
 B$6F98,3;40 { interiorobject_TUNNEL_SW_NE,                 4,  8 },
 B$6F9B,3;40 { interiorobject_TUNNEL_SW_NE,                 0, 10 },

; Room 31.
@label=roomdef_31
bB$6F9E,1;40 6
 B$6F9F,1;40 0 // count of boundaries
 B$6FA0,1;40 6 // count of mask bytes
 B$6FA1,6;40 [36, 37, 38, 39, 40, 41] // data mask bytes
 B$6FA7,1;40 6 // count of objects
 B$6FA8,3;40 { interiorobject_TUNNEL_NW_SE,                 0,  0 },
 B$6FAB,3;40 { interiorobject_TUNNEL_NW_SE,                 4,  2 },
 B$6FAE,3;40 { interiorobject_TUNNEL_NW_SE,                 8,  4 },
 B$6FB1,3;40 { interiorobject_TUNNEL_NW_SE,                12,  6 },
 B$6FB4,3;40 { interiorobject_TUNNEL_NW_SE,                16,  8 },
 B$6FB7,3;40 { interiorobject_TUNNEL_NW_SE,                20, 10 },

; Room 36.
@label=roomdef_36
bB$6FBA,1;40 7
 B$6FBB,1;40 0 // count of boundaries
 B$6FBC,1;40 6 // count of mask bytes
 B$6FBD,6;40 [31, 32, 33, 34, 35, 45] // data mask
 ;40 bytes
 B$6FC3,1;40 5 // count of objects
 B$6FC4,3;40 { interiorobject_TUNNEL_SW_NE,                20,  0 },
 B$6FC7,3;40 { interiorobject_TUNNEL_SW_NE,                16,  2 },
 B$6FCA,3;40 { interiorobject_TUNNEL_SW_NE,                12,  4 },
 B$6FCD,3;40 { interiorobject_TUNNEL_SW_NE,                 8,  6 },
 B$6FD0,3;40 { interiorobject_TUNNEL_14,                    4,  8 },

; Room 32.
@label=roomdef_32
bB$6FD3,1;40 8
 B$6FD4,1;40 0 // count of boundaries
 B$6FD5,1;40 6 // count of mask bytes
 B$6FD6,6;40 [36, 37, 38, 39, 40, 42] // data mask bytes
 B$6FDC,1;40 5 // count of objects
 B$6FDD,3;40 { interiorobject_TUNNEL_NW_SE,                 0,  0 },
 B$6FE0,3;40 { interiorobject_TUNNEL_NW_SE,                 4,  2 },
 B$6FE3,3;40 { interiorobject_TUNNEL_NW_SE,                 8,  4 },
 B$6FE6,3;40 { interiorobject_TUNNEL_NW_SE,                12,  6 },
 B$6FE9,3;40 { interiorobject_TUNNEL_17,                   16,  8 },

; Room 34.
@label=roomdef_34
bB$6FEC,1;40 6
 B$6FED,1;40 0 // count of boundaries
 B$6FEE,1;40 6 // count of mask bytes
 B$6FEF,6;40 [36, 37, 38, 39, 40, 46] // data mask
 ;40 bytes
 B$6FF5,1;40 6 // count of objects
 B$6FF6,3;40 { interiorobject_TUNNEL_NW_SE,                 0,  0 },
 B$6FF9,3;40 { interiorobject_TUNNEL_NW_SE,                 4,  2 },
 B$6FFC,3;40 { interiorobject_TUNNEL_NW_SE,                 8,  4 },
 B$6FFF,3;40 { interiorobject_TUNNEL_NW_SE,                12,  6 },
 B$7002,3;40 { interiorobject_TUNNEL_NW_SE,                16,  8 },
 B$7005,3;40 { interiorobject_TUNNEL_JOIN_18,              20, 10 },

; Room 35.
@label=roomdef_35
bB$7008,1;40 6
 B$7009,1;40 0 // count of boundaries
 B$700A,1;40 6 // count of mask bytes
 B$700B,6;40 [36, 37, 38, 39, 40, 41] // data mask bytes
 B$7011,1;40 6 // count of objects
 B$7012,3;40 { interiorobject_TUNNEL_NW_SE,                 0,  0 },
 B$7015,3;40 { interiorobject_TUNNEL_NW_SE,                 4,  2 },
 B$7018,3;40 { interiorobject_TUNNEL_T_JOIN_NW_SE,          8,  4 },
 B$701B,3;40 { interiorobject_TUNNEL_NW_SE,                12,  6 },
 B$701E,3;40 { interiorobject_TUNNEL_NW_SE,                16,  8 },
 B$7021,3;40 { interiorobject_TUNNEL_NW_SE,                20, 10 },

; Room 30.
@label=roomdef_30
bB$7024,1;40 5
 B$7025,1;40 0 // count of boundaries
 B$7026,1;40 7 // count of mask bytes
 B$7027,7;40 [30, 31, 32, 33, 34, 35, 44] // data mask bytes
 B$702E,1;40 6 // count of objects
 B$702F,3;40 { interiorobject_TUNNEL_SW_NE,                20,  0 },
 B$7032,3;40 { interiorobject_TUNNEL_SW_NE,                16,  2 },
 B$7035,3;40 { interiorobject_TUNNEL_SW_NE,                12,  4 },
 B$7038,3;40 { interiorobject_TUNNEL_CORNER_6,              8,  6 },
 B$703B,3;40 { interiorobject_TUNNEL_SW_NE,                 4,  8 },
 B$703E,3;40 { interiorobject_TUNNEL_SW_NE,                 0, 10 },

; Room 40.
@label=roomdef_40
bB$7041,1;40 9
 B$7042,1;40 0 // count of boundaries
 B$7043,1;40 6 // count of mask bytes
 B$7044,6;40 [30, 31, 32, 33, 34, 43] // data mask bytes
 B$704A,1;40 6 // count of objects
 B$704B,3;40 { interiorobject_TUNNEL_CORNER_7,             20,  0 },
 B$704E,3;40 { interiorobject_TUNNEL_SW_NE,                16,  2 },
 B$7051,3;40 { interiorobject_TUNNEL_SW_NE,                12,  4 },
 B$7054,3;40 { interiorobject_TUNNEL_SW_NE,                 8,  6 },
 B$7057,3;40 { interiorobject_TUNNEL_SW_NE,                 4,  8 },
 B$705A,3;40 { interiorobject_TUNNEL_SW_NE,                 0, 10 },

; Room 44.
@label=roomdef_44
bB$705D,1;40 8
 B$705E,1;40 0 // count of boundaries
 B$705F,1;40 5 // count of mask bytes
 B$7060,5;40 [36, 37, 38, 39, 40] // data mask bytes
 B$7065,1;40 5 // count of objects
 B$7066,3;40 { interiorobject_TUNNEL_NW_SE,                 0,  0 },
 B$7069,3;40 { interiorobject_TUNNEL_NW_SE,                 4,  2 },
 B$706C,3;40 { interiorobject_TUNNEL_NW_SE,                 8,  4 },
 B$706F,3;40 { interiorobject_TUNNEL_NW_SE,                12,  6 },
 B$7072,3;40 { interiorobject_TUNNEL_CORNER_NW_NE,         16,  8 },

; Room 50: Blocked tunnel.
@label=roomdef_50_blocked_tunnel
bB$7075,1;40 5
 B$7076,1;40 1 // count of boundaries
@label=roomdef_50_blocked_tunnel_boundary
 B$7077,4;40 { 52, 58, 32, 54 }, // boundary
 B$707B,1;40 6 // count of mask bytes
 B$707C,6;40 [30, 31, 32, 33, 34, 43] // data mask bytes
 B$7082,1;40 6 // count of objects
 B$7083,3;40 { interiorobject_TUNNEL_CORNER_7,             20,  0 },
 B$7086,3;40 { interiorobject_TUNNEL_SW_NE,                16,  2 },
 B$7089,3;40 { interiorobject_TUNNEL_SW_NE,                12,  4 },
@label=roomdef_50_blocked_tunnel_collapsed_tunnel
 B$708C,3;40 { interiorobject_COLLAPSED_TUNNEL_SW_NE,       8,  6 },
 B$708F,3;40 { interiorobject_TUNNEL_SW_NE,                 4,  8 },
 B$7092,3;40 { interiorobject_TUNNEL_SW_NE,                 0, 10 },

; Interior object definitions.
@label=interior_object_defs
bW$7095,2;21 {Array of pointer to interior object definitions, 54
 W$7097,2;21 entries long (== number of interior objects).
 W$7099,2*51
 W$70FF,2;21 }

; Room object 0: Straight tunnel section SW-NE
@label=interior_object_tile_refs_0
bB$7101,1;28 width
 B$7102,1;28 height
 B$7103,4;28 {tile references
 B$7107,4*4
 B$7117,4;28 }
; #HTML[#CALL:decode_object($7101, 0)]

; Room object 1: Small tunnel entrance
@label=interior_object_tile_refs_1
bB$711B,1;21 width
 B$711C,1;21 height
 B$711D,2;21 {tile references
 B$711F,2;21 }
; #HTML[#CALL:decode_object($711B, 1)]

; Room object 3: Straight tunnel section NW-SE
@label=interior_object_tile_refs_3
bB$7121,1;28 width
 B$7122,1;28 height
 B$7123,4;28 {tile references
 B$7127,4*4
 B$7137,4;28 }
; #HTML[#CALL:decode_object($7121, 3)]

; Room object 4: Tunnel T-join section NW-SE
@label=interior_object_tile_refs_4
bB$713B,1;28 width
 B$713C,1;28 height
 B$713D,4;28 {tile references
 B$7141,4*4
 B$7151,4;28 }
; #HTML[#CALL:decode_object($713B, 4)]

; Room object 5: Prisoner sat mid table
@label=interior_object_tile_refs_5
bB$7155,1;24 width
 B$7156,1;24 height
 B$7157,3;24 tile references (incl. RLE)
; #HTML[#CALL:decode_object($7155, 5)]

; Room object 6: Tunnel T-join section SW-NE
@label=interior_object_tile_refs_6
bB$715A,1;28 width
 B$715B,1;28 height
 B$715C,4;28 {tile references
 B$7160,4*4
 B$7170,4;28 }
; #HTML[#CALL:decode_object($715A, 6)]

; Room object 7: Tunnel corner section SW-SE
@label=interior_object_tile_refs_7
bB$7174,1;28 width
 B$7175,1;28 height
 B$7176,4;28 {tile references
 B$717A,4*4
 B$718A,4;28 }
; #HTML[#CALL:decode_object($7174, 7)]

; Room object 12: Tunnel corner section NW-NE
@label=interior_object_tile_refs_12
bB$718E,1;44 width
 B$718F,1;44 height
 B$7190,8;44 {tile references (incl. RLE)
 B$7198,8
 B$71A0,6;44 }
; #HTML[#CALL:decode_object($718E, 12)]

; Room object 13: Empty bench
@label=interior_object_tile_refs_13
bB$71A6,1;24 width
 B$71A7,1;24 height
 B$71A8,3;24 tile references (incl. RLE)
; #HTML[#CALL:decode_object($71A6, 13)]

; Room object 14: Tunnel corner section NE-SE
@label=interior_object_tile_refs_14
bB$71AB,1;44 width
 B$71AC,1;44 height
 B$71AD,8;44 {tile references (incl. RLE)
 B$71B5,8
 B$71BD,7;44 }
; #HTML[#CALL:decode_object($71AB, 14)]

; Room object 17: Tunnel corner section NW-SW
@label=interior_object_tile_refs_17
bB$71C4,1;28 width
 B$71C5,1;28 height
 B$71C6,4;28 {tile references
 B$71CA,4*4
 B$71DA,4;28 }
; #HTML[#CALL:decode_object($71C4, 17)]

; Room object 18: Tunnel entrance
@label=interior_object_tile_refs_18
bB$71DE,1;28 width
 B$71DF,1;28 height
 B$71E0,4;28 {tile references
 B$71E4,4*4
 B$71F4,4;28 }
; #HTML[#CALL:decode_object($71DE, 18)]

; Room object 19: Prisoner sat end table
@label=interior_object_tile_refs_19
bB$71F8,1;21 width
 B$71F9,1;21 height
 B$71FA,2;21 {tile references
 B$71FC,2
 B$71FE,2;21 }
; #HTML[#CALL:decode_object($71F8, 19)]

; Room object 20: Collapsed tunnel section SW-NE
@label=interior_object_tile_refs_20
bB$7200,1;44 width
 B$7201,1;44 height
 B$7202,3;44 tile references (incl. RLE)
 B$7205,8*2,5
; #HTML[#CALL:decode_object($7200, 20)]

; Room object 2: Room outline 22x12 A
@label=interior_object_tile_refs_2
bB$721A,1;44 width
 B$721B,1;44 height
 B$721C,8;44 {tile references (incl. RLE)
 B$7224,8*13
 B$728C,2;44 }
; #HTML[#CALL:decode_object($721A, 2)]

; Room object 8: Wide window facing SE
@label=interior_object_tile_refs_8
bB$728E,1;32 width
 B$728F,1;32 height
 B$7290,5;32 {tile references
 B$7295,5*4
 B$72A9,5;32 }
; #HTML[#CALL:decode_object($728E, 8)]

; Room object 9: Empty bed facing SE
@label=interior_object_tile_refs_9
bB$72AE,1;44 width
 B$72AF,1;44 height
 B$72B0,8;44 {tile references (incl. RLE)
 B$72B8,8
 B$72C0,1;44 }
; #HTML[#CALL:decode_object($72AE, 9)]

; Room object 10: Short wardrobe facing SW
@label=interior_object_tile_refs_10
bB$72C1,1;44 width
 B$72C2,1;44 height
 B$72C3,8;44 {tile references (incl. RLE)
 B$72CB,1;44 }
; #HTML[#CALL:decode_object($72C1, 10)]

; Room object 11: Chest of drawers facing SW
@label=interior_object_tile_refs_11
bB$72CC,1;24 width
 B$72CD,1;24 height
 B$72CE,3;24 tile references (incl. RLE)
; #HTML[#CALL:decode_object($72CC, 11)]

; Room object 15: Door frame SE
@label=interior_object_tile_refs_15
bB$72D1,1;28 width
 B$72D2,1;28 height
 B$72D3,4;28 {tile references
 B$72D7,4*4
 B$72E7,4;28 }
; #HTML[#CALL:decode_object($72D1, 15)]

; Room object 16: Door frame SW
@label=interior_object_tile_refs_16
bB$72EB,1;28 width
 B$72EC,1;28 height
 B$72ED,4;28 {tile references
 B$72F1,4*4
 B$7301,4;28 }
; #HTML[#CALL:decode_object($72EB, 16)]

; Room object 22: Chair facing SE
@label=interior_object_tile_refs_22
bB$7305,1;21 width
 B$7306,1;21 height
 B$7307,2;21 {tile references
 B$7309,2*2
 B$730D,2;21 }
; #HTML[#CALL:decode_object($7305, 22)]

; Room object 23: Occupied bed
@label=interior_object_tile_refs_23
bB$730F,1;32 width
 B$7310,1;32 height
 B$7311,5;32 {tile references
 B$7316,5*2
 B$7320,5;32 }
; #HTML[#CALL:decode_object($730F, 23)]

; Room object 24: Ornate wardrobe facing SW
@label=interior_object_tile_refs_24
bB$7325,1;24 width
 B$7326,1;24 height
 B$7327,3;24 {tile references
 B$732A,3*2
 B$7330,3;24 }
; #HTML[#CALL:decode_object($7325, 24)]

; Room object 25: Chair facing SW
@label=interior_object_tile_refs_25
bB$7333,1;40 width
 B$7334,1;40 height
 B$7335,7;40 tile references (incl. RLE)
; #HTML[#CALL:decode_object($7333, 25)]

; Room object 26: Cupboard facing SE
@label=interior_object_tile_refs_26
bB$733C,1;28 width
 B$733D,1;28 height
 B$733E,4;28 tile references (incl. RLE)
; #HTML[#CALL:decode_object($733C, 26)]

; Room object 29: Table
@label=interior_object_tile_refs_29
bB$7342,1;40 width
 B$7343,1;40 height
 B$7344,7;40 tile references (incl. RLE)
; #HTML[#CALL:decode_object($7342, 29)]

; Room object 30: Stove pipe
@label=interior_object_tile_refs_30
bB$734B,1;44 width
 B$734C,1;44 height
 B$734D,8;44 {tile references (incl. RLE)
 B$7355,4;44 }
; #HTML[#CALL:decode_object($734B, 30)]

; Room object 31: Papers on floor
@label=interior_object_tile_refs_31
bB$7359,1;21 width
 B$735A,1;21 height
 B$735B,1;21 tile references
; #HTML[#CALL:decode_object($7359, 31)]

; Room object 32: Tall wardrobe facing SW
@label=interior_object_tile_refs_32
bB$735C,1;44 width
 B$735D,1;44 height
 B$735E,8;44 {tile references (incl. RLE)
 B$7366,4;44 }
; #HTML[#CALL:decode_object($735C, 32)]

; Room object 33: Small shelf facing SE
@label=interior_object_tile_refs_33
bB$736A,1;24 width
 B$736B,1;24 height
 B$736C,3;24 tile references (incl. RLE)
; #HTML[#CALL:decode_object($736A, 33)]

; Room object 34: Small crate
@label=interior_object_tile_refs_34
bB$736F,1;24 width
 B$7370,1;24 height
 B$7371,3;24 tile references (incl. RLE)
; #HTML[#CALL:decode_object($736F, 34)]

; Room object 35: Small window with bars facing SE
@label=interior_object_tile_refs_35
bB$7374,1;44 width
 B$7375,1;44 height
 B$7376,8;44 {tile references (incl. RLE)
 B$737E,7;44 }
; #HTML[#CALL:decode_object($7374, 35)]

; Room object 36: Tiny door frame NE (tunnel entrance)
@label=interior_object_tile_refs_36
bB$7385,1;44 width
 B$7386,1;44 height
 B$7387,8;44 {tile references (incl. RLE)
 B$738F,4;44 }
; #HTML[#CALL:decode_object($7385, 36)]

; Room object 37: Noticeboard facing SE
@label=interior_object_tile_refs_37
bB$7393,1;44 width
 B$7394,1;44 height
 B$7395,8;44 {tile references (incl. RLE)
 B$739D,8;44 }
; #HTML[#CALL:decode_object($7393, 37)]

; Room object 38: Door frame NW
@label=interior_object_tile_refs_38
bB$73A5,1;28 width
 B$73A6,1;28 height
 B$73A7,4;28 {tile references
 B$73AB,4*4
 B$73BB,4;28 }
; #HTML[#CALL:decode_object($73A5, 38)]

; Room object 40: Door frame NE
@label=interior_object_tile_refs_40
bB$73BF,1;28 width
 B$73C0,1;28 height
 B$73C1,4;28 {tile references
 B$73C5,4*4
 B$73D5,4;28 }
; #HTML[#CALL:decode_object($73BF, 40)]

; Room object 41: Room outline 15x8
@label=interior_object_tile_refs_41
bB$73D9,1;44 width
 B$73DA,1;44 height
 B$73DB,8;44 {tile references (incl. RLE)
 B$73E3,8*8
 B$7423,2;44 }
; #HTML[#CALL:decode_object($73D9, 41)]

; Room object 42: Cupboard facing SW
@label=interior_object_tile_refs_42
bB$7425,1;21 width
 B$7426,1;21 height
 B$7427,2;21 {tile references
 B$7429,2
 B$742B,2;21 }
; #HTML[#CALL:decode_object($7425, 42)]

; Room object 43: Mess bench
@label=interior_object_tile_refs_43
bB$742D,1;44 width
 B$742E,1;44 height
 B$742F,8;44 {tile references (incl. RLE)
 B$7437,8*3
 B$744F,3;44 }
; #HTML[#CALL:decode_object($742D, 43)]

; Room object 44: Mess table
@label=interior_object_tile_refs_44
bB$7452,1;44 width
 B$7453,1;44 height
 B$7454,8;44 {tile references (incl. RLE)
 B$745C,8*4
 B$747C,6;44 }
; #HTML[#CALL:decode_object($7452, 44)]

; Room object 45: Mess bench short
@label=interior_object_tile_refs_45
bB$7482,1;44 width
 B$7483,1;44 height
 B$7484,8;44 {tile references (incl. RLE)
 B$748C,7;44 }
; #HTML[#CALL:decode_object($7482, 45)]

; Room object 46: Room outline 18x10 B
@label=interior_object_tile_refs_46
bB$7493,1;44 width
 B$7494,1;44 height
 B$7495,8;44 {tile references (incl. RLE)
 B$749D,8*10
 B$74ED,8;44 }
; #HTML[#CALL:decode_object($7493, 46)]

; Room object 47: Room outline 22x12 B
@label=interior_object_tile_refs_47
bB$74F5,1;44 width
 B$74F6,1;44 height
 B$74F7,8;44 {tile references (incl. RLE)
 B$74FF,8*14
 B$756F,1;44 }
; #HTML[#CALL:decode_object($74F5, 47)]

; Room object 48: Tiny table
@label=interior_object_tile_refs_48
bB$7570,1;21 width
 B$7571,1;21 height
 B$7572,2;21 {tile references
 B$7574,2;21 }
; #HTML[#CALL:decode_object($7570, 48)]

; Room object 49: Tiny drawers facing SE
@label=interior_object_tile_refs_49
bB$7576,1;21 width
 B$7577,1;21 height
 B$7578,2;21 {tile references
 B$757A,2
 B$757C,2;21 }
; #HTML[#CALL:decode_object($7576, 49)]

; Room object 50: Tall drawers facing SW
@label=interior_object_tile_refs_50
bB$757E,1;21 width
 B$757F,1;21 height
 B$7580,2;21 {tile references
 B$7582,2*2
 B$7586,2;21 }
; #HTML[#CALL:decode_object($757E, 50)]

; Room object 51: Desk facing SW
@label=interior_object_tile_refs_51
bB$7588,1;36 width
 B$7589,1;36 height
 B$758A,6;36 {tile references
 B$7590,6*2
 B$759C,6;36 }
; #HTML[#CALL:decode_object($7588, 51)]

; Room object 52: Sink facing SE
@label=interior_object_tile_refs_52
bB$75A2,1;36 width
 B$75A3,1;36 height
 B$75A4,6;36 tile references (incl. RLE)
; #HTML[#CALL:decode_object($75A2, 52)]

; Room object 53: Key rack facing SE
@label=interior_object_tile_refs_53
bB$75AA,1;21 width
 B$75AB,1;21 height
 B$75AC,2;21 {tile references
 B$75AE,2;21 }
; #HTML[#CALL:decode_object($75AA, 53)]

; Room object 27: Room outline 18x10 A
@label=interior_object_tile_refs_27
bB$75B0,1;44 width
 B$75B1,1;44 height
 B$75B2,8;44 {tile references (incl. RLE)
 B$75BA,8*10
 B$760A,8;44 }
; #HTML[#CALL:decode_object($75B0, 27)]

; Character structures.
;
; This array contains one of these 7-byte structures for each of the 26 game characters:
; .
; #TABLE(default)
; { =h Type   | =h Bytes | =h Name             | =h Meaning }
; { Character |        1 | character_and_flags | Character index; bit 6 = on-screen flag }
; { Room      |        1 | room                | The room the character's in, and flags }
; { TinyPos   |        3 | pos                 | Map position of the character }
; { Route     |        2 | route               | The route the character's on }
; TABLE#
@label=character_structs
bB$7612,7;40 character_0_COMMANDANT,   room_11_PAPERS,   ( 46,  46, 24), (0x03, 0x00)
 B$7619,7;40 character_1_GUARD_1,      room_0_OUTDOORS,  (102,  68,  3), (0x01, 0x00)
 B$7620,7;40 character_2_GUARD_2,      room_0_OUTDOORS,  ( 68, 104,  3), (0x01, 0x02)
 B$7627,7;40 character_3_GUARD_3,      room_16_CORRIDOR, ( 46,  46, 24), (0x03, 0x13)
 B$762E,7;40 character_4_GUARD_4,      room_0_OUTDOORS,  ( 61, 103,  3), (0x02, 0x04)
 B$7635,7;40 character_5_GUARD_5,      room_0_OUTDOORS,  (106,  56, 13), (0x00, 0x00)
 B$763C,7;40 character_6_GUARD_6,      room_0_OUTDOORS,  ( 72,  94, 13), (0x00, 0x00)
 B$7643,7;40 character_7_GUARD_7,      room_0_OUTDOORS,  ( 72,  70, 13), (0x00, 0x00)
 B$764A,7;40 character_8_GUARD_8,      room_0_OUTDOORS,  ( 80,  46, 13), (0x00, 0x00)
 B$7651,7;40 character_9_GUARD_9,      room_0_OUTDOORS,  (108,  71, 21), (0x04, 0x00)
 B$7658,7;40 character_10_GUARD_10,    room_0_OUTDOORS,  ( 92,  52,  3), (0xFF, 0x38)
 B$765F,7;40 character_11_GUARD_11,    room_0_OUTDOORS,  (109,  69,  3), (0x00, 0x00)
 B$7666,7;40 character_12_GUARD_12,    room_3_HUT2RIGHT, ( 40,  60, 24), (0x00, 0x08)
; Bug: The room field here is 2 but reset_map_and_characters will reset it to
; 3.
 B$766D,7;40 character_13_GUARD_13,    room_2_HUT2LEFT,  ( 36,  48, 24), (0x00, 0x08)
 B$7674,7;40 character_14_GUARD_14,    room_5_HUT3RIGHT, ( 40,  60, 24), (0x00, 0x10)
 B$767B,7;40 character_15_GUARD_15,    room_5_HUT3RIGHT, ( 36,  34, 24), (0x00, 0x10)
 B$7682,7;40 character_16_GUARD_DOG_1, room_0_OUTDOORS,  ( 68,  84,  1), (0xFF, 0x00)
 B$7689,7;40 character_16_GUARD_DOG_2, room_0_OUTDOORS,  ( 68, 104,  1), (0xFF, 0x00)
 B$7690,7;40 character_18_GUARD_DOG_3, room_0_OUTDOORS,  (102,  68,  1), (0xFF, 0x18)
 B$7697,7;40 character_19_GUARD_DOG_4, room_0_OUTDOORS,  ( 88,  68,  1), (0xFF, 0x18)
 B$769E,7;40 character_20_PRISONER_1,  room_NONE,        ( 52,  60, 24), (0x00, 0x08)
 B$76A5,7;40 character_21_PRISONER_2,  room_NONE,        ( 52,  44, 24), (0x00, 0x08)
 B$76AC,7;40 character_22_PRISONER_3,  room_NONE,        ( 52,  28, 24), (0x00, 0x08)
 B$76B3,7;40 character_23_PRISONER_4,  room_NONE,        ( 52,  60, 24), (0x00, 0x10)
 B$76BA,7;40 character_24_PRISONER_5,  room_NONE,        ( 52,  44, 24), (0x00, 0x10)
 B$76C1,7;40 character_25_PRISONER_6,  room_NONE,        ( 52,  28, 24), (0x00, 0x10)

; Item structures.
;
; This array contains one of these 7-byte structures for each of the 16 game items:
; .
; #TABLE(default)
; { =h Type | =h Bytes | =h Name        | =h Meaning }
; { Item    |        1 | item_and_flags | bits 0..3 = item; bits 4..7 = flags }
; { Room    |        1 | room_and_flags | bits 0..5 = room; bits 6..7 = flags }
; { TinyPos |        3 | pos            | Map position of the item }
; { IsoPos  |        2 | iso_pos        | Isometric projected position of the item }
; TABLE#
@label=item_structs
bB$76C8,7;40 item_WIRESNIPS,        room_NONE,        (64, 32,  2), (0x78, 0xF4) // <- item_to_itemstruct, find_nearby_item
 B$76CF,7;40 item_SHOVEL,           room_9_CRATE,     (62, 48,  0), (0x7C, 0xF2)
 B$76D6,7;40 item_LOCKPICK,         room_10_LOCKPICK, (73, 36, 16), (0x77, 0xF0)
 B$76DD,7;40 item_PAPERS,           room_11_PAPERS,   (42, 58,  4), (0x84, 0xF3)
 B$76E4,7;40 item_TORCH,            room_14_TORCH,    (34, 24,  2), (0x7A, 0xF6)
 B$76EB,7;40 item_BRIBE,            room_NONE,        (36, 44,  4), (0x7E, 0xF4) // <- accept_bribe
 B$76F2,7;40 item_UNIFORM,          room_15_UNIFORM,  (44, 65, 16), (0x87, 0xF1)
@label=item_structs_food
 B$76F9,7;40 item_FOOD,             room_19_FOOD,     (64, 48, 16), (0x7E, 0xF0) // <- action_poison, called_from_main_loop
 B$7700,7;40 item_POISON,           room_1_HUT1RIGHT, (66, 52,  4), (0x7C, 0xF1)
 B$7707,7;40 item_RED_KEY,          room_22_REDKEY,   (60, 42,  0), (0x7B, 0xF2)
 B$770E,7;40 item_YELLOW_KEY,       room_11_PAPERS,   (28, 34,  0), (0x81, 0xF8)
 B$7715,7;40 item_GREEN_KEY,        room_0_OUTDOORS,  (74, 72,  0), (0x7A, 0x6E)
 B$771C,7;40 item_RED_CROSS_PARCEL, room_NONE,        (28, 50, 12), (0x85, 0xF6) // <- event_new_red_cross_parcel, new_red_cross_parcel
 B$7723,7;40 item_RADIO,            room_18_RADIO,    (36, 58,  8), (0x85, 0xF4)
 B$772A,7;40 item_PURSE,            room_NONE,        (36, 44,  4), (0x7E, 0xF4)
 B$7731,7;40 item_COMPASS,          room_NONE,        (52, 28,  4), (0x7E, 0xF4)

; Table of pointers to routes.
@label=routes
@assemble=,0
bW$7738,2;44 {Array, 46 long, of pointers to
 W$773A,2;44 $FF-terminated runs.
 W$773C,2*43
 W$7792,2;44 }
 B$7794,1;44 could be a terminating $FF
@label=route_7795
 B$7795,4;44 L-shaped route in the fenced area  #ROUTE($7795)
@label=route_7799
 B$7799,7;44 guard's route around the front perimeter wall  #ROUTE($7799)
@label=route_commandant
 B$77A0,8;44 {the commandant's route - the longest of all the routes  #ROUTE($77A0)
 B$77A8,8*4
 B$77C8,5;44 }
@label=route_77CD
 B$77CD,3;44 guard's route marching over the front gate  #ROUTE($77CD)
@label=route_exit_hut2
 B$77D0,4;44 route_exit_hut2  #ROUTE($77D0)
@label=route_exit_hut3
 B$77D4,4;44 route_exit_hut3  #ROUTE($77D4)
@label=route_prisoner_sleeps_1
 B$77D8,2;44 route_prisoner_sleeps_1  #ROUTE($77D8)
@label=route_prisoner_sleeps_2
 B$77DA,2;44 route_prisoner_sleeps_2  #ROUTE($77DA)
@label=route_prisoner_sleeps_3
 B$77DC,2;44 route_prisoner_sleeps_3  #ROUTE($77DC)
@label=route_77DE
 B$77DE,3;44 route_77DE  #ROUTE($77DE)
@label=route_77E1
 B$77E1,6;44 route_77E1  #ROUTE($77E1)
@label=route_77E7
 B$77E7,5;44 route_77E7  #ROUTE($77E7)
@label=route_77EC
 B$77EC,5;44 route_77EC  #ROUTE($77EC)
@label=route_prisoner_sits_1
 B$77F1,2;44 route_prisoner_sits_1  #ROUTE($77F1)
@label=route_prisoner_sits_2
 B$77F3,2;44 route_prisoner_sits_2  #ROUTE($77F3)
@label=route_prisoner_sits_3
 B$77F5,2;44 route_prisoner_sits_3  #ROUTE($77F5)
@label=route_guardA_breakfast
 B$77F7,2;44 route_guardA_breakfast  #ROUTE($77F7)
@label=route_guardB_breakfast
 B$77F9,2;44 route_guardB_breakfast  #ROUTE($77F9)
@label=route_guard_12_roll_call
 B$77FB,2;44 route_guard_12_roll_call  #ROUTE($77FB)
@label=route_guard_13_roll_call
 B$77FD,2;44 route_guard_13_roll_call  #ROUTE($77FD)
@label=route_guard_14_roll_call
 B$77FF,2;44 route_guard_14_roll_call  #ROUTE($77FF)
@label=route_guard_15_roll_call
 B$7801,2;44 route_guard_15_roll_call  #ROUTE($7801)
@label=route_prisoner_1_roll_call
 B$7803,2;44 route_prisoner_1_roll_call  #ROUTE($7803)
@label=route_prisoner_2_roll_call
 B$7805,2;44 route_prisoner_2_roll_call  #ROUTE($7805)
@label=route_prisoner_3_roll_call
 B$7807,2;44 route_prisoner_3_roll_call  #ROUTE($7807)
@label=route_prisoner_4_roll_call
 B$7809,2;44 route_prisoner_4_roll_call  #ROUTE($7809)
@label=route_prisoner_5_roll_call
 B$780B,2;44 route_prisoner_5_roll_call  #ROUTE($780B)
@label=route_prisoner_6_roll_call
 B$780D,2;44 route_prisoner_6_roll_call  #ROUTE($780D)
@label=route_go_to_solitary
 B$780F,6;44 route_go_to_solitary  #ROUTE($780F)
@label=route_hero_leave_solitary
 B$7815,5;44 route_hero_leave_solitary  #ROUTE($7815)
@label=route_guard_12_bed
 B$781A,5;44 route_guard_12_bed  #ROUTE($781A)
@label=route_guard_13_bed
 B$781F,6;44 route_guard_13_bed  #ROUTE($781F)
@label=route_guard_14_bed
 B$7825,6;44 route_guard_14_bed  #ROUTE($7825)
@label=route_guard_15_bed
 B$782B,6;44 route_guard_15_bed  #ROUTE($782B)
@label=route_hut2_left_to_right
 B$7831,2;44 route_hut2_left_to_right  #ROUTE($7831)
@label=route_7833
 B$7833,2;44 route_7833  #ROUTE($7833)
@label=route_hut2_right_to_left
 B$7835,3;44 route_hut2_right_to_left  #ROUTE($7835)
@label=route_hero_roll_call
 B$7838,2;44 route_hero_roll_call  #ROUTE($7838)
@assemble=,-1

; Table of map locations used in routes.
;
; Array, 78 long, of two-byte locations (x,y)
@label=locations
@keep
wW$783A,2;21 ( 68, 104)
 W$783C,2;21 ( 68,  84)
 W$783E,2;21 ( 68,  70)
@keep
 W$7840,2;21 ( 64, 102)
@keep
 W$7842,2;21 ( 64,  64)
 W$7844,2;21 ( 68,  68)
@keep
 W$7846,2;21 ( 64,  64)
 W$7848,2;21 ( 68,  64)
 W$784A,2;21 (104, 112)
@keep
 W$784C,2;21 ( 96, 112)
 W$784E,2;21 (106, 102)
 W$7850,2;21 ( 93, 104)
@keep
 W$7852,2;21 (124, 101)
@keep
 W$7854,2;21 (124, 112)
@keep
 W$7856,2;21 (116, 104)
@keep
 W$7858,2;21 (112, 100)
@keep
 W$785A,2;21 (120,  96)
@keep
 W$785C,2;21 (128,  88)
@keep
 W$785E,2;21 (112,  96)
 W$7860,2;21 (116,  84)
@keep
 W$7862,2;21 (124, 100)
@keep
 W$7864,2;21 (124, 112)
@keep
 W$7866,2;21 (116, 104)
@keep
 W$7868,2;21 (112, 100)
 W$786A,2;21 (102,  68)
 W$786C,2;21 (102,  64)
@keep
 W$786E,2;21 ( 96,  64)
 W$7870,2;21 ( 92,  68)
 W$7872,2;21 ( 86,  68)
 W$7874,2;21 ( 84,  64)
 W$7876,2;21 ( 74,  68)
 W$7878,2;21 ( 74,  64)
 W$787A,2;21 (102,  68)
 W$787C,2;21 ( 68,  68)
@keep
 W$787E,2;21 ( 68, 104)
 W$7880,2;21 (107,  69)
 W$7882,2;21 (107,  45)
 W$7884,2;21 ( 77,  45)
 W$7886,2;21 ( 77,  61)
 W$7888,2;21 ( 61,  61)
 W$788A,2;21 ( 61, 103)
 W$788C,2;21 (116,  76)
 W$788E,2;21 ( 44,  42)
 W$7890,2;21 (106,  72)
 W$7892,2;21 (110,  72)
 W$7894,2;21 ( 81, 104)
 W$7896,2;21 ( 52,  60)
 W$7898,2;21 ( 52,  44)
 W$789A,2;21 ( 52,  28)
 W$789C,2;21 (119, 107)
 W$789E,2;21 (122, 110)
 W$78A0,2;21 ( 52,  28)
 W$78A2,2;21 ( 40,  60)
 W$78A4,2;21 ( 36,  34)
 W$78A6,2;21 ( 80,  76)
 W$78A8,2;21 ( 89,  76)
 W$78AA,2;21 ( 89,  60)
 W$78AC,2;21 (100,  61)
 W$78AE,2;21 ( 92,  54)
 W$78B0,2;21 ( 84,  50)
 W$78B2,2;21 (102,  48)
 W$78B4,2;21 ( 96,  56)
 W$78B6,2;21 ( 79,  59)
 W$78B8,2;21 (103,  47)
 W$78BA,2;21 ( 52,  54)
 W$78BC,2;21 ( 52,  46)
 W$78BE,2;21 ( 52,  36)
 W$78C0,2;21 ( 52,  62)
 W$78C2,2;21 ( 32,  56)
 W$78C4,2;21 ( 52,  24)
 W$78C6,2;21 ( 42,  46)
 W$78C8,2;21 ( 34,  34)
@keep
 W$78CA,2;21 (120, 110)
@keep
 W$78CC,2;21 (118, 110)
 W$78CE,2;21 (116, 110)
@keep
 W$78D0,2;21 (121, 109)
@keep
 W$78D2,2;21 (119, 109)
 W$78D4,2;21 (117, 109)

; Door positions.
;
; 62 pairs of four-byte structs (<- setup_doors)
; .
; #define BYTE0(room, direction) ((room << 2) | direction)
@label=doors
bB$78D6,4;28 { BYTE0(room_0_OUTDOORS,             1), 0xB2, 0x8A,  6 }, // gates
@label=door_positions_1
 B$78DA,4;28 { BYTE0(room_0_OUTDOORS,             3), 0xB2, 0x8E,  6 }, // gates
 B$78DE,4;28 { BYTE0(room_0_OUTDOORS,             1), 0xB2, 0x7A,  6 },
 B$78E2,4;28 { BYTE0(room_0_OUTDOORS,             3), 0xB2, 0x7E,  6 },
 B$78E6,4;28 { BYTE0(room_34,                     0), 0x8A, 0xB3,  6 },
 B$78EA,4;28 { BYTE0(room_0_OUTDOORS,             2), 0x10, 0x34, 12 },
 B$78EE,4;28 { BYTE0(room_48,                     0), 0xCC, 0x79,  6 },
 B$78F2,4;28 { BYTE0(room_0_OUTDOORS,             2), 0x10, 0x34, 12 },
 B$78F6,4;28 { BYTE0(room_28_HUT1LEFT,            1), 0xD9, 0xA3,  6 },
 B$78FA,4;28 { BYTE0(room_0_OUTDOORS,             3), 0x2A, 0x1C, 24 },
 B$78FE,4;28 { BYTE0(room_1_HUT1RIGHT,            0), 0xD4, 0xBD,  6 },
 B$7902,4;28 { BYTE0(room_0_OUTDOORS,             2), 0x1E, 0x2E, 24 },
; If I set the room number to $80 in the next entry then I can't use the (left)
; door to exit, entering the door from the otherside puts me in a tunnel (I
; think).
 B$7906,4;28 { BYTE0(room_2_HUT2LEFT,             1), 0xC1, 0xA3,  6 },
 B$790A,4;28 { BYTE0(room_0_OUTDOORS,             3), 0x2A, 0x1C, 24 },
 B$790E,4;28 { BYTE0(room_3_HUT2RIGHT,            0), 0xBC, 0xBD,  6 },
 B$7912,4;28 { BYTE0(room_0_OUTDOORS,             2), 0x20, 0x2E, 24 },
 B$7916,4;28 { BYTE0(room_4_HUT3LEFT,             1), 0xA9, 0xA3,  6 },
 B$791A,4;28 { BYTE0(room_0_OUTDOORS,             3), 0x2A, 0x1C, 24 },
 B$791E,4;28 { BYTE0(room_5_HUT3RIGHT,            0), 0xA4, 0xBD,  6 },
 B$7922,4;28 { BYTE0(room_0_OUTDOORS,             2), 0x20, 0x2E, 24 },
 B$7926,4;28 { BYTE0(room_21_CORRIDOR,            0), 0xFC, 0xCA,  6 }, // 10
 B$792A,4;28 { BYTE0(room_0_OUTDOORS,             2), 0x1C, 0x24, 24 },
 B$792E,4;28 { BYTE0(room_20_REDCROSS,            0), 0xFC, 0xDA,  6 },
 B$7932,4;28 { BYTE0(room_0_OUTDOORS,             2), 0x1A, 0x22, 24 },
 B$7936,4;28 { BYTE0(room_15_UNIFORM,             1), 0xF7, 0xE3,  6 },
 B$793A,4;28 { BYTE0(room_0_OUTDOORS,             3), 0x26, 0x19, 24 },
 B$793E,4;28 { BYTE0(room_13_CORRIDOR,            1), 0xDF, 0xE3,  6 },
 B$7942,4;28 { BYTE0(room_0_OUTDOORS,             3), 0x2A, 0x1C, 24 },
 B$7946,4;28 { BYTE0(room_8_CORRIDOR,             1), 0x97, 0xD3,  6 },
 B$794A,4;28 { BYTE0(room_0_OUTDOORS,             3), 0x2A, 0x15, 24 },
 B$794E,4;28 { BYTE0(room_6,                      1), 0x00, 0x00,  0 }, // unused room
 B$7952,4;28 { BYTE0(room_0_OUTDOORS,             3), 0x22, 0x22, 24 },
 B$7956,4;28 { BYTE0(room_1_HUT1RIGHT,            1), 0x2C, 0x34, 24 },
 B$795A,4;28 { BYTE0(room_28_HUT1LEFT,            3), 0x26, 0x1A, 24 },
 B$795E,4;28 { BYTE0(room_3_HUT2RIGHT,            1), 0x24, 0x36, 24 }, // 17
 B$7962,4;28 { BYTE0(room_2_HUT2LEFT,             3), 0x26, 0x1A, 24 },
 B$7966,4;28 { BYTE0(room_5_HUT3RIGHT,            1), 0x24, 0x36, 24 },
 B$796A,4;28 { BYTE0(room_4_HUT3LEFT,             3), 0x26, 0x1A, 24 },
 B$796E,4;28 { BYTE0(room_23_BREAKFAST,           1), 0x28, 0x42, 24 },
 B$7972,4;28 { BYTE0(room_25_BREAKFAST,           3), 0x26, 0x18, 24 },
 B$7976,4;28 { BYTE0(room_23_BREAKFAST,           0), 0x3E, 0x24, 24 },
 B$797A,4;28 { BYTE0(room_21_CORRIDOR,            2), 0x20, 0x2E, 24 },
 B$797E,4;28 { BYTE0(room_19_FOOD,                1), 0x22, 0x42, 24 },
 B$7982,4;28 { BYTE0(room_23_BREAKFAST,           3), 0x22, 0x1C, 24 },
 B$7986,4;28 { BYTE0(room_18_RADIO,               1), 0x24, 0x36, 24 },
 B$798A,4;28 { BYTE0(room_19_FOOD,                3), 0x38, 0x22, 24 },
 B$798E,4;28 { BYTE0(room_21_CORRIDOR,            1), 0x2C, 0x36, 24 },
 B$7992,4;28 { BYTE0(room_22_REDKEY,              3), 0x22, 0x1C, 24 },
 B$7996,4;28 { BYTE0(room_22_REDKEY,              1), 0x2C, 0x36, 24 },
 B$799A,4;28 { BYTE0(room_24_SOLITARY,            3), 0x2A, 0x26, 24 },
 B$799E,4;28 { BYTE0(room_12_CORRIDOR,            1), 0x42, 0x3A, 24 },
 B$79A2,4;28 { BYTE0(room_18_RADIO,               3), 0x22, 0x1C, 24 },
 B$79A6,4;28 { BYTE0(room_17_CORRIDOR,            0), 0x3C, 0x24, 24 },
 B$79AA,4;28 { BYTE0(room_7_CORRIDOR,             2), 0x1C, 0x22, 24 },
 B$79AE,4;28 { BYTE0(room_15_UNIFORM,             0), 0x40, 0x28, 24 },
 B$79B2,4;28 { BYTE0(room_14_TORCH,               2), 0x1E, 0x28, 24 },
 B$79B6,4;28 { BYTE0(room_16_CORRIDOR,            1), 0x22, 0x42, 24 },
 B$79BA,4;28 { BYTE0(room_14_TORCH,               3), 0x22, 0x1C, 24 },
 B$79BE,4;28 { BYTE0(room_16_CORRIDOR,            0), 0x3E, 0x2E, 24 },
 B$79C2,4;28 { BYTE0(room_13_CORRIDOR,            2), 0x1A, 0x22, 24 },
 B$79C6,4;28 { BYTE0(room_0_OUTDOORS,             0), 0x44, 0x30, 24 },
 B$79CA,4;28 { BYTE0(room_0_OUTDOORS,             2), 0x20, 0x30, 24 },
 B$79CE,4;28 { BYTE0(room_13_CORRIDOR,            0), 0x4A, 0x28, 24 },
 B$79D2,4;28 { BYTE0(room_11_PAPERS,              2), 0x1A, 0x22, 24 },
 B$79D6,4;28 { BYTE0(room_7_CORRIDOR,             0), 0x40, 0x24, 24 },
 B$79DA,4;28 { BYTE0(room_16_CORRIDOR,            2), 0x1A, 0x22, 24 },
 B$79DE,4;28 { BYTE0(room_10_LOCKPICK,            0), 0x36, 0x35, 24 },
 B$79E2,4;28 { BYTE0(room_8_CORRIDOR,             2), 0x17, 0x26, 24 },
 B$79E6,4;28 { BYTE0(room_9_CRATE,                0), 0x36, 0x1C, 24 },
 B$79EA,4;28 { BYTE0(room_8_CORRIDOR,             2), 0x1A, 0x22, 24 },
 B$79EE,4;28 { BYTE0(room_12_CORRIDOR,            0), 0x3E, 0x24, 24 },
 B$79F2,4;28 { BYTE0(room_17_CORRIDOR,            2), 0x1A, 0x22, 24 },
 B$79F6,4;28 { BYTE0(room_29_SECOND_TUNNEL_START, 1), 0x36, 0x36, 24 },
 B$79FA,4;28 { BYTE0(room_9_CRATE,                3), 0x38, 0x0A, 12 },
 B$79FE,4;28 { BYTE0(room_52,                     1), 0x38, 0x62, 12 },
 B$7A02,4;28 { BYTE0(room_30,                     3), 0x38, 0x0A, 12 },
 B$7A06,4;28 { BYTE0(room_30,                     0), 0x64, 0x34, 12 },
 B$7A0A,4;28 { BYTE0(room_31,                     2), 0x38, 0x26, 12 },
 B$7A0E,4;28 { BYTE0(room_30,                     1), 0x38, 0x62, 12 },
 B$7A12,4;28 { BYTE0(room_36,                     3), 0x38, 0x0A, 12 },
 B$7A16,4;28 { BYTE0(room_31,                     0), 0x64, 0x34, 12 },
 B$7A1A,4;28 { BYTE0(room_32,                     2), 0x0A, 0x34, 12 },
 B$7A1E,4;28 { BYTE0(room_32,                     1), 0x38, 0x62, 12 },
 B$7A22,4;28 { BYTE0(room_33,                     3), 0x20, 0x34, 12 },
 B$7A26,4;28 { BYTE0(room_33,                     1), 0x40, 0x34, 12 },
 B$7A2A,4;28 { BYTE0(room_35,                     3), 0x38, 0x0A, 12 },
 B$7A2E,4;28 { BYTE0(room_35,                     0), 0x64, 0x34, 12 },
 B$7A32,4;28 { BYTE0(room_34,                     2), 0x0A, 0x34, 12 },
 B$7A36,4;28 { BYTE0(room_36,                     0), 0x64, 0x34, 12 },
 B$7A3A,4;28 { BYTE0(room_35,                     2), 0x38, 0x1C, 12 },
 B$7A3E,4;28 { BYTE0(room_37,                     0), 0x3E, 0x22, 24 }, // tunnel entrance
 B$7A42,4;28 { BYTE0(room_2_HUT2LEFT,             2), 0x10, 0x34, 12 },
 B$7A46,4;28 { BYTE0(room_38,                     0), 0x64, 0x34, 12 },
 B$7A4A,4;28 { BYTE0(room_37,                     2), 0x10, 0x34, 12 },
 B$7A4E,4;28 { BYTE0(room_39,                     1), 0x40, 0x34, 12 },
 B$7A52,4;28 { BYTE0(room_38,                     3), 0x20, 0x34, 12 },
 B$7A56,4;28 { BYTE0(room_40,                     0), 0x64, 0x34, 12 },
 B$7A5A,4;28 { BYTE0(room_38,                     2), 0x38, 0x54, 12 },
 B$7A5E,4;28 { BYTE0(room_40,                     1), 0x38, 0x62, 12 },
 B$7A62,4;28 { BYTE0(room_41,                     3), 0x38, 0x0A, 12 },
 B$7A66,4;28 { BYTE0(room_41,                     0), 0x64, 0x34, 12 },
 B$7A6A,4;28 { BYTE0(room_42,                     2), 0x38, 0x26, 12 },
 B$7A6E,4;28 { BYTE0(room_41,                     1), 0x38, 0x62, 12 },
 B$7A72,4;28 { BYTE0(room_45,                     3), 0x38, 0x0A, 12 },
 B$7A76,4;28 { BYTE0(room_45,                     0), 0x64, 0x34, 12 },
 B$7A7A,4;28 { BYTE0(room_44,                     2), 0x38, 0x1C, 12 },
 B$7A7E,4;28 { BYTE0(room_43,                     1), 0x20, 0x34, 12 },
 B$7A82,4;28 { BYTE0(room_44,                     3), 0x38, 0x0A, 12 },
 B$7A86,4;28 { BYTE0(room_42,                     1), 0x38, 0x62, 12 },
 B$7A8A,4;28 { BYTE0(room_43,                     3), 0x20, 0x34, 12 },
 B$7A8E,4;28 { BYTE0(room_46,                     0), 0x64, 0x34, 12 },
 B$7A92,4;28 { BYTE0(room_39,                     2), 0x38, 0x1C, 12 },
 B$7A96,4;28 { BYTE0(room_47,                     1), 0x38, 0x62, 12 },
 B$7A9A,4;28 { BYTE0(room_46,                     3), 0x20, 0x34, 12 },
 B$7A9E,4;28 { BYTE0(room_50_BLOCKED_TUNNEL,      0), 0x64, 0x34, 12 },
 B$7AA2,4;28 { BYTE0(room_47,                     2), 0x38, 0x56, 12 },
 B$7AA6,4;28 { BYTE0(room_50_BLOCKED_TUNNEL,      1), 0x38, 0x62, 12 },
 B$7AAA,4;28 { BYTE0(room_49,                     3), 0x38, 0x0A, 12 },
 B$7AAE,4;28 { BYTE0(room_49,                     0), 0x64, 0x34, 12 },
 B$7AB2,4;28 { BYTE0(room_48,                     2), 0x38, 0x1C, 12 },
 B$7AB6,4;28 { BYTE0(room_51,                     1), 0x38, 0x62, 12 },
 B$7ABA,4;28 { BYTE0(room_29_SECOND_TUNNEL_START, 3), 0x20, 0x34, 12 },
 B$7ABE,4;28 { BYTE0(room_52,                     0), 0x64, 0x34, 12 },
 B$7AC2,4;28 { BYTE0(room_51,                     2), 0x38, 0x54, 12 },

; Solitary map position.
;
; Used by solitary.
@label=solitary_pos
bB$7AC6,3;24 0x3A, 0x2A, 24 // tinypos_t

; Check for 'pick up', 'drop' and 'use' input events.
;
; Used by the routine at #R$9E07.
;
; I:A Input event.
@label=process_player_input_fire
cC$7AC9,2;21 Is the input event fire + up?
 C$7ACB,3;21 Test for the next input event if not
 C$7ACE,3;21 Call pick_up_item if so
 C$7AD1,2;21 Then return
*C$7AD3,2;21 Is the input event fire + down?
 C$7AD5,3;21 Test for the next input event if not
 C$7AD8,3;21 Call drop_item if so
 C$7ADB,2;21 Then return
*C$7ADD,2;21 Is the input event fire + left?
 C$7ADF,3;21 Test for the next input event if not
 C$7AE2,3;21 Call use_item_A if so
 C$7AE5,2;21 Then return
*C$7AE7,2;21 Is the input event fire + right?
 C$7AE9,3;21 Test for the next input event if not
 C$7AEC,3;21 Call use_item_B if so
@label=check_for_pick_up_keypress_exit
*C$7AEF,1;21 Return
; Use item 'B'.
@label=use_item_B
@isub=LD A,(items_held + 1)
*C$7AF0,3;21 Fetch the second held item
 C$7AF3,2;21 Jump over item 'A' case
; Use item 'A'.
@label=use_item_A
*C$7AF5,3;21 Fetch the first held item
; Use item common.
@label=use_item_common
*C$7AF8,2;21 Is the item in #REGa item_NONE? ($FF)
 C$7AFA,1;21 Return if so
@rfix-begin
 C$7AFB,2;21 Bug: Pointless jump to adjacent instruction
@rfix-end
*C$7AFD,1;21 {Point #REGhl at the #REGa'th entry of item_actions_jump_table
 C$7AFE,3;21
@nowarn
 C$7B01,3;21
 C$7B04,1;21 }
 C$7B05,1;21 {Fetch the jump table destination address
 C$7B06,2;21
 C$7B08,1;21 }
 C$7B09,1;21 Stack the jump table destination address
 C$7B0A,3;21 {Copy X,Y and height from the hero's position into saved_pos
 C$7B0D,6;21
 C$7B13,2;21 }
 C$7B15,1;21 Jump to the stacked destination address
; Item actions jump table.
@label=item_actions_jump_table
 W$7B16,2*4;21
 W$7B1E,2;21 Return
 W$7B20,2*2;21
 W$7B24,2;21 Return
 W$7B26,2*5;21
 W$7B30,2;21 Return
 W$7B32,2;21 Return
 W$7B34,2;21 Return

; Pick up an item.
;
; Used by the routine at #R$7AC9.
@label=pick_up_item
cC$7B36,3;21 Load both held items into #REGhl
 C$7B39,2;21 Set #REGa to item_NONE ($FF)
 C$7B3B,1;21 {If neither item slot is empty then return - we don't have the space to pick another item up
 C$7B3C,3;21
 C$7B3F,1;21 }
@label=pick_up_have_empty_slot
*C$7B40,3;21 Find nearby items. #REGhl points to an item in item_structs if found
 C$7B43,1;21 Return if no items were found
; Locate an empty item slot.
 C$7B44,3;21 Point #REGde at the held items array
 C$7B47,1;21 Load an item
 C$7B48,2;21 {Step over the item if it's item_NONE
 C$7B4A,2;21
 C$7B4C,1;21 }
*C$7B4D,1;21 {Fetch the item_struct item's first byte and mask off the item.
 C$7B4E,2;21 Note: The mask used here is $1F, not $0F as seen elsewhere in the code. Unsure why
 C$7B50,1;21 }
 C$7B51,1;21 Save the item_struct item pointer
 C$7B52,3;21 Fetch the global current room index
 C$7B55,2;21 Are we outdoors?
 C$7B57,3;21 No - jump to indoor handling
@label=pick_up_outdoors
 C$7B5A,3;21 Plot all tiles
 C$7B5D,2;21 Jump over indoor handling
@label=pick_up_indoors
*C$7B5F,3;21 Expand out the room definition for room_index
 C$7B62,3;21 Expand all of the tile indices in the tiles buffer to full tiles in the screen buffer
 C$7B65,3;21 Choose game window attributes
 C$7B68,3;21 Set game window attributes
*C$7B6B,1;21 Retrieve the item_struct item pointer
 C$7B6C,2;21 Is the itemstruct_ITEM_FLAG_HELD flag set? ($80)
 C$7B6E,2;21 Jump if so
@label=pick_up_novel_item
; Have picked up an item not previously held - increase the score.
 C$7B70,2;21 Set the itemstruct_ITEM_FLAG_HELD flag so we only award these points on the first pick-up
 C$7B72,1;21 Save the item_struct item pointer again
 C$7B73,3;21 Increase morale by 5, score by 5
 C$7B76,1;21 Retrieve again
; Make the item disappear.
*C$7B77,1;21 Zero #REGa
 C$7B78,1;21 {Zero itemstruct->room_and_flags
 C$7B79,1;21 }
 C$7B7A,1;21 {Advance #REGhl to itemstruct->screenpos
 C$7B7B,2;21
 C$7B7D,1;21 }
 C$7B7E,1;21 {Zero itemstruct->screenpos.screen_x and screen_y
 C$7B7F,1;21
 C$7B80,1;21 }
 C$7B81,3;21 Draw both held items
 C$7B84,3;21 {Play the "pick up item" sound
 C$7B87,3;21 }
 C$7B8A,1;21 Return

; Drop the first held item then shuffle the second into the first slot.
;
; Used by the routine at #R$7AC9.
;
; .
;
; Return if no items held.
@label=drop_item
cC$7B8B,3;21 Fetch the first held item
 C$7B8E,2;21 Is the item item_NONE? ($FF)
 C$7B90,1;21 Return if so - there are no items to drop
; When dropping the uniform reset the hero's sprite.
 C$7B91,2;21 Does #REGa contain item_UNIFORM? (6)
 C$7B93,3;21 Jump if not
 C$7B96,3;21 {Set the hero's sprite definition pointer to #R$CE2E to remove the guard's uniform
 C$7B99,3;21 }
*C$7B9C,1;21 Save item
; Shuffle items down.
@isub=LD HL,items_held + 1
 C$7B9D,3;21 Point #REGhl at the second held item
 C$7BA0,1;21 Fetch its value
 C$7BA1,2;21 Set it to item_NONE
 C$7BA3,1;21 Now point to the first held item
 C$7BA4,1;21 Store the fetched item there
; Redraw
 C$7BA5,3;21 Draw both held items
 C$7BA8,3;21 {Play the "drop item" sound
 C$7BAB,3;21 }
 C$7BAE,3;21 Choose game window attributes
 C$7BB1,3;21 Set game window attributes
 C$7BB4,1;21 Restore item
; FALL THROUGH into drop_item_tail.

; Drop item, tail part.
;
; Used by the routine at #R$B387.
;
; I:A Item index.
@label=drop_item_tail
cC$7BB5,3;21 Convert the item index in #REGa into an itemstruct pointer
 C$7BB8,1;21 Advance #REGhl to point to the room index
 C$7BB9,3;21 Get the global current room index
 C$7BBC,1;21 Set the object's room index
 C$7BBD,1;21 Is it outdoors? (room index is zero)
 C$7BBE,2;21 Jump if not
; Outdoors.
 C$7BC0,1;21 Point #REGhl at itemstruct.pos
 C$7BC1,1;21 Save for below
 C$7BC2,1;21 {Bug: HL is incremented by two here but then is immediately overwritten by the LD HL at $7BC5.
 C$7BC3,1;21 }
 C$7BC4,1;21 Restore itemstruct.pos pointer into #REGde
 C$7BC5,3;21 Point #REGhl at the hero's map position
 C$7BC8,3;21 Scale down hero's map position (#REGhl) and assign the result to itemstruct's tinypos (#REGde). #REGde is updated to point after tinypos on return
 C$7BCB,1;21 Point at height field
 C$7BCC,2;21 {Set height to zero
 C$7BCE,1;21 }
 C$7BCF,1;21 Move itemstruct pointer into HL
; FALL THROUGH into calc_exterior_item_iso_pos.

; Calculate isometric screen position for dropped exterior items.
;
; Used by the routine at #R$CD31.
;
; I:HL Pointer to item struct.
;
@label=calc_exterior_item_iso_pos
; Set #REGc to ($40 + y - x) * 2
cC$7BD0,1;21 Point to itemstruct.y
 C$7BD1,7;21
; Set #REGb to ($200 - x - y - height)
 C$7BD8,1;21 Zero result - this acts like $200
 C$7BD9,7;21
; Write the result to itemstruct.screenpos
 C$7BE0,3;21
 C$7BE3,1;21 Return

; Drop item, interior part.
;
; Used by the routine at #R$7BB5.
;
; I:HL Pointer to item struct.
@label=drop_item_interior
cC$7BE4,1;21 Point to itemstruct.x
 C$7BE5,3;21 Point #REGde at the hero's map position.x
 C$7BE8,1;21 Fetch x
 C$7BE9,1;21 Store x in itemstruct.x
 C$7BEA,1;21 Point to itemstruct.y
 C$7BEB,1;21 {Point #REGde at the hero's map position.y
 C$7BEC,1;21 }
 C$7BED,1;21 Fetch y
 C$7BEE,1;21 Store y in itemstruct.y
 C$7BEF,1;21 Point #REGhl at itemstruct.height
 C$7BF0,2;21 Set height to five
; FALL THROUGH into calc_interior_item_iso_pos.

; Calculate isometric screen position for dropped interior items.
;
; TODO: Describe why this has to scale things whereas the above exterior variant doesn't.
; .
; Used by the routine at #R$CD31.
;
; I:HL Pointer to item struct + ?
@label=calc_interior_item_iso_pos
; Set #REGa' to ($200 + y - x) * 2
cC$7BF2,13;21
 C$7BFF,1;21 Double
 C$7C00,2;21
 C$7C02,3;21 Divide #REGhl by 8 with rounding. Assign the result to #REGa
 C$7C05,1;21
; Set #REGa to ($800 - x - y - height)
 C$7C06,5;21
 C$7C0B,1;21 #REGde points to x
 C$7C0C,16;21
 C$7C1C,3;21 Divide #REGhl by 8 with rounding. Assign the result to #REGa
; Write the result to itemstruct.screenpos
 C$7C1F,6;21
 C$7C25,1;21 Return

; Convert an item to an itemstruct pointer.
;
; Used by the routines at #R$7BB5, #R$A228 and #R$CD31.
;
; I:A  Item index.
; O:HL Pointer to itemstruct.
@label=item_to_itemstruct
cC$7C26,1;21 {Multiply item index by seven
 C$7C27,3;21
 C$7C2A,1;21 }
 C$7C2B,3;21 Point #REGhl at the first element of item_structs
 C$7C2E,1;21 {Add the two
 C$7C2F,2;21
 C$7C31,1;21 }
 C$7C32,1;21 Return i'th element of item_structs in #REGhl

; Draw both held items.
;
; Used by the routines at #R$7B36, #R$7B8B, #R$B107, #R$B387, #R$B3C4, #R$B75A
; and #R$CB98.
@label=draw_all_items
cC$7C33,3;21 Point #REGhl at the screen address of item 1
 C$7C36,3;21 Fetch the first held item
 C$7C39,3;21 Draw the item
 C$7C3C,3;21 Point #REGhl at the screen address of item 2
 C$7C3F,3;21 Fetch the second held item
 C$7C42,3;21 Draw the item
 C$7C45,1;21 Return

; Draw a single held item.
;
; Used by the routine at #R$7C33.
;
; I:A  Item index.
; I:HL Screen address of item.
@label=draw_item
cC$7C46,1;21 Save screen address of item
 C$7C47,1;21 Bank item index
; Wipe the item's screen area.
 C$7C48,2;21 2 bytes / pixels wide
 C$7C4A,2;21 16 pixels high
 C$7C4C,3;21 Wipe the screen area pointed to by #REGhl
; Bail if no item.
 C$7C4F,1;21 Retrieve screen address
 C$7C50,1;21 Retrieve item index
 C$7C51,2;21 Is the item index item_NONE? ($FF)
 C$7C53,1;21 Return if so
; Set screen attributes.
 C$7C54,1;21 Save screen address again
 C$7C55,2;21 Set #REGh to $5A which points #REGhl at the attribute for the equivalent screen address
 C$7C57,1;21 Save item index
 C$7C58,3;21 {Get the attribute byte for this item
 C$7C5B,5;21
*C$7C60,1;21 }
 C$7C61,1;21 {Write two attribute bytes
 C$7C62,1;21
 C$7C63,1;21 }
; Move to next attribute row.
 C$7C64,1;21 Move #REGhl back for the next row
 C$7C65,2;21 Move #REGhl to the next attribute row
 C$7C67,1;21 {Write two attribute bytes
 C$7C68,1;21
 C$7C69,1;21 }
 C$7C6A,1;21 Retrieve item index
; Plot bitmap.
 C$7C6B,1;21 {Point #REGhl at the definition for this item
 C$7C6C,9;21
 C$7C75,1;21 }
 C$7C76,1;21 {Fetch width
 C$7C77,1;21 }
 C$7C78,1;21 {Fetch height
 C$7C79,1;21 }
 C$7C7A,1;21 {Fetch sprite data pointer
 C$7C7B,1;21
 C$7C7C,1;21 }
 C$7C7D,1;21 Retrieve screen address saved at #R$7C54
 C$7C7E,3;21 Plot the bitmap without masking
 C$7C81,1;21 Return

; Returns an item within range of the hero.
;
; Used by the routine at #R$7B36.
;
; O:AF Z set if item found, NZ otherwise.
; O:HL If item was found contains pointer to the item.
;
; Select a pick up radius based on the room.
@label=find_nearby_item
cC$7C82,2;21 Set the pick up radius to one
 C$7C84,3;21 Fetch global current room index
 C$7C87,1;21 Is it room_0_OUTDOORS?
 C$7C88,2;21 Jump if so
 C$7C8A,2;21 Otherwise set the pick up radius to six
; Loop for all items.
*C$7C8C,2;21 Sixteen items (item__LIMIT)
 C$7C8E,3;21 Point #REGhl at the first item_struct's room member
@label=find_nearby_item_loop
*C$7C91,2;21 Is the itemstruct_ROOM_FLAG_ITEM_NEARBY_7 flag set? ($80)
 C$7C93,2;21 If not, jump to the next iteration
 C$7C95,1;21 Save item counter
 C$7C96,1;21 Save item_struct pointer
 C$7C97,1;21 Point #REGhl at itemstruct position
 C$7C98,3;21 Point #REGde at global map position (hero)
 C$7C9B,2;21 Do two loop iterations (once for x then y)
; Range check.
@label=find_nearby_position_loop
*C$7C9D,1;21 Read a map position byte
 C$7C9E,1;21 {if (map_pos_byte (#REGa) - pick_up_radius (#REGc) >= itemstruct_byte || map_pos_byte + pick_up_radius < itemstruct_byte) jump to pop_next
 C$7C9F,6;21
 C$7CA5,2;21 }
 C$7CA7,1;21 Move to next itemstruct byte
 C$7CA8,1;21 Move to next map position byte
 C$7CA9,2;21 ...loop for both bytes
 C$7CAB,1;21 Restore item_struct pointer
 C$7CAC,1;21 Compensate for overshoot. Point to itemstruct.item for return value
 C$7CAD,1;21 Restore item counter
 C$7CAE,1;21 Set Z (found)
@bfix-begin
; Bug: The next instruction is written as RET Z but there's no need for it to
; be conditional.
 C$7CAF,1;21 Return
@bfix+else
 $7CAF RET           ; Return
@bfix+end
@label=find_nearby_pop_next
*C$7CB0,1;21 Restore item_struct pointer
 C$7CB1,1;21 Restore item counter
@label=find_nearby_next
*C$7CB2,2;21 {Step #REGhl to the next item_struct
 C$7CB4,4;21
 C$7CB8,1;21 }
*C$7CB9,2;21 ...loop for each item
 C$7CBB,2;21 Ran out of items: set NZ (not found)
 C$7CBD,1;21 Return

; Plot a bitmap without masking.
;
; Used by the routines at #R$7C46, #R$A035 and #R$A0C9.
;
; I:BC Dimensions (B x C == width x height, where width is specified in bytes).
; I:DE Source address.
; I:HL Destination address.
@label=plot_bitmap
cC$7CBE,1;21 Set #REGa to the byte width of the bitmap
 C$7CBF,3;21 Self modify the width counter at $7CC2 to set #REGb to the byte width
@label=plot_bitmap_row
*C$7CC2,2;21 Set the column counter to the bitmap width in bytes
 C$7CC4,1;21 Save the destination address
@label=plot_bitmap_column
*C$7CC5,1;21 {Copy a byte across
 C$7CC6,1;21 }
 C$7CC7,1;21 Step destination address
 C$7CC8,1;21 Step source address
 C$7CC9,2;21 Decrement the column counter then loop for every column
 C$7CCB,1;21 Restore the destination address
 C$7CCC,3;21 Move the destination address down a scanline
 C$7CCF,1;21 Decrement the row counter
 C$7CD0,3;21 ...loop for every row
 C$7CD3,1;21 Return

; Wipe an area of the screen.
;
; Used by the routine at #R$7C46.
;
; I:BC Dimensions (B x C == width x height, where width is specified in bytes).
; I:HL Destination address.
@label=screen_wipe
cC$7CD4,1;21 Set #REGa to the byte width of the area to wipe
 C$7CD5,3;21 Self modify the width counter at $7CD8 to set #REGb to the byte width
@label=screen_wipe_row
*C$7CD8,2;21 Set the column counter to the bitmap width in bytes
 C$7CDA,1;21 Save the destination address
@label=screen_wipe_column
*C$7CDB,2;21 Wipe a byte
 C$7CDD,1;21 Step destination address
 C$7CDE,2;21 Decrement the column counter then loop for every column
 C$7CE0,1;21 Restore the destination address
 C$7CE1,3;21 Move the destination address down a scanline
 C$7CE4,1;21 Decrement the row counter
 C$7CE5,3;21 ...loop for every row
 C$7CE8,1;21 Return

; Given a screen address, return the same position on the next scanline down.
;
; Used by the routines at #R$7CBE, #R$7CD4, #R$A035 and #R$F20B.
;
; I:HL Original screen address.
; O:HL Updated screen address.
@label=next_scanline_down
cC$7CE9,1;21 Incrementing #REGh moves us to the next minor row
 C$7CEA,1;21
 C$7CEB,2;21 Unless we hit an exact multiple of eight - in which case we stepped to the next third of the screen
 C$7CED,1;21 Just return if we didn't
 C$7CEE,1;21 Borrow #REGde for scratch
 C$7CEF,3;21 Step back by a third ($F8), then to the next major row ($20)
 C$7CF2,1;21 {Unless we will hit a boundary in doing that
 C$7CF3,2;21 }
 C$7CF5,2;21 Skip, if we won't
 C$7CF7,2;21 If we will then step back by a minor row, then to the next major row
*C$7CF9,1;21 Step
 C$7CFA,1;21 Restore
 C$7CFB,1;21 Return

; The pending message queue.
@label=message_queue
gB$7CFC,8;44 {Queue of message indexes. Pairs of bytes + 0xFF terminator.
 B$7D04,8;44
 B$7D0C,3;44 }

; Countdown to the next message.
@label=message_display_delay
gB$7D0F,1;44 Decrementing counter which shows the next message when it reaches zero.

; Index into the message we're displaying or wiping.
@label=message_display_index
gB$7D10,1;44 If 128 then next_message. If > 128 then wipe_message. Else display.

; Pointer to the next available slot in the message queue.
@label=message_queue_pointer
gW$7D11,2

; Pointer to the next message character to be displayed.
@label=current_message_character
gW$7D13,2

; Add a new message index to the pending messages queue.
;
; Used by the routines at #R$9DCF, #R$9E98, #R$A1D3, #R$A1E7, #R$A1F0, #R$A1F9,
; #R$A206, #R$A219, #R$A228, #R$B107, #R$B1D4, #R$B387, #R$B417, #R$B495,
; #R$B4B8, #R$CB98, #R$CD31 and #R$EF9A.
; .
; The use of #REGc on entry to this routine is puzzling. One routine (#R$9DCF)
; explicitly sets it to zero before calling, but the other callers do not so we
; receive whatever was in #REGc previously.
;
; I:B Message index.
; I:C Unknown: possibly a second message index.
@label=queue_message
cC$7D15,3;21 Fetch the message queue pointer
 C$7D18,2;21 {Is the currently pointed-to index message_QUEUE_END? ($FF)
 C$7D1A,1;21 }
 C$7D1B,1;21 Return if so - the queue is full
; Is this message index already pending?
 C$7D1C,1;21 {Step back two bytes to the next pending entry
 C$7D1D,1;21 }
 C$7D1E,1;21 {If the new message index matches the pending entry then return
 C$7D1F,6;21
 C$7D25,1;21 }
; Add it to the queue.
*C$7D26,1;21 {Store the new message index
 C$7D27,3;21
 C$7D2A,1;21 }
 C$7D2B,3;21 Update the message queue pointer
 C$7D2E,1;21 Return

; Plot a single glyph (indirectly).
;
; Used by the routines at #R$7D48, #R$A10B, #R$A5BF and #R$F350.
;
; I:HL Pointer to glyph index.
; I:DE Pointer to screen destination.
; O:HL Preserved.
; O:DE Points to the next character position to the right.
@label=plot_glyph
cC$7D2F,1;21 Fetch the glyph index
; FALL THROUGH into plot_single_glyph,

; Plot a single glyph.
;
; Used by the routine at #R$7D87.
; .
; Note: This won't work for arbitrary screen locations.
;
; I:HL Glyph index.
; I:DE Pointer to screen destination.
; O:HL Preserved.
; O:DE Points to the next character position to the right.
@label=plot_single_glyph
cC$7D30,1;21 Preserve #REGhl
 C$7D31,1;21 {Point #REGhl at the bitmap glyph we want to plot
 C$7D32,8;21
 C$7D3A,1;21 }
 C$7D3B,1;21 Preserve #REGde so we can return it incremented later
 C$7D3C,2;21 8 rows
@label=glyph_loop
*C$7D3E,1;21 {Plot a byte (a row) of bitmap glyph
 C$7D3F,1;21 }
 C$7D40,1;21 Move down to the next scanline (#REGde increases by 256)
 C$7D41,1;21 Move to the next byte of the bitmap glyph
 C$7D42,2;21 ...loop until the glyph is drawn
 C$7D44,1;21 {Restore and point #REGde at the next character position to the right
 C$7D45,1;21 }
 C$7D46,1;21 Restore #REGhl
 C$7D47,1;21 Return

; Incrementally wipe and display queued game messages.
;
; Used by the routine at #R$9D7B.
;
; .
;
; Proceed only if message display delay is zero.
@label=message_display
cC$7D48,3;21 {If message display delay is positive...
 C$7D4B,1;21
 C$7D4C,3;21 }
 C$7D4F,1;21 {Decrement it - we'll get called again until it hits zero
 C$7D50,3;21 }
 C$7D53,1;21 Return
; Otherwise message_display_delay reached zero.
*C$7D54,3;21 {If message display index == message_NEXT (128) exit via (jump to) next_message
 C$7D57,2;21
 C$7D59,2;21 }
 C$7D5B,2;21 Otherwise if message display index > message_NEXT exit via (jump to) wipe_message
; Display a character
 C$7D5D,3;21 Otherwise... point #REGhl to the current message character
@nowarn
 C$7D60,3;21 {Point #REGde at the message text screen address
 C$7D63,1;21 plus the display index
 C$7D64,1;21 }
 C$7D65,3;21 Plot the glyph
 C$7D68,1;21 {Save the incremented message display index
 C$7D69,2;21
 C$7D6B,3;21 }
 C$7D6E,1;21 {Check for end of string ($FF)
 C$7D6F,3;21
 C$7D72,3;21 }
; Leave the message for 31 turns, then wipe it.
 C$7D75,2;21 {Set message display delay to 31
 C$7D77,3;21 }
 C$7D7A,3;21 {Set the message_NEXT flag in the message display index
 C$7D7D,2;21
 C$7D7F,3;21 }
 C$7D82,1;21 Return
@label=not_end_of_string
*C$7D83,3;21 If it wasn't the end of the string set current message character to #REGhl
 C$7D86,1;21 Return

; Incrementally wipe away any on-screen game message.
;
; Used by the routine at #R$7D48.
@label=wipe_message
cC$7D87,3;21 {Decrement the message display index
 C$7D8A,1;21
 C$7D8B,3;21 }
@nowarn
 C$7D8E,3;21 {Point #REGde at the message text screen address
 C$7D91,1;21 plus the display index
 C$7D92,1;21 }
; Overplot the previous character with a single space.
 C$7D93,2;21 Glyph index of space
 C$7D95,3;21 Plot the single space glyph
 C$7D98,1;21 Return

; Change to displaying the next queued game message.
;
; Used by the routine at #R$7D48.
; .
; Called when messages.display_index == 128.
@label=next_message
cC$7D99,3;21 Get the message queue pointer
 C$7D9C,3;21 Queue start address
 C$7D9F,1;21 {Is the queue pointer at the start of the queue?
 C$7DA0,1;21 }
 C$7DA1,1;21 Return if so
 C$7DA2,1;21
 C$7DA3,1;21 {Get message index from queue
 C$7DA4,1;21 }
@rsub-begin
 C$7DA5,1;21 Bug: C is loaded here but not used. This could be a hangover from 16-bit message IDs
@rsub-end
 C$7DA6,1;21 {Set current message character pointer to messages_table[A]
 C$7DA7,11;21
 C$7DB2,3;21 }
 C$7DB5,3;21 {Shunt the whole queue back by two bytes discarding the first element
 C$7DB8,6;21
 C$7DBE,2;21 }
 C$7DC0,3;21 {Move the message queue pointer back
 C$7DC3,2;21
 C$7DC5,3;21 }
 C$7DC8,1;21 {Zero the message display index
 C$7DC9,3;21 }
 C$7DCC,1;21 Return

; Array of pointers to game messages.
@label=messages_table
wW$7DCD,2*20

; Game messages.
;
; Non-ASCII: encoded to match the font; $FF terminated.
@label=messages_missed_roll_call
tB$7DF5,17;92 "MISSED ROLL CALL" #HTML[/ #CALL:decode_stringFF($7DF5)]
@label=messages_time_to_wake_up
 B$7E06,16;92 "TIME TO WAKE UP" #HTML[/ #CALL:decode_stringFF($7E06)]
@label=messages_breakfast_time
 B$7E16,15;92 "BREAKFAST TIME" #HTML[/ #CALL:decode_stringFF($7E16)]
@label=messages_exercise_time
 B$7E25,14;92 "EXERCISE TIME" #HTML[/ #CALL:decode_stringFF($7E25)]
@label=messages_time_for_bed
 B$7E33,13;92 "TIME FOR BED" #HTML[/ #CALL:decode_stringFF($7E33)]
@label=messages_the_door_is_locked
 B$7E40,19;92 "THE DOOR IS LOCKED" #HTML[/ #CALL:decode_stringFF($7E40)]
@label=messages_it_is_open
 B$7E53,11;92 "IT IS OPEN" #HTML[/ #CALL:decode_stringFF($7E53)]
@label=messages_incorrect_key
 B$7E5E,14;92 "INCORRECT KEY" #HTML[/ #CALL:decode_stringFF($7E5E)]
@label=messages_roll_call
 B$7E6C,10;92 "ROLL CALL" #HTML[/ #CALL:decode_stringFF($7E6C)]
@label=messages_red_cross_parcel
 B$7E76,17;92 "RED CROSS PARCEL" #HTML[/ #CALL:decode_stringFF($7E76)]
@label=messages_picking_the_lock
 B$7E87,17;92 "PICKING THE LOCK" #HTML[/ #CALL:decode_stringFF($7E87)]
@label=messages_cutting_the_wire
 B$7E98,17;92 "CUTTING THE WIRE" #HTML[/ #CALL:decode_stringFF($7E98)]
@label=messages_you_open_the_box
 B$7EA9,17;92 "YOU OPEN THE BOX" #HTML[/ #CALL:decode_stringFF($7EA9)]
@label=messages_you_are_in_solitary
 B$7EBA,20;92 "YOU ARE IN SOLITARY" #HTML[/ #CALL:decode_stringFF($7EBA)]
@label=messages_wait_for_release
 B$7ECE,17;92 "WAIT FOR RELEASE" #HTML[/ #CALL:decode_stringFF($7ECE)]
@label=messages_morale_is_zero
 B$7EDF,15;92 "MORALE IS ZERO" #HTML[/ #CALL:decode_stringFF($7EDF)]
@label=messages_item_discovered
 B$7EEE,16;92 "ITEM DISCOVERED" #HTML[/ #CALL:decode_stringFF($7EEE)]

; Unreferenced bytes.
;
; Two alignment bytes to make static_tiles start at $7F00.
uB$7EFE,2

; Static tiles.
;
; These tiles are used to draw fixed screen elements such as medals.
; .
; 9 bytes each: 8x8 bitmap + 1 byte attribute. 75 tiles.
; .
; #UDGTABLE
; {
; #UDGARRAY75,6,1;$7F00,7;$7F09;$7F12;$7F1B;$7F24;$7F2D;$7F36;$7F3F;$7F48;$7F51;$7F5A;$7F63;$7F6C;$7F75;$7F7E;$7F87;$7F90;$7F99;$7FA2;$7FAB;$7FB4;$7FBD;$7FC6;$7FCF;$7FD8,7;$7FE1,7;$7FEA,7;$7FF3,7;$7FFC,4;$8005,4;$800E,4;$8017,4;$8020,3;$8029,7;$8032,3;$803B,3;$8044,3;$804D,3;$8056,3;$805F,3;$8068,3;$8071,3;$807A,3;$8083,3;$808C,7;$8095,3;$809E,3;$80A7,3;$80B0,3;$80B9,7;$80C2,7;$80CB;$80D4;$80DD;$80E6;$80EF,5;$80F8,5;$8101,4;$810A,4;$8113,4;$811C,7;$8125,7;$812E;$8137;$8140;$8149;$8152,5;$815B,5;$8164,5;$816D,4;$8176;$817F;$8188;$8191;$819A(static-tiles)
; }
; TABLE#
@label=static_tiles
bB$7F00,9;48 blank
 B$7F09,9;48 speaker_tl_tl
 B$7F12,9;48 speaker_tl_tr
 B$7F1B,9;48 speaker_tl_bl
 B$7F24,9;48 speaker_tl_br
 B$7F2D,9;48 speaker_tr_tl
 B$7F36,9;48 speaker_tr_tr
 B$7F3F,9;48 speaker_tr_bl
 B$7F48,9;48 speaker_tr_br
 B$7F51,9;48 speaker_br_tl
 B$7F5A,9;48 speaker_br_tr
 B$7F63,9;48 speaker_br_bl
 B$7F6C,9;48 speaker_br_br
 B$7F75,9;48 speaker_bl_tl
 B$7F7E,9;48 speaker_bl_tr
 B$7F87,9;48 speaker_bl_bl
 B$7F90,9;48 speaker_bl_br
 B$7F99,9;48 barbwire_v_top
 B$7FA2,9;48 barbwire_v_bottom
 B$7FAB,9;48 barbwire_h_left
 B$7FB4,9;48 barbwire_h_right
 B$7FBD,9;48 barbwire_h_wide_left
 B$7FC6,9;48 barbwire_h_wide_middle
 B$7FCF,9;48 barbwire_h_wide_right
 B$7FD8,9;48 flagpole_top
 B$7FE1,9;48 flagpole_middle
 B$7FEA,9;48 flagpole_bottom
 B$7FF3,9;48 flagpole_ground1
 B$7FFC,9;48 flagpole_ground2
 B$8005,9;48 flagpole_ground3
 B$800E,9;48 flagpole_ground4
 B$8017,9;48 flagpole_ground0
 B$8020,9;48 medal_0_0
 B$8029,9;48 medal_0_1/3/5/7/9
 B$8032,9;48 medal_0_2
 B$803B,9;48 medal_0_4
 B$8044,9;48 medal_0_6
 B$804D,9;48 medal_0_8
 B$8056,9;48 medal_1_0
 B$805F,9;48 medal_1_2
 B$8068,9;48 medal_1_4
 B$8071,9;48 medal_1_6
 B$807A,9;48 medal_1_8
 B$8083,9;48 medal_1_10
 B$808C,9;48 medal_2_0
 B$8095,9;48 medal_2_1/3/5/7/9
 B$809E,9;48 medal_2_2
 B$80A7,9;48 medal_2_4
 B$80B0,9;48 medal_2_6
 B$80B9,9;48 medal_2_8
 B$80C2,9;48 medal_2_10
 B$80CB,9;48 medal_3_0
 B$80D4,9;48 medal_3_1
 B$80DD,9;48 medal_3_2
 B$80E6,9;48 medal_3_3
 B$80EF,9;48 medal_3_4
 B$80F8,9;48 medal_3_5
 B$8101,9;48 medal_3_6
 B$810A,9;48 medal_3_7
 B$8113,9;48 medal_3_8
 B$811C,9;48 medal_3_9
 B$8125,9;48 medal_4_0
 B$812E,9;48 medal_4_1
 B$8137,9;48 medal_4_2
 B$8140,9;48 medal_4_3
 B$8149,9;48 medal_4_4
 B$8152,9;48 medal_4_5
 B$815B,9;48 medal_4_6
 B$8164,9;48 medal_4_7
 B$816D,9;48 medal_4_8
 B$8176,9;48 medal_4_9
 B$817F,9;48 bell_top_middle
 B$8188,9;48 bell_top_right
 B$8191,9;48 bell_middle_left
 B$819A,9;48 bell_middle_middle

; Unreferenced byte.
uB$81A3,1

; Saved/stashed position.
;
; Structure type: pos_t.
@label=saved_pos_x
@keep
gW$81A4,2
@label=saved_pos_y
 W$81A6,2
@label=saved_height
 W$81A8,2

; Used by touch() only.
@label=touch_stashed_A
gB$81AA,1

; Unreferenced byte.
uB$81AB,1

; Bitmap and mask pointers.
@label=bitmap_pointer
gW$81AC,2
@label=mask_pointer
 W$81AE,2
@label=foreground_mask_pointer
 W$81B0,2

; Saved/stashed position.
;
; Structure type: tinypos_t.
; .
; Written by setup_item_plotting, setup_vischar_plotting.
; .
; Read by render_mask_buffer, guards_follow_suspicious_character.
@label=tinypos_stash_x
gB$81B2,1
@label=tinypos_stash_y
 B$81B3,1
@label=tinypos_stash_height
 B$81B4,1

; Current vischar's isometric projected map position.
@label=iso_pos_x
gB$81B5,1
@label=iso_pos_y
 B$81B6,1

; Controls character left/right flipping.
@label=flip_sprite
gB$81B7,1

; Hero's map position.
;
; Structure type: tinypos_t.
@label=hero_map_position_x
gB$81B8,1
@label=hero_map_position_y
 B$81B9,1
@label=hero_map_position_height
 B$81BA,1

; Map position.
;
; Used when drawing tiles.
@label=map_position
gW$81BB,2

; Searchlight state.
;
; Suspect that this is a 'hero has been found in searchlight' flag. (possible
; states: 0, 31, 255)
; .
; Used by the routines at #R$ADBD, #R$B866.
; .
; #TABLE(default,centre)
; { =h Value | =h Meaning }
; { 0 | Searchlight is sweeping }
; { 31 | Searchlight is tracking the hero }
; { 255 | Searchlight is off }
; TABLE#
@label=searchlight_state
gB$81BD,1

; Copy of first byte of current room def.
;
; Indexes roomdef_dimensions[].
@label=roomdef_bounds_index
gB$81BE,1

; Count of object bounds.
@label=roomdef_object_bounds_count
gB$81BF,1

; Copy of current room def's additional bounds (allows for four room objects).
@label=roomdef_object_bounds
gB$81C0,4*4

; Unreferenced bytes.
;
; These are possibly spare object bounds bytes, but not ever used.
gB$81D0,6

; Indices of interior doors.
;
; Used by the routines at #R$69DC, #R$B32D, #R$B4D0.
@label=interior_doors
gB$81D6,4

; Interior mask data.
;
; Used by the routines at #R$6A35, #R$B916.
;
; FIXME: First byte is a count.
;
@label=interior_mask_data
gB$81DA,8*7,1

; Written to by #R$DC41 setup_item_plotting but never read.
@label=saved_item
gB$8213,1

; A copy of item_definition height.
;
; Used by the routines at #R$DC41, #R$DD02.
@label=item_height
gB$8214,1

; The items which the hero is holding.
;
; Each byte holds one item. Initialised to 0xFFFF meaning no item in either
; slot.
@label=items_held
gW$8215,2

; The current character index.
@label=character_index
gB$8217,1

; Tiles
;
; Exterior tiles set 0. 111 tiles.
@label=tiles
@label=mask_tiles
bB$8218,8;44 #HTML[#UDGARRAY1,7,4,1;$8218-$821F-8(exterior-tiles0-000)]
 B$8220,8;44 #HTML[#UDGARRAY1,7,4,1;$8220-$8227-8(exterior-tiles0-001)]
 B$8228,8;44 #HTML[#UDGARRAY1,7,4,1;$8228-$822F-8(exterior-tiles0-002)]
 B$8230,8;44 #HTML[#UDGARRAY1,7,4,1;$8230-$8237-8(exterior-tiles0-003)]
 B$8238,8;44 #HTML[#UDGARRAY1,7,4,1;$8238-$823F-8(exterior-tiles0-004)]
 B$8240,8;44 #HTML[#UDGARRAY1,7,4,1;$8240-$8247-8(exterior-tiles0-005)]
 B$8248,8;44 #HTML[#UDGARRAY1,7,4,1;$8248-$824F-8(exterior-tiles0-006)]
 B$8250,8;44 #HTML[#UDGARRAY1,7,4,1;$8250-$8257-8(exterior-tiles0-007)]
 B$8258,8;44 #HTML[#UDGARRAY1,7,4,1;$8258-$825F-8(exterior-tiles0-008)]
 B$8260,8;44 #HTML[#UDGARRAY1,7,4,1;$8260-$8267-8(exterior-tiles0-009)]
 B$8268,8;44 #HTML[#UDGARRAY1,7,4,1;$8268-$826F-8(exterior-tiles0-010)]
 B$8270,8;44 #HTML[#UDGARRAY1,7,4,1;$8270-$8277-8(exterior-tiles0-011)]
 B$8278,8;44 #HTML[#UDGARRAY1,7,4,1;$8278-$827F-8(exterior-tiles0-012)]
 B$8280,8;44 #HTML[#UDGARRAY1,7,4,1;$8280-$8287-8(exterior-tiles0-013)]
 B$8288,8;44 #HTML[#UDGARRAY1,7,4,1;$8288-$828F-8(exterior-tiles0-014)]
 B$8290,8;44 #HTML[#UDGARRAY1,7,4,1;$8290-$8297-8(exterior-tiles0-015)]
 B$8298,8;44 #HTML[#UDGARRAY1,7,4,1;$8298-$829F-8(exterior-tiles0-016)]
 B$82A0,8;44 #HTML[#UDGARRAY1,7,4,1;$82A0-$82A7-8(exterior-tiles0-017)]
 B$82A8,8;44 #HTML[#UDGARRAY1,7,4,1;$82A8-$82AF-8(exterior-tiles0-018)]
 B$82B0,8;44 #HTML[#UDGARRAY1,7,4,1;$82B0-$82B7-8(exterior-tiles0-019)]
 B$82B8,8;44 #HTML[#UDGARRAY1,7,4,1;$82B8-$82BF-8(exterior-tiles0-020)]
 B$82C0,8;44 #HTML[#UDGARRAY1,7,4,1;$82C0-$82C7-8(exterior-tiles0-021)]
 B$82C8,8;44 #HTML[#UDGARRAY1,7,4,1;$82C8-$82CF-8(exterior-tiles0-022)]
 B$82D0,8;44 #HTML[#UDGARRAY1,7,4,1;$82D0-$82D7-8(exterior-tiles0-023)]
 B$82D8,8;44 #HTML[#UDGARRAY1,7,4,1;$82D8-$82DF-8(exterior-tiles0-024)]
 B$82E0,8;44 #HTML[#UDGARRAY1,7,4,1;$82E0-$82E7-8(exterior-tiles0-025)]
 B$82E8,8;44 #HTML[#UDGARRAY1,7,4,1;$82E8-$82EF-8(exterior-tiles0-026)]
 B$82F0,8;44 #HTML[#UDGARRAY1,7,4,1;$82F0-$82F7-8(exterior-tiles0-027)]
 B$82F8,8;44 #HTML[#UDGARRAY1,7,4,1;$82F8-$82FF-8(exterior-tiles0-028)]
 B$8300,8;44 #HTML[#UDGARRAY1,7,4,1;$8300-$8307-8(exterior-tiles0-029)]
 B$8308,8;44 #HTML[#UDGARRAY1,7,4,1;$8308-$830F-8(exterior-tiles0-030)]
 B$8310,8;44 #HTML[#UDGARRAY1,7,4,1;$8310-$8317-8(exterior-tiles0-031)]
 B$8318,8;44 #HTML[#UDGARRAY1,7,4,1;$8318-$831F-8(exterior-tiles0-032)]
 B$8320,8;44 #HTML[#UDGARRAY1,7,4,1;$8320-$8327-8(exterior-tiles0-033)]
 B$8328,8;44 #HTML[#UDGARRAY1,7,4,1;$8328-$832F-8(exterior-tiles0-034)]
 B$8330,8;44 #HTML[#UDGARRAY1,7,4,1;$8330-$8337-8(exterior-tiles0-035)]
 B$8338,8;44 #HTML[#UDGARRAY1,7,4,1;$8338-$833F-8(exterior-tiles0-036)]
 B$8340,8;44 #HTML[#UDGARRAY1,7,4,1;$8340-$8347-8(exterior-tiles0-037)]
 B$8348,8;44 #HTML[#UDGARRAY1,7,4,1;$8348-$834F-8(exterior-tiles0-038)]
 B$8350,8;44 #HTML[#UDGARRAY1,7,4,1;$8350-$8357-8(exterior-tiles0-039)]
 B$8358,8;44 #HTML[#UDGARRAY1,7,4,1;$8358-$835F-8(exterior-tiles0-040)]
 B$8360,8;44 #HTML[#UDGARRAY1,7,4,1;$8360-$8367-8(exterior-tiles0-041)]
 B$8368,8;44 #HTML[#UDGARRAY1,7,4,1;$8368-$836F-8(exterior-tiles0-042)]
 B$8370,8;44 #HTML[#UDGARRAY1,7,4,1;$8370-$8377-8(exterior-tiles0-043)]
 B$8378,8;44 #HTML[#UDGARRAY1,7,4,1;$8378-$837F-8(exterior-tiles0-044)]
 B$8380,8;44 #HTML[#UDGARRAY1,7,4,1;$8380-$8387-8(exterior-tiles0-045)]
 B$8388,8;44 #HTML[#UDGARRAY1,7,4,1;$8388-$838F-8(exterior-tiles0-046)]
 B$8390,8;44 #HTML[#UDGARRAY1,7,4,1;$8390-$8397-8(exterior-tiles0-047)]
 B$8398,8;44 #HTML[#UDGARRAY1,7,4,1;$8398-$839F-8(exterior-tiles0-048)]
 B$83A0,8;44 #HTML[#UDGARRAY1,7,4,1;$83A0-$83A7-8(exterior-tiles0-049)]
 B$83A8,8;44 #HTML[#UDGARRAY1,7,4,1;$83A8-$83AF-8(exterior-tiles0-050)]
 B$83B0,8;44 #HTML[#UDGARRAY1,7,4,1;$83B0-$83B7-8(exterior-tiles0-051)]
 B$83B8,8;44 #HTML[#UDGARRAY1,7,4,1;$83B8-$83BF-8(exterior-tiles0-052)]
 B$83C0,8;44 #HTML[#UDGARRAY1,7,4,1;$83C0-$83C7-8(exterior-tiles0-053)]
 B$83C8,8;44 #HTML[#UDGARRAY1,7,4,1;$83C8-$83CF-8(exterior-tiles0-054)]
 B$83D0,8;44 #HTML[#UDGARRAY1,7,4,1;$83D0-$83D7-8(exterior-tiles0-055)]
 B$83D8,8;44 #HTML[#UDGARRAY1,7,4,1;$83D8-$83DF-8(exterior-tiles0-056)]
 B$83E0,8;44 #HTML[#UDGARRAY1,7,4,1;$83E0-$83E7-8(exterior-tiles0-057)]
 B$83E8,8;44 #HTML[#UDGARRAY1,7,4,1;$83E8-$83EF-8(exterior-tiles0-058)]
 B$83F0,8;44 #HTML[#UDGARRAY1,7,4,1;$83F0-$83F7-8(exterior-tiles0-059)]
 B$83F8,8;44 #HTML[#UDGARRAY1,7,4,1;$83F8-$83FF-8(exterior-tiles0-060)]
 B$8400,8;44 #HTML[#UDGARRAY1,7,4,1;$8400-$8407-8(exterior-tiles0-061)]
 B$8408,8;44 #HTML[#UDGARRAY1,7,4,1;$8408-$840F-8(exterior-tiles0-062)]
 B$8410,8;44 #HTML[#UDGARRAY1,7,4,1;$8410-$8417-8(exterior-tiles0-063)]
 B$8418,8;44 #HTML[#UDGARRAY1,7,4,1;$8418-$841F-8(exterior-tiles0-064)]
 B$8420,8;44 #HTML[#UDGARRAY1,7,4,1;$8420-$8427-8(exterior-tiles0-065)]
 B$8428,8;44 #HTML[#UDGARRAY1,7,4,1;$8428-$842F-8(exterior-tiles0-066)]
 B$8430,8;44 #HTML[#UDGARRAY1,7,4,1;$8430-$8437-8(exterior-tiles0-067)]
 B$8438,8;44 #HTML[#UDGARRAY1,7,4,1;$8438-$843F-8(exterior-tiles0-068)]
 B$8440,8;44 #HTML[#UDGARRAY1,7,4,1;$8440-$8447-8(exterior-tiles0-069)]
 B$8448,8;44 #HTML[#UDGARRAY1,7,4,1;$8448-$844F-8(exterior-tiles0-070)]
 B$8450,8;44 #HTML[#UDGARRAY1,7,4,1;$8450-$8457-8(exterior-tiles0-071)]
 B$8458,8;44 #HTML[#UDGARRAY1,7,4,1;$8458-$845F-8(exterior-tiles0-072)]
 B$8460,8;44 #HTML[#UDGARRAY1,7,4,1;$8460-$8467-8(exterior-tiles0-073)]
 B$8468,8;44 #HTML[#UDGARRAY1,7,4,1;$8468-$846F-8(exterior-tiles0-074)]
 B$8470,8;44 #HTML[#UDGARRAY1,7,4,1;$8470-$8477-8(exterior-tiles0-075)]
 B$8478,8;44 #HTML[#UDGARRAY1,7,4,1;$8478-$847F-8(exterior-tiles0-076)]
 B$8480,8;44 #HTML[#UDGARRAY1,7,4,1;$8480-$8487-8(exterior-tiles0-077)]
 B$8488,8;44 #HTML[#UDGARRAY1,7,4,1;$8488-$848F-8(exterior-tiles0-078)]
 B$8490,8;44 #HTML[#UDGARRAY1,7,4,1;$8490-$8497-8(exterior-tiles0-079)]
 B$8498,8;44 #HTML[#UDGARRAY1,7,4,1;$8498-$849F-8(exterior-tiles0-080)]
 B$84A0,8;44 #HTML[#UDGARRAY1,7,4,1;$84A0-$84A7-8(exterior-tiles0-081)]
 B$84A8,8;44 #HTML[#UDGARRAY1,7,4,1;$84A8-$84AF-8(exterior-tiles0-082)]
 B$84B0,8;44 #HTML[#UDGARRAY1,7,4,1;$84B0-$84B7-8(exterior-tiles0-083)]
 B$84B8,8;44 #HTML[#UDGARRAY1,7,4,1;$84B8-$84BF-8(exterior-tiles0-084)]
 B$84C0,8;44 #HTML[#UDGARRAY1,7,4,1;$84C0-$84C7-8(exterior-tiles0-085)]
 B$84C8,8;44 #HTML[#UDGARRAY1,7,4,1;$84C8-$84CF-8(exterior-tiles0-086)]
 B$84D0,8;44 #HTML[#UDGARRAY1,7,4,1;$84D0-$84D7-8(exterior-tiles0-087)]
 B$84D8,8;44 #HTML[#UDGARRAY1,7,4,1;$84D8-$84DF-8(exterior-tiles0-088)]
 B$84E0,8;44 #HTML[#UDGARRAY1,7,4,1;$84E0-$84E7-8(exterior-tiles0-089)]
 B$84E8,8;44 #HTML[#UDGARRAY1,7,4,1;$84E8-$84EF-8(exterior-tiles0-090)]
 B$84F0,8;44 #HTML[#UDGARRAY1,7,4,1;$84F0-$84F7-8(exterior-tiles0-091)]
 B$84F8,8;44 #HTML[#UDGARRAY1,7,4,1;$84F8-$84FF-8(exterior-tiles0-092)]
 B$8500,8;44 #HTML[#UDGARRAY1,7,4,1;$8500-$8507-8(exterior-tiles0-093)]
 B$8508,8;44 #HTML[#UDGARRAY1,7,4,1;$8508-$850F-8(exterior-tiles0-094)]
 B$8510,8;44 #HTML[#UDGARRAY1,7,4,1;$8510-$8517-8(exterior-tiles0-095)]
 B$8518,8;44 #HTML[#UDGARRAY1,7,4,1;$8518-$851F-8(exterior-tiles0-096)]
 B$8520,8;44 #HTML[#UDGARRAY1,7,4,1;$8520-$8527-8(exterior-tiles0-097)]
 B$8528,8;44 #HTML[#UDGARRAY1,7,4,1;$8528-$852F-8(exterior-tiles0-098)]
 B$8530,8;44 #HTML[#UDGARRAY1,7,4,1;$8530-$8537-8(exterior-tiles0-099)]
 B$8538,8;44 #HTML[#UDGARRAY1,7,4,1;$8538-$853F-8(exterior-tiles0-100)]
 B$8540,8;44 #HTML[#UDGARRAY1,7,4,1;$8540-$8547-8(exterior-tiles0-101)]
 B$8548,8;44 #HTML[#UDGARRAY1,7,4,1;$8548-$854F-8(exterior-tiles0-102)]
 B$8550,8;44 #HTML[#UDGARRAY1,7,4,1;$8550-$8557-8(exterior-tiles0-103)]
 B$8558,8;44 #HTML[#UDGARRAY1,7,4,1;$8558-$855F-8(exterior-tiles0-104)]
 B$8560,8;44 #HTML[#UDGARRAY1,7,4,1;$8560-$8567-8(exterior-tiles0-105)]
 B$8568,8;44 #HTML[#UDGARRAY1,7,4,1;$8568-$856F-8(exterior-tiles0-106)]
 B$8570,8;44 #HTML[#UDGARRAY1,7,4,1;$8570-$8577-8(exterior-tiles0-107)]
 B$8578,8;44 #HTML[#UDGARRAY1,7,4,1;$8578-$857F-8(exterior-tiles0-108)]
 B$8580,8;44 #HTML[#UDGARRAY1,7,4,1;$8580-$8587-8(exterior-tiles0-109)]
 B$8588,8;44 #HTML[#UDGARRAY1,7,4,1;$8588-$858F-8(exterior-tiles0-110)]
; Exterior tiles. 145 + 220 + 206 tiles. (<- plot_tile)
@label=exterior_tiles
 B$8590,8;44 #HTML[#UDGARRAY1,7,4,1;$8590-$8597-8(exterior-tiles1-000)]
 B$8598,8;44 #HTML[#UDGARRAY1,7,4,1;$8598-$859F-8(exterior-tiles1-001)]
 B$85A0,8;44 #HTML[#UDGARRAY1,7,4,1;$85A0-$85A7-8(exterior-tiles1-002)]
 B$85A8,8;44 #HTML[#UDGARRAY1,7,4,1;$85A8-$85AF-8(exterior-tiles1-003)]
 B$85B0,8;44 #HTML[#UDGARRAY1,7,4,1;$85B0-$85B7-8(exterior-tiles1-004)]
 B$85B8,8;44 #HTML[#UDGARRAY1,7,4,1;$85B8-$85BF-8(exterior-tiles1-005)]
 B$85C0,8;44 #HTML[#UDGARRAY1,7,4,1;$85C0-$85C7-8(exterior-tiles1-006)]
 B$85C8,8;44 #HTML[#UDGARRAY1,7,4,1;$85C8-$85CF-8(exterior-tiles1-007)]
 B$85D0,8;44 #HTML[#UDGARRAY1,7,4,1;$85D0-$85D7-8(exterior-tiles1-008)]
 B$85D8,8;44 #HTML[#UDGARRAY1,7,4,1;$85D8-$85DF-8(exterior-tiles1-009)]
 B$85E0,8;44 #HTML[#UDGARRAY1,7,4,1;$85E0-$85E7-8(exterior-tiles1-010)]
 B$85E8,8;44 #HTML[#UDGARRAY1,7,4,1;$85E8-$85EF-8(exterior-tiles1-011)]
 B$85F0,8;44 #HTML[#UDGARRAY1,7,4,1;$85F0-$85F7-8(exterior-tiles1-012)]
 B$85F8,8;44 #HTML[#UDGARRAY1,7,4,1;$85F8-$85FF-8(exterior-tiles1-013)]
 B$8600,8;44 #HTML[#UDGARRAY1,7,4,1;$8600-$8607-8(exterior-tiles1-014)]
 B$8608,8;44 #HTML[#UDGARRAY1,7,4,1;$8608-$860F-8(exterior-tiles1-015)]
 B$8610,8;44 #HTML[#UDGARRAY1,7,4,1;$8610-$8617-8(exterior-tiles1-016)]
 B$8618,8;44 #HTML[#UDGARRAY1,7,4,1;$8618-$861F-8(exterior-tiles1-017)]
 B$8620,8;44 #HTML[#UDGARRAY1,7,4,1;$8620-$8627-8(exterior-tiles1-018)]
 B$8628,8;44 #HTML[#UDGARRAY1,7,4,1;$8628-$862F-8(exterior-tiles1-019)]
 B$8630,8;44 #HTML[#UDGARRAY1,7,4,1;$8630-$8637-8(exterior-tiles1-020)]
 B$8638,8;44 #HTML[#UDGARRAY1,7,4,1;$8638-$863F-8(exterior-tiles1-021)]
 B$8640,8;44 #HTML[#UDGARRAY1,7,4,1;$8640-$8647-8(exterior-tiles1-022)]
 B$8648,8;44 #HTML[#UDGARRAY1,7,4,1;$8648-$864F-8(exterior-tiles1-023)]
 B$8650,8;44 #HTML[#UDGARRAY1,7,4,1;$8650-$8657-8(exterior-tiles1-024)]
 B$8658,8;44 #HTML[#UDGARRAY1,7,4,1;$8658-$865F-8(exterior-tiles1-025)]
 B$8660,8;44 #HTML[#UDGARRAY1,7,4,1;$8660-$8667-8(exterior-tiles1-026)]
 B$8668,8;44 #HTML[#UDGARRAY1,7,4,1;$8668-$866F-8(exterior-tiles1-027)]
 B$8670,8;44 #HTML[#UDGARRAY1,7,4,1;$8670-$8677-8(exterior-tiles1-028)]
 B$8678,8;44 #HTML[#UDGARRAY1,7,4,1;$8678-$867F-8(exterior-tiles1-029)]
 B$8680,8;44 #HTML[#UDGARRAY1,7,4,1;$8680-$8687-8(exterior-tiles1-030)]
 B$8688,8;44 #HTML[#UDGARRAY1,7,4,1;$8688-$868F-8(exterior-tiles1-031)]
 B$8690,8;44 #HTML[#UDGARRAY1,7,4,1;$8690-$8697-8(exterior-tiles1-032)]
 B$8698,8;44 #HTML[#UDGARRAY1,7,4,1;$8698-$869F-8(exterior-tiles1-033)]
 B$86A0,8;44 #HTML[#UDGARRAY1,7,4,1;$86A0-$86A7-8(exterior-tiles1-034)]
 B$86A8,8;44 #HTML[#UDGARRAY1,7,4,1;$86A8-$86AF-8(exterior-tiles1-035)]
 B$86B0,8;44 #HTML[#UDGARRAY1,7,4,1;$86B0-$86B7-8(exterior-tiles1-036)]
 B$86B8,8;44 #HTML[#UDGARRAY1,7,4,1;$86B8-$86BF-8(exterior-tiles1-037)]
 B$86C0,8;44 #HTML[#UDGARRAY1,7,4,1;$86C0-$86C7-8(exterior-tiles1-038)]
 B$86C8,8;44 #HTML[#UDGARRAY1,7,4,1;$86C8-$86CF-8(exterior-tiles1-039)]
 B$86D0,8;44 #HTML[#UDGARRAY1,7,4,1;$86D0-$86D7-8(exterior-tiles1-040)]
 B$86D8,8;44 #HTML[#UDGARRAY1,7,4,1;$86D8-$86DF-8(exterior-tiles1-041)]
 B$86E0,8;44 #HTML[#UDGARRAY1,7,4,1;$86E0-$86E7-8(exterior-tiles1-042)]
 B$86E8,8;44 #HTML[#UDGARRAY1,7,4,1;$86E8-$86EF-8(exterior-tiles1-043)]
 B$86F0,8;44 #HTML[#UDGARRAY1,7,4,1;$86F0-$86F7-8(exterior-tiles1-044)]
 B$86F8,8;44 #HTML[#UDGARRAY1,7,4,1;$86F8-$86FF-8(exterior-tiles1-045)]
 B$8700,8;44 #HTML[#UDGARRAY1,7,4,1;$8700-$8707-8(exterior-tiles1-046)]
 B$8708,8;44 #HTML[#UDGARRAY1,7,4,1;$8708-$870F-8(exterior-tiles1-047)]
 B$8710,8;44 #HTML[#UDGARRAY1,7,4,1;$8710-$8717-8(exterior-tiles1-048)]
 B$8718,8;44 #HTML[#UDGARRAY1,7,4,1;$8718-$871F-8(exterior-tiles1-049)]
 B$8720,8;44 #HTML[#UDGARRAY1,7,4,1;$8720-$8727-8(exterior-tiles1-050)]
 B$8728,8;44 #HTML[#UDGARRAY1,7,4,1;$8728-$872F-8(exterior-tiles1-051)]
 B$8730,8;44 #HTML[#UDGARRAY1,7,4,1;$8730-$8737-8(exterior-tiles1-052)]
 B$8738,8;44 #HTML[#UDGARRAY1,7,4,1;$8738-$873F-8(exterior-tiles1-053)]
 B$8740,8;44 #HTML[#UDGARRAY1,7,4,1;$8740-$8747-8(exterior-tiles1-054)]
 B$8748,8;44 #HTML[#UDGARRAY1,7,4,1;$8748-$874F-8(exterior-tiles1-055)]
 B$8750,8;44 #HTML[#UDGARRAY1,7,4,1;$8750-$8757-8(exterior-tiles1-056)]
 B$8758,8;44 #HTML[#UDGARRAY1,7,4,1;$8758-$875F-8(exterior-tiles1-057)]
 B$8760,8;44 #HTML[#UDGARRAY1,7,4,1;$8760-$8767-8(exterior-tiles1-058)]
 B$8768,8;44 #HTML[#UDGARRAY1,7,4,1;$8768-$876F-8(exterior-tiles1-059)]
 B$8770,8;44 #HTML[#UDGARRAY1,7,4,1;$8770-$8777-8(exterior-tiles1-060)]
 B$8778,8;44 #HTML[#UDGARRAY1,7,4,1;$8778-$877F-8(exterior-tiles1-061)]
 B$8780,8;44 #HTML[#UDGARRAY1,7,4,1;$8780-$8787-8(exterior-tiles1-062)]
 B$8788,8;44 #HTML[#UDGARRAY1,7,4,1;$8788-$878F-8(exterior-tiles1-063)]
 B$8790,8;44 #HTML[#UDGARRAY1,7,4,1;$8790-$8797-8(exterior-tiles1-064)]
 B$8798,8;44 #HTML[#UDGARRAY1,7,4,1;$8798-$879F-8(exterior-tiles1-065)]
 B$87A0,8;44 #HTML[#UDGARRAY1,7,4,1;$87A0-$87A7-8(exterior-tiles1-066)]
 B$87A8,8;44 #HTML[#UDGARRAY1,7,4,1;$87A8-$87AF-8(exterior-tiles1-067)]
 B$87B0,8;44 #HTML[#UDGARRAY1,7,4,1;$87B0-$87B7-8(exterior-tiles1-068)]
 B$87B8,8;44 #HTML[#UDGARRAY1,7,4,1;$87B8-$87BF-8(exterior-tiles1-069)]
 B$87C0,8;44 #HTML[#UDGARRAY1,7,4,1;$87C0-$87C7-8(exterior-tiles1-070)]
 B$87C8,8;44 #HTML[#UDGARRAY1,7,4,1;$87C8-$87CF-8(exterior-tiles1-071)]
 B$87D0,8;44 #HTML[#UDGARRAY1,7,4,1;$87D0-$87D7-8(exterior-tiles1-072)]
 B$87D8,8;44 #HTML[#UDGARRAY1,7,4,1;$87D8-$87DF-8(exterior-tiles1-073)]
 B$87E0,8;44 #HTML[#UDGARRAY1,7,4,1;$87E0-$87E7-8(exterior-tiles1-074)]
 B$87E8,8;44 #HTML[#UDGARRAY1,7,4,1;$87E8-$87EF-8(exterior-tiles1-075)]
 B$87F0,8;44 #HTML[#UDGARRAY1,7,4,1;$87F0-$87F7-8(exterior-tiles1-076)]
 B$87F8,8;44 #HTML[#UDGARRAY1,7,4,1;$87F8-$87FF-8(exterior-tiles1-077)]
 B$8800,8;44 #HTML[#UDGARRAY1,7,4,1;$8800-$8807-8(exterior-tiles1-078)]
 B$8808,8;44 #HTML[#UDGARRAY1,7,4,1;$8808-$880F-8(exterior-tiles1-079)]
 B$8810,8;44 #HTML[#UDGARRAY1,7,4,1;$8810-$8817-8(exterior-tiles1-080)]
 B$8818,8;44 #HTML[#UDGARRAY1,7,4,1;$8818-$881F-8(exterior-tiles1-081)]
 B$8820,8;44 #HTML[#UDGARRAY1,7,4,1;$8820-$8827-8(exterior-tiles1-082)]
 B$8828,8;44 #HTML[#UDGARRAY1,7,4,1;$8828-$882F-8(exterior-tiles1-083)]
 B$8830,8;44 #HTML[#UDGARRAY1,7,4,1;$8830-$8837-8(exterior-tiles1-084)]
 B$8838,8;44 #HTML[#UDGARRAY1,7,4,1;$8838-$883F-8(exterior-tiles1-085)]
 B$8840,8;44 #HTML[#UDGARRAY1,7,4,1;$8840-$8847-8(exterior-tiles1-086)]
 B$8848,8;44 #HTML[#UDGARRAY1,7,4,1;$8848-$884F-8(exterior-tiles1-087)]
 B$8850,8;44 #HTML[#UDGARRAY1,7,4,1;$8850-$8857-8(exterior-tiles1-088)]
 B$8858,8;44 #HTML[#UDGARRAY1,7,4,1;$8858-$885F-8(exterior-tiles1-089)]
 B$8860,8;44 #HTML[#UDGARRAY1,7,4,1;$8860-$8867-8(exterior-tiles1-090)]
 B$8868,8;44 #HTML[#UDGARRAY1,7,4,1;$8868-$886F-8(exterior-tiles1-091)]
 B$8870,8;44 #HTML[#UDGARRAY1,7,4,1;$8870-$8877-8(exterior-tiles1-092)]
 B$8878,8;44 #HTML[#UDGARRAY1,7,4,1;$8878-$887F-8(exterior-tiles1-093)]
 B$8880,8;44 #HTML[#UDGARRAY1,7,4,1;$8880-$8887-8(exterior-tiles1-094)]
 B$8888,8;44 #HTML[#UDGARRAY1,7,4,1;$8888-$888F-8(exterior-tiles1-095)]
 B$8890,8;44 #HTML[#UDGARRAY1,7,4,1;$8890-$8897-8(exterior-tiles1-096)]
 B$8898,8;44 #HTML[#UDGARRAY1,7,4,1;$8898-$889F-8(exterior-tiles1-097)]
 B$88A0,8;44 #HTML[#UDGARRAY1,7,4,1;$88A0-$88A7-8(exterior-tiles1-098)]
 B$88A8,8;44 #HTML[#UDGARRAY1,7,4,1;$88A8-$88AF-8(exterior-tiles1-099)]
 B$88B0,8;44 #HTML[#UDGARRAY1,7,4,1;$88B0-$88B7-8(exterior-tiles1-100)]
 B$88B8,8;44 #HTML[#UDGARRAY1,7,4,1;$88B8-$88BF-8(exterior-tiles1-101)]
 B$88C0,8;44 #HTML[#UDGARRAY1,7,4,1;$88C0-$88C7-8(exterior-tiles1-102)]
 B$88C8,8;44 #HTML[#UDGARRAY1,7,4,1;$88C8-$88CF-8(exterior-tiles1-103)]
 B$88D0,8;44 #HTML[#UDGARRAY1,7,4,1;$88D0-$88D7-8(exterior-tiles1-104)]
 B$88D8,8;44 #HTML[#UDGARRAY1,7,4,1;$88D8-$88DF-8(exterior-tiles1-105)]
 B$88E0,8;44 #HTML[#UDGARRAY1,7,4,1;$88E0-$88E7-8(exterior-tiles1-106)]
 B$88E8,8;44 #HTML[#UDGARRAY1,7,4,1;$88E8-$88EF-8(exterior-tiles1-107)]
 B$88F0,8;44 #HTML[#UDGARRAY1,7,4,1;$88F0-$88F7-8(exterior-tiles1-108)]
 B$88F8,8;44 #HTML[#UDGARRAY1,7,4,1;$88F8-$88FF-8(exterior-tiles1-109)]
 B$8900,8;44 #HTML[#UDGARRAY1,7,4,1;$8900-$8907-8(exterior-tiles1-110)]
 B$8908,8;44 #HTML[#UDGARRAY1,7,4,1;$8908-$890F-8(exterior-tiles1-111)]
 B$8910,8;44 #HTML[#UDGARRAY1,7,4,1;$8910-$8917-8(exterior-tiles1-112)]
 B$8918,8;44 #HTML[#UDGARRAY1,7,4,1;$8918-$891F-8(exterior-tiles1-113)]
 B$8920,8;44 #HTML[#UDGARRAY1,7,4,1;$8920-$8927-8(exterior-tiles1-114)]
 B$8928,8;44 #HTML[#UDGARRAY1,7,4,1;$8928-$892F-8(exterior-tiles1-115)]
 B$8930,8;44 #HTML[#UDGARRAY1,7,4,1;$8930-$8937-8(exterior-tiles1-116)]
 B$8938,8;44 #HTML[#UDGARRAY1,7,4,1;$8938-$893F-8(exterior-tiles1-117)]
 B$8940,8;44 #HTML[#UDGARRAY1,7,4,1;$8940-$8947-8(exterior-tiles1-118)]
 B$8948,8;44 #HTML[#UDGARRAY1,7,4,1;$8948-$894F-8(exterior-tiles1-119)]
 B$8950,8;44 #HTML[#UDGARRAY1,7,4,1;$8950-$8957-8(exterior-tiles1-120)]
 B$8958,8;44 #HTML[#UDGARRAY1,7,4,1;$8958-$895F-8(exterior-tiles1-121)]
 B$8960,8;44 #HTML[#UDGARRAY1,7,4,1;$8960-$8967-8(exterior-tiles1-122)]
 B$8968,8;44 #HTML[#UDGARRAY1,7,4,1;$8968-$896F-8(exterior-tiles1-123)]
 B$8970,8;44 #HTML[#UDGARRAY1,7,4,1;$8970-$8977-8(exterior-tiles1-124)]
 B$8978,8;44 #HTML[#UDGARRAY1,7,4,1;$8978-$897F-8(exterior-tiles1-125)]
 B$8980,8;44 #HTML[#UDGARRAY1,7,4,1;$8980-$8987-8(exterior-tiles1-126)]
 B$8988,8;44 #HTML[#UDGARRAY1,7,4,1;$8988-$898F-8(exterior-tiles1-127)]
 B$8990,8;44 #HTML[#UDGARRAY1,7,4,1;$8990-$8997-8(exterior-tiles1-128)]
 B$8998,8;44 #HTML[#UDGARRAY1,7,4,1;$8998-$899F-8(exterior-tiles1-129)]
 B$89A0,8;44 #HTML[#UDGARRAY1,7,4,1;$89A0-$89A7-8(exterior-tiles1-130)]
 B$89A8,8;44 #HTML[#UDGARRAY1,7,4,1;$89A8-$89AF-8(exterior-tiles1-131)]
 B$89B0,8;44 #HTML[#UDGARRAY1,7,4,1;$89B0-$89B7-8(exterior-tiles1-132)]
 B$89B8,8;44 #HTML[#UDGARRAY1,7,4,1;$89B8-$89BF-8(exterior-tiles1-133)]
 B$89C0,8;44 #HTML[#UDGARRAY1,7,4,1;$89C0-$89C7-8(exterior-tiles1-134)]
 B$89C8,8;44 #HTML[#UDGARRAY1,7,4,1;$89C8-$89CF-8(exterior-tiles1-135)]
 B$89D0,8;44 #HTML[#UDGARRAY1,7,4,1;$89D0-$89D7-8(exterior-tiles1-136)]
 B$89D8,8;44 #HTML[#UDGARRAY1,7,4,1;$89D8-$89DF-8(exterior-tiles1-137)]
 B$89E0,8;44 #HTML[#UDGARRAY1,7,4,1;$89E0-$89E7-8(exterior-tiles1-138)]
 B$89E8,8;44 #HTML[#UDGARRAY1,7,4,1;$89E8-$89EF-8(exterior-tiles1-139)]
 B$89F0,8;44 #HTML[#UDGARRAY1,7,4,1;$89F0-$89F7-8(exterior-tiles1-140)]
 B$89F8,8;44 #HTML[#UDGARRAY1,7,4,1;$89F8-$89FF-8(exterior-tiles1-141)]
 B$8A00,8;44 #HTML[#UDGARRAY1,7,4,1;$8A00-$8A07-8(exterior-tiles1-142)]
 B$8A08,8;44 #HTML[#UDGARRAY1,7,4,1;$8A08-$8A0F-8(exterior-tiles1-143)]
 B$8A10,8;44 #HTML[#UDGARRAY1,7,4,1;$8A10-$8A17-8(exterior-tiles1-144)]
 B$8A18,8;44 #HTML[#UDGARRAY1,7,4,1;$8A18-$8A1F-8(exterior-tiles2-000)]
 B$8A20,8;44 #HTML[#UDGARRAY1,7,4,1;$8A20-$8A27-8(exterior-tiles2-001)]
 B$8A28,8;44 #HTML[#UDGARRAY1,7,4,1;$8A28-$8A2F-8(exterior-tiles2-002)]
 B$8A30,8;44 #HTML[#UDGARRAY1,7,4,1;$8A30-$8A37-8(exterior-tiles2-003)]
 B$8A38,8;44 #HTML[#UDGARRAY1,7,4,1;$8A38-$8A3F-8(exterior-tiles2-004)]
 B$8A40,8;44 #HTML[#UDGARRAY1,7,4,1;$8A40-$8A47-8(exterior-tiles2-005)]
 B$8A48,8;44 #HTML[#UDGARRAY1,7,4,1;$8A48-$8A4F-8(exterior-tiles2-006)]
 B$8A50,8;44 #HTML[#UDGARRAY1,7,4,1;$8A50-$8A57-8(exterior-tiles2-007)]
 B$8A58,8;44 #HTML[#UDGARRAY1,7,4,1;$8A58-$8A5F-8(exterior-tiles2-008)]
 B$8A60,8;44 #HTML[#UDGARRAY1,7,4,1;$8A60-$8A67-8(exterior-tiles2-009)]
 B$8A68,8;44 #HTML[#UDGARRAY1,7,4,1;$8A68-$8A6F-8(exterior-tiles2-010)]
 B$8A70,8;44 #HTML[#UDGARRAY1,7,4,1;$8A70-$8A77-8(exterior-tiles2-011)]
 B$8A78,8;44 #HTML[#UDGARRAY1,7,4,1;$8A78-$8A7F-8(exterior-tiles2-012)]
 B$8A80,8;44 #HTML[#UDGARRAY1,7,4,1;$8A80-$8A87-8(exterior-tiles2-013)]
 B$8A88,8;44 #HTML[#UDGARRAY1,7,4,1;$8A88-$8A8F-8(exterior-tiles2-014)]
 B$8A90,8;44 #HTML[#UDGARRAY1,7,4,1;$8A90-$8A97-8(exterior-tiles2-015)]
 B$8A98,8;44 #HTML[#UDGARRAY1,7,4,1;$8A98-$8A9F-8(exterior-tiles2-016)]
 B$8AA0,8;44 #HTML[#UDGARRAY1,7,4,1;$8AA0-$8AA7-8(exterior-tiles2-017)]
 B$8AA8,8;44 #HTML[#UDGARRAY1,7,4,1;$8AA8-$8AAF-8(exterior-tiles2-018)]
 B$8AB0,8;44 #HTML[#UDGARRAY1,7,4,1;$8AB0-$8AB7-8(exterior-tiles2-019)]
 B$8AB8,8;44 #HTML[#UDGARRAY1,7,4,1;$8AB8-$8ABF-8(exterior-tiles2-020)]
 B$8AC0,8;44 #HTML[#UDGARRAY1,7,4,1;$8AC0-$8AC7-8(exterior-tiles2-021)]
 B$8AC8,8;44 #HTML[#UDGARRAY1,7,4,1;$8AC8-$8ACF-8(exterior-tiles2-022)]
 B$8AD0,8;44 #HTML[#UDGARRAY1,7,4,1;$8AD0-$8AD7-8(exterior-tiles2-023)]
 B$8AD8,8;44 #HTML[#UDGARRAY1,7,4,1;$8AD8-$8ADF-8(exterior-tiles2-024)]
 B$8AE0,8;44 #HTML[#UDGARRAY1,7,4,1;$8AE0-$8AE7-8(exterior-tiles2-025)]
 B$8AE8,8;44 #HTML[#UDGARRAY1,7,4,1;$8AE8-$8AEF-8(exterior-tiles2-026)]
 B$8AF0,8;44 #HTML[#UDGARRAY1,7,4,1;$8AF0-$8AF7-8(exterior-tiles2-027)]
 B$8AF8,8;44 #HTML[#UDGARRAY1,7,4,1;$8AF8-$8AFF-8(exterior-tiles2-028)]
 B$8B00,8;44 #HTML[#UDGARRAY1,7,4,1;$8B00-$8B07-8(exterior-tiles2-029)]
 B$8B08,8;44 #HTML[#UDGARRAY1,7,4,1;$8B08-$8B0F-8(exterior-tiles2-030)]
 B$8B10,8;44 #HTML[#UDGARRAY1,7,4,1;$8B10-$8B17-8(exterior-tiles2-031)]
 B$8B18,8;44 #HTML[#UDGARRAY1,7,4,1;$8B18-$8B1F-8(exterior-tiles2-032)]
 B$8B20,8;44 #HTML[#UDGARRAY1,7,4,1;$8B20-$8B27-8(exterior-tiles2-033)]
 B$8B28,8;44 #HTML[#UDGARRAY1,7,4,1;$8B28-$8B2F-8(exterior-tiles2-034)]
 B$8B30,8;44 #HTML[#UDGARRAY1,7,4,1;$8B30-$8B37-8(exterior-tiles2-035)]
 B$8B38,8;44 #HTML[#UDGARRAY1,7,4,1;$8B38-$8B3F-8(exterior-tiles2-036)]
 B$8B40,8;44 #HTML[#UDGARRAY1,7,4,1;$8B40-$8B47-8(exterior-tiles2-037)]
 B$8B48,8;44 #HTML[#UDGARRAY1,7,4,1;$8B48-$8B4F-8(exterior-tiles2-038)]
 B$8B50,8;44 #HTML[#UDGARRAY1,7,4,1;$8B50-$8B57-8(exterior-tiles2-039)]
 B$8B58,8;44 #HTML[#UDGARRAY1,7,4,1;$8B58-$8B5F-8(exterior-tiles2-040)]
 B$8B60,8;44 #HTML[#UDGARRAY1,7,4,1;$8B60-$8B67-8(exterior-tiles2-041)]
 B$8B68,8;44 #HTML[#UDGARRAY1,7,4,1;$8B68-$8B6F-8(exterior-tiles2-042)]
 B$8B70,8;44 #HTML[#UDGARRAY1,7,4,1;$8B70-$8B77-8(exterior-tiles2-043)]
 B$8B78,8;44 #HTML[#UDGARRAY1,7,4,1;$8B78-$8B7F-8(exterior-tiles2-044)]
 B$8B80,8;44 #HTML[#UDGARRAY1,7,4,1;$8B80-$8B87-8(exterior-tiles2-045)]
 B$8B88,8;44 #HTML[#UDGARRAY1,7,4,1;$8B88-$8B8F-8(exterior-tiles2-046)]
 B$8B90,8;44 #HTML[#UDGARRAY1,7,4,1;$8B90-$8B97-8(exterior-tiles2-047)]
 B$8B98,8;44 #HTML[#UDGARRAY1,7,4,1;$8B98-$8B9F-8(exterior-tiles2-048)]
 B$8BA0,8;44 #HTML[#UDGARRAY1,7,4,1;$8BA0-$8BA7-8(exterior-tiles2-049)]
 B$8BA8,8;44 #HTML[#UDGARRAY1,7,4,1;$8BA8-$8BAF-8(exterior-tiles2-050)]
 B$8BB0,8;44 #HTML[#UDGARRAY1,7,4,1;$8BB0-$8BB7-8(exterior-tiles2-051)]
 B$8BB8,8;44 #HTML[#UDGARRAY1,7,4,1;$8BB8-$8BBF-8(exterior-tiles2-052)]
 B$8BC0,8;44 #HTML[#UDGARRAY1,7,4,1;$8BC0-$8BC7-8(exterior-tiles2-053)]
 B$8BC8,8;44 #HTML[#UDGARRAY1,7,4,1;$8BC8-$8BCF-8(exterior-tiles2-054)]
 B$8BD0,8;44 #HTML[#UDGARRAY1,7,4,1;$8BD0-$8BD7-8(exterior-tiles2-055)]
 B$8BD8,8;44 #HTML[#UDGARRAY1,7,4,1;$8BD8-$8BDF-8(exterior-tiles2-056)]
 B$8BE0,8;44 #HTML[#UDGARRAY1,7,4,1;$8BE0-$8BE7-8(exterior-tiles2-057)]
 B$8BE8,8;44 #HTML[#UDGARRAY1,7,4,1;$8BE8-$8BEF-8(exterior-tiles2-058)]
 B$8BF0,8;44 #HTML[#UDGARRAY1,7,4,1;$8BF0-$8BF7-8(exterior-tiles2-059)]
 B$8BF8,8;44 #HTML[#UDGARRAY1,7,4,1;$8BF8-$8BFF-8(exterior-tiles2-060)]
 B$8C00,8;44 #HTML[#UDGARRAY1,7,4,1;$8C00-$8C07-8(exterior-tiles2-061)]
 B$8C08,8;44 #HTML[#UDGARRAY1,7,4,1;$8C08-$8C0F-8(exterior-tiles2-062)]
 B$8C10,8;44 #HTML[#UDGARRAY1,7,4,1;$8C10-$8C17-8(exterior-tiles2-063)]
 B$8C18,8;44 #HTML[#UDGARRAY1,7,4,1;$8C18-$8C1F-8(exterior-tiles2-064)]
 B$8C20,8;44 #HTML[#UDGARRAY1,7,4,1;$8C20-$8C27-8(exterior-tiles2-065)]
 B$8C28,8;44 #HTML[#UDGARRAY1,7,4,1;$8C28-$8C2F-8(exterior-tiles2-066)]
 B$8C30,8;44 #HTML[#UDGARRAY1,7,4,1;$8C30-$8C37-8(exterior-tiles2-067)]
 B$8C38,8;44 #HTML[#UDGARRAY1,7,4,1;$8C38-$8C3F-8(exterior-tiles2-068)]
 B$8C40,8;44 #HTML[#UDGARRAY1,7,4,1;$8C40-$8C47-8(exterior-tiles2-069)]
 B$8C48,8;44 #HTML[#UDGARRAY1,7,4,1;$8C48-$8C4F-8(exterior-tiles2-070)]
 B$8C50,8;44 #HTML[#UDGARRAY1,7,4,1;$8C50-$8C57-8(exterior-tiles2-071)]
 B$8C58,8;44 #HTML[#UDGARRAY1,7,4,1;$8C58-$8C5F-8(exterior-tiles2-072)]
 B$8C60,8;44 #HTML[#UDGARRAY1,7,4,1;$8C60-$8C67-8(exterior-tiles2-073)]
 B$8C68,8;44 #HTML[#UDGARRAY1,7,4,1;$8C68-$8C6F-8(exterior-tiles2-074)]
 B$8C70,8;44 #HTML[#UDGARRAY1,7,4,1;$8C70-$8C77-8(exterior-tiles2-075)]
 B$8C78,8;44 #HTML[#UDGARRAY1,7,4,1;$8C78-$8C7F-8(exterior-tiles2-076)]
 B$8C80,8;44 #HTML[#UDGARRAY1,7,4,1;$8C80-$8C87-8(exterior-tiles2-077)]
 B$8C88,8;44 #HTML[#UDGARRAY1,7,4,1;$8C88-$8C8F-8(exterior-tiles2-078)]
 B$8C90,8;44 #HTML[#UDGARRAY1,7,4,1;$8C90-$8C97-8(exterior-tiles2-079)]
 B$8C98,8;44 #HTML[#UDGARRAY1,7,4,1;$8C98-$8C9F-8(exterior-tiles2-080)]
 B$8CA0,8;44 #HTML[#UDGARRAY1,7,4,1;$8CA0-$8CA7-8(exterior-tiles2-081)]
 B$8CA8,8;44 #HTML[#UDGARRAY1,7,4,1;$8CA8-$8CAF-8(exterior-tiles2-082)]
 B$8CB0,8;44 #HTML[#UDGARRAY1,7,4,1;$8CB0-$8CB7-8(exterior-tiles2-083)]
 B$8CB8,8;44 #HTML[#UDGARRAY1,7,4,1;$8CB8-$8CBF-8(exterior-tiles2-084)]
 B$8CC0,8;44 #HTML[#UDGARRAY1,7,4,1;$8CC0-$8CC7-8(exterior-tiles2-085)]
 B$8CC8,8;44 #HTML[#UDGARRAY1,7,4,1;$8CC8-$8CCF-8(exterior-tiles2-086)]
 B$8CD0,8;44 #HTML[#UDGARRAY1,7,4,1;$8CD0-$8CD7-8(exterior-tiles2-087)]
 B$8CD8,8;44 #HTML[#UDGARRAY1,7,4,1;$8CD8-$8CDF-8(exterior-tiles2-088)]
 B$8CE0,8;44 #HTML[#UDGARRAY1,7,4,1;$8CE0-$8CE7-8(exterior-tiles2-089)]
 B$8CE8,8;44 #HTML[#UDGARRAY1,7,4,1;$8CE8-$8CEF-8(exterior-tiles2-090)]
 B$8CF0,8;44 #HTML[#UDGARRAY1,7,4,1;$8CF0-$8CF7-8(exterior-tiles2-091)]
 B$8CF8,8;44 #HTML[#UDGARRAY1,7,4,1;$8CF8-$8CFF-8(exterior-tiles2-092)]
 B$8D00,8;44 #HTML[#UDGARRAY1,7,4,1;$8D00-$8D07-8(exterior-tiles2-093)]
 B$8D08,8;44 #HTML[#UDGARRAY1,7,4,1;$8D08-$8D0F-8(exterior-tiles2-094)]
 B$8D10,8;44 #HTML[#UDGARRAY1,7,4,1;$8D10-$8D17-8(exterior-tiles2-095)]
 B$8D18,8;44 #HTML[#UDGARRAY1,7,4,1;$8D18-$8D1F-8(exterior-tiles2-096)]
 B$8D20,8;44 #HTML[#UDGARRAY1,7,4,1;$8D20-$8D27-8(exterior-tiles2-097)]
 B$8D28,8;44 #HTML[#UDGARRAY1,7,4,1;$8D28-$8D2F-8(exterior-tiles2-098)]
 B$8D30,8;44 #HTML[#UDGARRAY1,7,4,1;$8D30-$8D37-8(exterior-tiles2-099)]
 B$8D38,8;44 #HTML[#UDGARRAY1,7,4,1;$8D38-$8D3F-8(exterior-tiles2-100)]
 B$8D40,8;44 #HTML[#UDGARRAY1,7,4,1;$8D40-$8D47-8(exterior-tiles2-101)]
 B$8D48,8;44 #HTML[#UDGARRAY1,7,4,1;$8D48-$8D4F-8(exterior-tiles2-102)]
 B$8D50,8;44 #HTML[#UDGARRAY1,7,4,1;$8D50-$8D57-8(exterior-tiles2-103)]
 B$8D58,8;44 #HTML[#UDGARRAY1,7,4,1;$8D58-$8D5F-8(exterior-tiles2-104)]
 B$8D60,8;44 #HTML[#UDGARRAY1,7,4,1;$8D60-$8D67-8(exterior-tiles2-105)]
 B$8D68,8;44 #HTML[#UDGARRAY1,7,4,1;$8D68-$8D6F-8(exterior-tiles2-106)]
 B$8D70,8;44 #HTML[#UDGARRAY1,7,4,1;$8D70-$8D77-8(exterior-tiles2-107)]
 B$8D78,8;44 #HTML[#UDGARRAY1,7,4,1;$8D78-$8D7F-8(exterior-tiles2-108)]
 B$8D80,8;44 #HTML[#UDGARRAY1,7,4,1;$8D80-$8D87-8(exterior-tiles2-109)]
 B$8D88,8;44 #HTML[#UDGARRAY1,7,4,1;$8D88-$8D8F-8(exterior-tiles2-110)]
 B$8D90,8;44 #HTML[#UDGARRAY1,7,4,1;$8D90-$8D97-8(exterior-tiles2-111)]
 B$8D98,8;44 #HTML[#UDGARRAY1,7,4,1;$8D98-$8D9F-8(exterior-tiles2-112)]
 B$8DA0,8;44 #HTML[#UDGARRAY1,7,4,1;$8DA0-$8DA7-8(exterior-tiles2-113)]
 B$8DA8,8;44 #HTML[#UDGARRAY1,7,4,1;$8DA8-$8DAF-8(exterior-tiles2-114)]
 B$8DB0,8;44 #HTML[#UDGARRAY1,7,4,1;$8DB0-$8DB7-8(exterior-tiles2-115)]
 B$8DB8,8;44 #HTML[#UDGARRAY1,7,4,1;$8DB8-$8DBF-8(exterior-tiles2-116)]
 B$8DC0,8;44 #HTML[#UDGARRAY1,7,4,1;$8DC0-$8DC7-8(exterior-tiles2-117)]
 B$8DC8,8;44 #HTML[#UDGARRAY1,7,4,1;$8DC8-$8DCF-8(exterior-tiles2-118)]
 B$8DD0,8;44 #HTML[#UDGARRAY1,7,4,1;$8DD0-$8DD7-8(exterior-tiles2-119)]
 B$8DD8,8;44 #HTML[#UDGARRAY1,7,4,1;$8DD8-$8DDF-8(exterior-tiles2-120)]
 B$8DE0,8;44 #HTML[#UDGARRAY1,7,4,1;$8DE0-$8DE7-8(exterior-tiles2-121)]
 B$8DE8,8;44 #HTML[#UDGARRAY1,7,4,1;$8DE8-$8DEF-8(exterior-tiles2-122)]
 B$8DF0,8;44 #HTML[#UDGARRAY1,7,4,1;$8DF0-$8DF7-8(exterior-tiles2-123)]
 B$8DF8,8;44 #HTML[#UDGARRAY1,7,4,1;$8DF8-$8DFF-8(exterior-tiles2-124)]
 B$8E00,8;44 #HTML[#UDGARRAY1,7,4,1;$8E00-$8E07-8(exterior-tiles2-125)]
 B$8E08,8;44 #HTML[#UDGARRAY1,7,4,1;$8E08-$8E0F-8(exterior-tiles2-126)]
 B$8E10,8;44 #HTML[#UDGARRAY1,7,4,1;$8E10-$8E17-8(exterior-tiles2-127)]
 B$8E18,8;44 #HTML[#UDGARRAY1,7,4,1;$8E18-$8E1F-8(exterior-tiles2-128)]
 B$8E20,8;44 #HTML[#UDGARRAY1,7,4,1;$8E20-$8E27-8(exterior-tiles2-129)]
 B$8E28,8;44 #HTML[#UDGARRAY1,7,4,1;$8E28-$8E2F-8(exterior-tiles2-130)]
 B$8E30,8;44 #HTML[#UDGARRAY1,7,4,1;$8E30-$8E37-8(exterior-tiles2-131)]
 B$8E38,8;44 #HTML[#UDGARRAY1,7,4,1;$8E38-$8E3F-8(exterior-tiles2-132)]
 B$8E40,8;44 #HTML[#UDGARRAY1,7,4,1;$8E40-$8E47-8(exterior-tiles2-133)]
 B$8E48,8;44 #HTML[#UDGARRAY1,7,4,1;$8E48-$8E4F-8(exterior-tiles2-134)]
 B$8E50,8;44 #HTML[#UDGARRAY1,7,4,1;$8E50-$8E57-8(exterior-tiles2-135)]
 B$8E58,8;44 #HTML[#UDGARRAY1,7,4,1;$8E58-$8E5F-8(exterior-tiles2-136)]
 B$8E60,8;44 #HTML[#UDGARRAY1,7,4,1;$8E60-$8E67-8(exterior-tiles2-137)]
 B$8E68,8;44 #HTML[#UDGARRAY1,7,4,1;$8E68-$8E6F-8(exterior-tiles2-138)]
 B$8E70,8;44 #HTML[#UDGARRAY1,7,4,1;$8E70-$8E77-8(exterior-tiles2-139)]
 B$8E78,8;44 #HTML[#UDGARRAY1,7,4,1;$8E78-$8E7F-8(exterior-tiles2-140)]
 B$8E80,8;44 #HTML[#UDGARRAY1,7,4,1;$8E80-$8E87-8(exterior-tiles2-141)]
 B$8E88,8;44 #HTML[#UDGARRAY1,7,4,1;$8E88-$8E8F-8(exterior-tiles2-142)]
 B$8E90,8;44 #HTML[#UDGARRAY1,7,4,1;$8E90-$8E97-8(exterior-tiles2-143)]
 B$8E98,8;44 #HTML[#UDGARRAY1,7,4,1;$8E98-$8E9F-8(exterior-tiles2-144)]
 B$8EA0,8;44 #HTML[#UDGARRAY1,7,4,1;$8EA0-$8EA7-8(exterior-tiles2-145)]
 B$8EA8,8;44 #HTML[#UDGARRAY1,7,4,1;$8EA8-$8EAF-8(exterior-tiles2-146)]
 B$8EB0,8;44 #HTML[#UDGARRAY1,7,4,1;$8EB0-$8EB7-8(exterior-tiles2-147)]
 B$8EB8,8;44 #HTML[#UDGARRAY1,7,4,1;$8EB8-$8EBF-8(exterior-tiles2-148)]
 B$8EC0,8;44 #HTML[#UDGARRAY1,7,4,1;$8EC0-$8EC7-8(exterior-tiles2-149)]
 B$8EC8,8;44 #HTML[#UDGARRAY1,7,4,1;$8EC8-$8ECF-8(exterior-tiles2-150)]
 B$8ED0,8;44 #HTML[#UDGARRAY1,7,4,1;$8ED0-$8ED7-8(exterior-tiles2-151)]
 B$8ED8,8;44 #HTML[#UDGARRAY1,7,4,1;$8ED8-$8EDF-8(exterior-tiles2-152)]
 B$8EE0,8;44 #HTML[#UDGARRAY1,7,4,1;$8EE0-$8EE7-8(exterior-tiles2-153)]
 B$8EE8,8;44 #HTML[#UDGARRAY1,7,4,1;$8EE8-$8EEF-8(exterior-tiles2-154)]
 B$8EF0,8;44 #HTML[#UDGARRAY1,7,4,1;$8EF0-$8EF7-8(exterior-tiles2-155)]
 B$8EF8,8;44 #HTML[#UDGARRAY1,7,4,1;$8EF8-$8EFF-8(exterior-tiles2-156)]
 B$8F00,8;44 #HTML[#UDGARRAY1,7,4,1;$8F00-$8F07-8(exterior-tiles2-157)]
 B$8F08,8;44 #HTML[#UDGARRAY1,7,4,1;$8F08-$8F0F-8(exterior-tiles2-158)]
 B$8F10,8;44 #HTML[#UDGARRAY1,7,4,1;$8F10-$8F17-8(exterior-tiles2-159)]
 B$8F18,8;44 #HTML[#UDGARRAY1,7,4,1;$8F18-$8F1F-8(exterior-tiles2-160)]
 B$8F20,8;44 #HTML[#UDGARRAY1,7,4,1;$8F20-$8F27-8(exterior-tiles2-161)]
 B$8F28,8;44 #HTML[#UDGARRAY1,7,4,1;$8F28-$8F2F-8(exterior-tiles2-162)]
 B$8F30,8;44 #HTML[#UDGARRAY1,7,4,1;$8F30-$8F37-8(exterior-tiles2-163)]
 B$8F38,8;44 #HTML[#UDGARRAY1,7,4,1;$8F38-$8F3F-8(exterior-tiles2-164)]
 B$8F40,8;44 #HTML[#UDGARRAY1,7,4,1;$8F40-$8F47-8(exterior-tiles2-165)]
 B$8F48,8;44 #HTML[#UDGARRAY1,7,4,1;$8F48-$8F4F-8(exterior-tiles2-166)]
 B$8F50,8;44 #HTML[#UDGARRAY1,7,4,1;$8F50-$8F57-8(exterior-tiles2-167)]
 B$8F58,8;44 #HTML[#UDGARRAY1,7,4,1;$8F58-$8F5F-8(exterior-tiles2-168)]
 B$8F60,8;44 #HTML[#UDGARRAY1,7,4,1;$8F60-$8F67-8(exterior-tiles2-169)]
 B$8F68,8;44 #HTML[#UDGARRAY1,7,4,1;$8F68-$8F6F-8(exterior-tiles2-170)]
 B$8F70,8;44 #HTML[#UDGARRAY1,7,4,1;$8F70-$8F77-8(exterior-tiles2-171)]
 B$8F78,8;44 #HTML[#UDGARRAY1,7,4,1;$8F78-$8F7F-8(exterior-tiles2-172)]
 B$8F80,8;44 #HTML[#UDGARRAY1,7,4,1;$8F80-$8F87-8(exterior-tiles2-173)]
 B$8F88,8;44 #HTML[#UDGARRAY1,7,4,1;$8F88-$8F8F-8(exterior-tiles2-174)]
 B$8F90,8;44 #HTML[#UDGARRAY1,7,4,1;$8F90-$8F97-8(exterior-tiles2-175)]
 B$8F98,8;44 #HTML[#UDGARRAY1,7,4,1;$8F98-$8F9F-8(exterior-tiles2-176)]
 B$8FA0,8;44 #HTML[#UDGARRAY1,7,4,1;$8FA0-$8FA7-8(exterior-tiles2-177)]
 B$8FA8,8;44 #HTML[#UDGARRAY1,7,4,1;$8FA8-$8FAF-8(exterior-tiles2-178)]
 B$8FB0,8;44 #HTML[#UDGARRAY1,7,4,1;$8FB0-$8FB7-8(exterior-tiles2-179)]
 B$8FB8,8;44 #HTML[#UDGARRAY1,7,4,1;$8FB8-$8FBF-8(exterior-tiles2-180)]
 B$8FC0,8;44 #HTML[#UDGARRAY1,7,4,1;$8FC0-$8FC7-8(exterior-tiles2-181)]
 B$8FC8,8;44 #HTML[#UDGARRAY1,7,4,1;$8FC8-$8FCF-8(exterior-tiles2-182)]
 B$8FD0,8;44 #HTML[#UDGARRAY1,7,4,1;$8FD0-$8FD7-8(exterior-tiles2-183)]
 B$8FD8,8;44 #HTML[#UDGARRAY1,7,4,1;$8FD8-$8FDF-8(exterior-tiles2-184)]
 B$8FE0,8;44 #HTML[#UDGARRAY1,7,4,1;$8FE0-$8FE7-8(exterior-tiles2-185)]
 B$8FE8,8;44 #HTML[#UDGARRAY1,7,4,1;$8FE8-$8FEF-8(exterior-tiles2-186)]
 B$8FF0,8;44 #HTML[#UDGARRAY1,7,4,1;$8FF0-$8FF7-8(exterior-tiles2-187)]
 B$8FF8,8;44 #HTML[#UDGARRAY1,7,4,1;$8FF8-$8FFF-8(exterior-tiles2-188)]
 B$9000,8;44 #HTML[#UDGARRAY1,7,4,1;$9000-$9007-8(exterior-tiles2-189)]
 B$9008,8;44 #HTML[#UDGARRAY1,7,4,1;$9008-$900F-8(exterior-tiles2-190)]
 B$9010,8;44 #HTML[#UDGARRAY1,7,4,1;$9010-$9017-8(exterior-tiles2-191)]
 B$9018,8;44 #HTML[#UDGARRAY1,7,4,1;$9018-$901F-8(exterior-tiles2-192)]
 B$9020,8;44 #HTML[#UDGARRAY1,7,4,1;$9020-$9027-8(exterior-tiles2-193)]
 B$9028,8;44 #HTML[#UDGARRAY1,7,4,1;$9028-$902F-8(exterior-tiles2-194)]
 B$9030,8;44 #HTML[#UDGARRAY1,7,4,1;$9030-$9037-8(exterior-tiles2-195)]
 B$9038,8;44 #HTML[#UDGARRAY1,7,4,1;$9038-$903F-8(exterior-tiles2-196)]
 B$9040,8;44 #HTML[#UDGARRAY1,7,4,1;$9040-$9047-8(exterior-tiles2-197)]
 B$9048,8;44 #HTML[#UDGARRAY1,7,4,1;$9048-$904F-8(exterior-tiles2-198)]
 B$9050,8;44 #HTML[#UDGARRAY1,7,4,1;$9050-$9057-8(exterior-tiles2-199)]
 B$9058,8;44 #HTML[#UDGARRAY1,7,4,1;$9058-$905F-8(exterior-tiles2-200)]
 B$9060,8;44 #HTML[#UDGARRAY1,7,4,1;$9060-$9067-8(exterior-tiles2-201)]
 B$9068,8;44 #HTML[#UDGARRAY1,7,4,1;$9068-$906F-8(exterior-tiles2-202)]
 B$9070,8;44 #HTML[#UDGARRAY1,7,4,1;$9070-$9077-8(exterior-tiles2-203)]
 B$9078,8;44 #HTML[#UDGARRAY1,7,4,1;$9078-$907F-8(exterior-tiles2-204)]
 B$9080,8;44 #HTML[#UDGARRAY1,7,4,1;$9080-$9087-8(exterior-tiles2-205)]
 B$9088,8;44 #HTML[#UDGARRAY1,7,4,1;$9088-$908F-8(exterior-tiles2-206)]
 B$9090,8;44 #HTML[#UDGARRAY1,7,4,1;$9090-$9097-8(exterior-tiles2-207)]
 B$9098,8;44 #HTML[#UDGARRAY1,7,4,1;$9098-$909F-8(exterior-tiles2-208)]
 B$90A0,8;44 #HTML[#UDGARRAY1,7,4,1;$90A0-$90A7-8(exterior-tiles2-209)]
 B$90A8,8;44 #HTML[#UDGARRAY1,7,4,1;$90A8-$90AF-8(exterior-tiles2-210)]
 B$90B0,8;44 #HTML[#UDGARRAY1,7,4,1;$90B0-$90B7-8(exterior-tiles2-211)]
 B$90B8,8;44 #HTML[#UDGARRAY1,7,4,1;$90B8-$90BF-8(exterior-tiles2-212)]
 B$90C0,8;44 #HTML[#UDGARRAY1,7,4,1;$90C0-$90C7-8(exterior-tiles2-213)]
 B$90C8,8;44 #HTML[#UDGARRAY1,7,4,1;$90C8-$90CF-8(exterior-tiles2-214)]
 B$90D0,8;44 #HTML[#UDGARRAY1,7,4,1;$90D0-$90D7-8(exterior-tiles2-215)]
 B$90D8,8;44 #HTML[#UDGARRAY1,7,4,1;$90D8-$90DF-8(exterior-tiles2-216)]
 B$90E0,8;44 #HTML[#UDGARRAY1,7,4,1;$90E0-$90E7-8(exterior-tiles2-217)]
 B$90E8,8;44 #HTML[#UDGARRAY1,7,4,1;$90E8-$90EF-8(exterior-tiles2-218)]
 B$90F0,8;44 #HTML[#UDGARRAY1,7,4,1;$90F0-$90F7-8(exterior-tiles2-219)]
 B$90F8,8;44 #HTML[#UDGARRAY1,7,4,1;$90F8-$90FF-8(exterior-tiles3-000)]
 B$9100,8;44 #HTML[#UDGARRAY1,7,4,1;$9100-$9107-8(exterior-tiles3-001)]
 B$9108,8;44 #HTML[#UDGARRAY1,7,4,1;$9108-$910F-8(exterior-tiles3-002)]
 B$9110,8;44 #HTML[#UDGARRAY1,7,4,1;$9110-$9117-8(exterior-tiles3-003)]
 B$9118,8;44 #HTML[#UDGARRAY1,7,4,1;$9118-$911F-8(exterior-tiles3-004)]
 B$9120,8;44 #HTML[#UDGARRAY1,7,4,1;$9120-$9127-8(exterior-tiles3-005)]
 B$9128,8;44 #HTML[#UDGARRAY1,7,4,1;$9128-$912F-8(exterior-tiles3-006)]
 B$9130,8;44 #HTML[#UDGARRAY1,7,4,1;$9130-$9137-8(exterior-tiles3-007)]
 B$9138,8;44 #HTML[#UDGARRAY1,7,4,1;$9138-$913F-8(exterior-tiles3-008)]
 B$9140,8;44 #HTML[#UDGARRAY1,7,4,1;$9140-$9147-8(exterior-tiles3-009)]
 B$9148,8;44 #HTML[#UDGARRAY1,7,4,1;$9148-$914F-8(exterior-tiles3-010)]
 B$9150,8;44 #HTML[#UDGARRAY1,7,4,1;$9150-$9157-8(exterior-tiles3-011)]
 B$9158,8;44 #HTML[#UDGARRAY1,7,4,1;$9158-$915F-8(exterior-tiles3-012)]
 B$9160,8;44 #HTML[#UDGARRAY1,7,4,1;$9160-$9167-8(exterior-tiles3-013)]
 B$9168,8;44 #HTML[#UDGARRAY1,7,4,1;$9168-$916F-8(exterior-tiles3-014)]
 B$9170,8;44 #HTML[#UDGARRAY1,7,4,1;$9170-$9177-8(exterior-tiles3-015)]
 B$9178,8;44 #HTML[#UDGARRAY1,7,4,1;$9178-$917F-8(exterior-tiles3-016)]
 B$9180,8;44 #HTML[#UDGARRAY1,7,4,1;$9180-$9187-8(exterior-tiles3-017)]
 B$9188,8;44 #HTML[#UDGARRAY1,7,4,1;$9188-$918F-8(exterior-tiles3-018)]
 B$9190,8;44 #HTML[#UDGARRAY1,7,4,1;$9190-$9197-8(exterior-tiles3-019)]
 B$9198,8;44 #HTML[#UDGARRAY1,7,4,1;$9198-$919F-8(exterior-tiles3-020)]
 B$91A0,8;44 #HTML[#UDGARRAY1,7,4,1;$91A0-$91A7-8(exterior-tiles3-021)]
 B$91A8,8;44 #HTML[#UDGARRAY1,7,4,1;$91A8-$91AF-8(exterior-tiles3-022)]
 B$91B0,8;44 #HTML[#UDGARRAY1,7,4,1;$91B0-$91B7-8(exterior-tiles3-023)]
 B$91B8,8;44 #HTML[#UDGARRAY1,7,4,1;$91B8-$91BF-8(exterior-tiles3-024)]
 B$91C0,8;44 #HTML[#UDGARRAY1,7,4,1;$91C0-$91C7-8(exterior-tiles3-025)]
 B$91C8,8;44 #HTML[#UDGARRAY1,7,4,1;$91C8-$91CF-8(exterior-tiles3-026)]
 B$91D0,8;44 #HTML[#UDGARRAY1,7,4,1;$91D0-$91D7-8(exterior-tiles3-027)]
 B$91D8,8;44 #HTML[#UDGARRAY1,7,4,1;$91D8-$91DF-8(exterior-tiles3-028)]
 B$91E0,8;44 #HTML[#UDGARRAY1,7,4,1;$91E0-$91E7-8(exterior-tiles3-029)]
 B$91E8,8;44 #HTML[#UDGARRAY1,7,4,1;$91E8-$91EF-8(exterior-tiles3-030)]
 B$91F0,8;44 #HTML[#UDGARRAY1,7,4,1;$91F0-$91F7-8(exterior-tiles3-031)]
 B$91F8,8;44 #HTML[#UDGARRAY1,7,4,1;$91F8-$91FF-8(exterior-tiles3-032)]
 B$9200,8;44 #HTML[#UDGARRAY1,7,4,1;$9200-$9207-8(exterior-tiles3-033)]
 B$9208,8;44 #HTML[#UDGARRAY1,7,4,1;$9208-$920F-8(exterior-tiles3-034)]
 B$9210,8;44 #HTML[#UDGARRAY1,7,4,1;$9210-$9217-8(exterior-tiles3-035)]
 B$9218,8;44 #HTML[#UDGARRAY1,7,4,1;$9218-$921F-8(exterior-tiles3-036)]
 B$9220,8;44 #HTML[#UDGARRAY1,7,4,1;$9220-$9227-8(exterior-tiles3-037)]
 B$9228,8;44 #HTML[#UDGARRAY1,7,4,1;$9228-$922F-8(exterior-tiles3-038)]
 B$9230,8;44 #HTML[#UDGARRAY1,7,4,1;$9230-$9237-8(exterior-tiles3-039)]
 B$9238,8;44 #HTML[#UDGARRAY1,7,4,1;$9238-$923F-8(exterior-tiles3-040)]
 B$9240,8;44 #HTML[#UDGARRAY1,7,4,1;$9240-$9247-8(exterior-tiles3-041)]
 B$9248,8;44 #HTML[#UDGARRAY1,7,4,1;$9248-$924F-8(exterior-tiles3-042)]
 B$9250,8;44 #HTML[#UDGARRAY1,7,4,1;$9250-$9257-8(exterior-tiles3-043)]
 B$9258,8;44 #HTML[#UDGARRAY1,7,4,1;$9258-$925F-8(exterior-tiles3-044)]
 B$9260,8;44 #HTML[#UDGARRAY1,7,4,1;$9260-$9267-8(exterior-tiles3-045)]
 B$9268,8;44 #HTML[#UDGARRAY1,7,4,1;$9268-$926F-8(exterior-tiles3-046)]
 B$9270,8;44 #HTML[#UDGARRAY1,7,4,1;$9270-$9277-8(exterior-tiles3-047)]
 B$9278,8;44 #HTML[#UDGARRAY1,7,4,1;$9278-$927F-8(exterior-tiles3-048)]
 B$9280,8;44 #HTML[#UDGARRAY1,7,4,1;$9280-$9287-8(exterior-tiles3-049)]
 B$9288,8;44 #HTML[#UDGARRAY1,7,4,1;$9288-$928F-8(exterior-tiles3-050)]
 B$9290,8;44 #HTML[#UDGARRAY1,7,4,1;$9290-$9297-8(exterior-tiles3-051)]
 B$9298,8;44 #HTML[#UDGARRAY1,7,4,1;$9298-$929F-8(exterior-tiles3-052)]
 B$92A0,8;44 #HTML[#UDGARRAY1,7,4,1;$92A0-$92A7-8(exterior-tiles3-053)]
 B$92A8,8;44 #HTML[#UDGARRAY1,7,4,1;$92A8-$92AF-8(exterior-tiles3-054)]
 B$92B0,8;44 #HTML[#UDGARRAY1,7,4,1;$92B0-$92B7-8(exterior-tiles3-055)]
 B$92B8,8;44 #HTML[#UDGARRAY1,7,4,1;$92B8-$92BF-8(exterior-tiles3-056)]
 B$92C0,8;44 #HTML[#UDGARRAY1,7,4,1;$92C0-$92C7-8(exterior-tiles3-057)]
 B$92C8,8;44 #HTML[#UDGARRAY1,7,4,1;$92C8-$92CF-8(exterior-tiles3-058)]
 B$92D0,8;44 #HTML[#UDGARRAY1,7,4,1;$92D0-$92D7-8(exterior-tiles3-059)]
 B$92D8,8;44 #HTML[#UDGARRAY1,7,4,1;$92D8-$92DF-8(exterior-tiles3-060)]
 B$92E0,8;44 #HTML[#UDGARRAY1,7,4,1;$92E0-$92E7-8(exterior-tiles3-061)]
 B$92E8,8;44 #HTML[#UDGARRAY1,7,4,1;$92E8-$92EF-8(exterior-tiles3-062)]
 B$92F0,8;44 #HTML[#UDGARRAY1,7,4,1;$92F0-$92F7-8(exterior-tiles3-063)]
 B$92F8,8;44 #HTML[#UDGARRAY1,7,4,1;$92F8-$92FF-8(exterior-tiles3-064)]
 B$9300,8;44 #HTML[#UDGARRAY1,7,4,1;$9300-$9307-8(exterior-tiles3-065)]
 B$9308,8;44 #HTML[#UDGARRAY1,7,4,1;$9308-$930F-8(exterior-tiles3-066)]
 B$9310,8;44 #HTML[#UDGARRAY1,7,4,1;$9310-$9317-8(exterior-tiles3-067)]
 B$9318,8;44 #HTML[#UDGARRAY1,7,4,1;$9318-$931F-8(exterior-tiles3-068)]
 B$9320,8;44 #HTML[#UDGARRAY1,7,4,1;$9320-$9327-8(exterior-tiles3-069)]
 B$9328,8;44 #HTML[#UDGARRAY1,7,4,1;$9328-$932F-8(exterior-tiles3-070)]
 B$9330,8;44 #HTML[#UDGARRAY1,7,4,1;$9330-$9337-8(exterior-tiles3-071)]
 B$9338,8;44 #HTML[#UDGARRAY1,7,4,1;$9338-$933F-8(exterior-tiles3-072)]
 B$9340,8;44 #HTML[#UDGARRAY1,7,4,1;$9340-$9347-8(exterior-tiles3-073)]
 B$9348,8;44 #HTML[#UDGARRAY1,7,4,1;$9348-$934F-8(exterior-tiles3-074)]
 B$9350,8;44 #HTML[#UDGARRAY1,7,4,1;$9350-$9357-8(exterior-tiles3-075)]
 B$9358,8;44 #HTML[#UDGARRAY1,7,4,1;$9358-$935F-8(exterior-tiles3-076)]
 B$9360,8;44 #HTML[#UDGARRAY1,7,4,1;$9360-$9367-8(exterior-tiles3-077)]
 B$9368,8;44 #HTML[#UDGARRAY1,7,4,1;$9368-$936F-8(exterior-tiles3-078)]
 B$9370,8;44 #HTML[#UDGARRAY1,7,4,1;$9370-$9377-8(exterior-tiles3-079)]
 B$9378,8;44 #HTML[#UDGARRAY1,7,4,1;$9378-$937F-8(exterior-tiles3-080)]
 B$9380,8;44 #HTML[#UDGARRAY1,7,4,1;$9380-$9387-8(exterior-tiles3-081)]
 B$9388,8;44 #HTML[#UDGARRAY1,7,4,1;$9388-$938F-8(exterior-tiles3-082)]
 B$9390,8;44 #HTML[#UDGARRAY1,7,4,1;$9390-$9397-8(exterior-tiles3-083)]
 B$9398,8;44 #HTML[#UDGARRAY1,7,4,1;$9398-$939F-8(exterior-tiles3-084)]
 B$93A0,8;44 #HTML[#UDGARRAY1,7,4,1;$93A0-$93A7-8(exterior-tiles3-085)]
 B$93A8,8;44 #HTML[#UDGARRAY1,7,4,1;$93A8-$93AF-8(exterior-tiles3-086)]
 B$93B0,8;44 #HTML[#UDGARRAY1,7,4,1;$93B0-$93B7-8(exterior-tiles3-087)]
 B$93B8,8;44 #HTML[#UDGARRAY1,7,4,1;$93B8-$93BF-8(exterior-tiles3-088)]
 B$93C0,8;44 #HTML[#UDGARRAY1,7,4,1;$93C0-$93C7-8(exterior-tiles3-089)]
 B$93C8,8;44 #HTML[#UDGARRAY1,7,4,1;$93C8-$93CF-8(exterior-tiles3-090)]
 B$93D0,8;44 #HTML[#UDGARRAY1,7,4,1;$93D0-$93D7-8(exterior-tiles3-091)]
 B$93D8,8;44 #HTML[#UDGARRAY1,7,4,1;$93D8-$93DF-8(exterior-tiles3-092)]
 B$93E0,8;44 #HTML[#UDGARRAY1,7,4,1;$93E0-$93E7-8(exterior-tiles3-093)]
 B$93E8,8;44 #HTML[#UDGARRAY1,7,4,1;$93E8-$93EF-8(exterior-tiles3-094)]
 B$93F0,8;44 #HTML[#UDGARRAY1,7,4,1;$93F0-$93F7-8(exterior-tiles3-095)]
 B$93F8,8;44 #HTML[#UDGARRAY1,7,4,1;$93F8-$93FF-8(exterior-tiles3-096)]
 B$9400,8;44 #HTML[#UDGARRAY1,7,4,1;$9400-$9407-8(exterior-tiles3-097)]
 B$9408,8;44 #HTML[#UDGARRAY1,7,4,1;$9408-$940F-8(exterior-tiles3-098)]
 B$9410,8;44 #HTML[#UDGARRAY1,7,4,1;$9410-$9417-8(exterior-tiles3-099)]
 B$9418,8;44 #HTML[#UDGARRAY1,7,4,1;$9418-$941F-8(exterior-tiles3-100)]
 B$9420,8;44 #HTML[#UDGARRAY1,7,4,1;$9420-$9427-8(exterior-tiles3-101)]
 B$9428,8;44 #HTML[#UDGARRAY1,7,4,1;$9428-$942F-8(exterior-tiles3-102)]
 B$9430,8;44 #HTML[#UDGARRAY1,7,4,1;$9430-$9437-8(exterior-tiles3-103)]
 B$9438,8;44 #HTML[#UDGARRAY1,7,4,1;$9438-$943F-8(exterior-tiles3-104)]
 B$9440,8;44 #HTML[#UDGARRAY1,7,4,1;$9440-$9447-8(exterior-tiles3-105)]
 B$9448,8;44 #HTML[#UDGARRAY1,7,4,1;$9448-$944F-8(exterior-tiles3-106)]
 B$9450,8;44 #HTML[#UDGARRAY1,7,4,1;$9450-$9457-8(exterior-tiles3-107)]
 B$9458,8;44 #HTML[#UDGARRAY1,7,4,1;$9458-$945F-8(exterior-tiles3-108)]
 B$9460,8;44 #HTML[#UDGARRAY1,7,4,1;$9460-$9467-8(exterior-tiles3-109)]
 B$9468,8;44 #HTML[#UDGARRAY1,7,4,1;$9468-$946F-8(exterior-tiles3-110)]
 B$9470,8;44 #HTML[#UDGARRAY1,7,4,1;$9470-$9477-8(exterior-tiles3-111)]
 B$9478,8;44 #HTML[#UDGARRAY1,7,4,1;$9478-$947F-8(exterior-tiles3-112)]
 B$9480,8;44 #HTML[#UDGARRAY1,7,4,1;$9480-$9487-8(exterior-tiles3-113)]
 B$9488,8;44 #HTML[#UDGARRAY1,7,4,1;$9488-$948F-8(exterior-tiles3-114)]
 B$9490,8;44 #HTML[#UDGARRAY1,7,4,1;$9490-$9497-8(exterior-tiles3-115)]
 B$9498,8;44 #HTML[#UDGARRAY1,7,4,1;$9498-$949F-8(exterior-tiles3-116)]
 B$94A0,8;44 #HTML[#UDGARRAY1,7,4,1;$94A0-$94A7-8(exterior-tiles3-117)]
 B$94A8,8;44 #HTML[#UDGARRAY1,7,4,1;$94A8-$94AF-8(exterior-tiles3-118)]
 B$94B0,8;44 #HTML[#UDGARRAY1,7,4,1;$94B0-$94B7-8(exterior-tiles3-119)]
 B$94B8,8;44 #HTML[#UDGARRAY1,7,4,1;$94B8-$94BF-8(exterior-tiles3-120)]
 B$94C0,8;44 #HTML[#UDGARRAY1,7,4,1;$94C0-$94C7-8(exterior-tiles3-121)]
 B$94C8,8;44 #HTML[#UDGARRAY1,7,4,1;$94C8-$94CF-8(exterior-tiles3-122)]
 B$94D0,8;44 #HTML[#UDGARRAY1,7,4,1;$94D0-$94D7-8(exterior-tiles3-123)]
 B$94D8,8;44 #HTML[#UDGARRAY1,7,4,1;$94D8-$94DF-8(exterior-tiles3-124)]
 B$94E0,8;44 #HTML[#UDGARRAY1,7,4,1;$94E0-$94E7-8(exterior-tiles3-125)]
 B$94E8,8;44 #HTML[#UDGARRAY1,7,4,1;$94E8-$94EF-8(exterior-tiles3-126)]
 B$94F0,8;44 #HTML[#UDGARRAY1,7,4,1;$94F0-$94F7-8(exterior-tiles3-127)]
 B$94F8,8;44 #HTML[#UDGARRAY1,7,4,1;$94F8-$94FF-8(exterior-tiles3-128)]
 B$9500,8;44 #HTML[#UDGARRAY1,7,4,1;$9500-$9507-8(exterior-tiles3-129)]
 B$9508,8;44 #HTML[#UDGARRAY1,7,4,1;$9508-$950F-8(exterior-tiles3-130)]
 B$9510,8;44 #HTML[#UDGARRAY1,7,4,1;$9510-$9517-8(exterior-tiles3-131)]
 B$9518,8;44 #HTML[#UDGARRAY1,7,4,1;$9518-$951F-8(exterior-tiles3-132)]
 B$9520,8;44 #HTML[#UDGARRAY1,7,4,1;$9520-$9527-8(exterior-tiles3-133)]
 B$9528,8;44 #HTML[#UDGARRAY1,7,4,1;$9528-$952F-8(exterior-tiles3-134)]
 B$9530,8;44 #HTML[#UDGARRAY1,7,4,1;$9530-$9537-8(exterior-tiles3-135)]
 B$9538,8;44 #HTML[#UDGARRAY1,7,4,1;$9538-$953F-8(exterior-tiles3-136)]
 B$9540,8;44 #HTML[#UDGARRAY1,7,4,1;$9540-$9547-8(exterior-tiles3-137)]
 B$9548,8;44 #HTML[#UDGARRAY1,7,4,1;$9548-$954F-8(exterior-tiles3-138)]
 B$9550,8;44 #HTML[#UDGARRAY1,7,4,1;$9550-$9557-8(exterior-tiles3-139)]
 B$9558,8;44 #HTML[#UDGARRAY1,7,4,1;$9558-$955F-8(exterior-tiles3-140)]
 B$9560,8;44 #HTML[#UDGARRAY1,7,4,1;$9560-$9567-8(exterior-tiles3-141)]
 B$9568,8;44 #HTML[#UDGARRAY1,7,4,1;$9568-$956F-8(exterior-tiles3-142)]
 B$9570,8;44 #HTML[#UDGARRAY1,7,4,1;$9570-$9577-8(exterior-tiles3-143)]
 B$9578,8;44 #HTML[#UDGARRAY1,7,4,1;$9578-$957F-8(exterior-tiles3-144)]
 B$9580,8;44 #HTML[#UDGARRAY1,7,4,1;$9580-$9587-8(exterior-tiles3-145)]
 B$9588,8;44 #HTML[#UDGARRAY1,7,4,1;$9588-$958F-8(exterior-tiles3-146)]
 B$9590,8;44 #HTML[#UDGARRAY1,7,4,1;$9590-$9597-8(exterior-tiles3-147)]
 B$9598,8;44 #HTML[#UDGARRAY1,7,4,1;$9598-$959F-8(exterior-tiles3-148)]
 B$95A0,8;44 #HTML[#UDGARRAY1,7,4,1;$95A0-$95A7-8(exterior-tiles3-149)]
 B$95A8,8;44 #HTML[#UDGARRAY1,7,4,1;$95A8-$95AF-8(exterior-tiles3-150)]
 B$95B0,8;44 #HTML[#UDGARRAY1,7,4,1;$95B0-$95B7-8(exterior-tiles3-151)]
 B$95B8,8;44 #HTML[#UDGARRAY1,7,4,1;$95B8-$95BF-8(exterior-tiles3-152)]
 B$95C0,8;44 #HTML[#UDGARRAY1,7,4,1;$95C0-$95C7-8(exterior-tiles3-153)]
 B$95C8,8;44 #HTML[#UDGARRAY1,7,4,1;$95C8-$95CF-8(exterior-tiles3-154)]
 B$95D0,8;44 #HTML[#UDGARRAY1,7,4,1;$95D0-$95D7-8(exterior-tiles3-155)]
 B$95D8,8;44 #HTML[#UDGARRAY1,7,4,1;$95D8-$95DF-8(exterior-tiles3-156)]
 B$95E0,8;44 #HTML[#UDGARRAY1,7,4,1;$95E0-$95E7-8(exterior-tiles3-157)]
 B$95E8,8;44 #HTML[#UDGARRAY1,7,4,1;$95E8-$95EF-8(exterior-tiles3-158)]
 B$95F0,8;44 #HTML[#UDGARRAY1,7,4,1;$95F0-$95F7-8(exterior-tiles3-159)]
 B$95F8,8;44 #HTML[#UDGARRAY1,7,4,1;$95F8-$95FF-8(exterior-tiles3-160)]
 B$9600,8;44 #HTML[#UDGARRAY1,7,4,1;$9600-$9607-8(exterior-tiles3-161)]
 B$9608,8;44 #HTML[#UDGARRAY1,7,4,1;$9608-$960F-8(exterior-tiles3-162)]
 B$9610,8;44 #HTML[#UDGARRAY1,7,4,1;$9610-$9617-8(exterior-tiles3-163)]
 B$9618,8;44 #HTML[#UDGARRAY1,7,4,1;$9618-$961F-8(exterior-tiles3-164)]
 B$9620,8;44 #HTML[#UDGARRAY1,7,4,1;$9620-$9627-8(exterior-tiles3-165)]
 B$9628,8;44 #HTML[#UDGARRAY1,7,4,1;$9628-$962F-8(exterior-tiles3-166)]
 B$9630,8;44 #HTML[#UDGARRAY1,7,4,1;$9630-$9637-8(exterior-tiles3-167)]
 B$9638,8;44 #HTML[#UDGARRAY1,7,4,1;$9638-$963F-8(exterior-tiles3-168)]
 B$9640,8;44 #HTML[#UDGARRAY1,7,4,1;$9640-$9647-8(exterior-tiles3-169)]
 B$9648,8;44 #HTML[#UDGARRAY1,7,4,1;$9648-$964F-8(exterior-tiles3-170)]
 B$9650,8;44 #HTML[#UDGARRAY1,7,4,1;$9650-$9657-8(exterior-tiles3-171)]
 B$9658,8;44 #HTML[#UDGARRAY1,7,4,1;$9658-$965F-8(exterior-tiles3-172)]
 B$9660,8;44 #HTML[#UDGARRAY1,7,4,1;$9660-$9667-8(exterior-tiles3-173)]
 B$9668,8;44 #HTML[#UDGARRAY1,7,4,1;$9668-$966F-8(exterior-tiles3-174)]
 B$9670,8;44 #HTML[#UDGARRAY1,7,4,1;$9670-$9677-8(exterior-tiles3-175)]
 B$9678,8;44 #HTML[#UDGARRAY1,7,4,1;$9678-$967F-8(exterior-tiles3-176)]
 B$9680,8;44 #HTML[#UDGARRAY1,7,4,1;$9680-$9687-8(exterior-tiles3-177)]
 B$9688,8;44 #HTML[#UDGARRAY1,7,4,1;$9688-$968F-8(exterior-tiles3-178)]
 B$9690,8;44 #HTML[#UDGARRAY1,7,4,1;$9690-$9697-8(exterior-tiles3-179)]
 B$9698,8;44 #HTML[#UDGARRAY1,7,4,1;$9698-$969F-8(exterior-tiles3-180)]
 B$96A0,8;44 #HTML[#UDGARRAY1,7,4,1;$96A0-$96A7-8(exterior-tiles3-181)]
 B$96A8,8;44 #HTML[#UDGARRAY1,7,4,1;$96A8-$96AF-8(exterior-tiles3-182)]
 B$96B0,8;44 #HTML[#UDGARRAY1,7,4,1;$96B0-$96B7-8(exterior-tiles3-183)]
 B$96B8,8;44 #HTML[#UDGARRAY1,7,4,1;$96B8-$96BF-8(exterior-tiles3-184)]
 B$96C0,8;44 #HTML[#UDGARRAY1,7,4,1;$96C0-$96C7-8(exterior-tiles3-185)]
 B$96C8,8;44 #HTML[#UDGARRAY1,7,4,1;$96C8-$96CF-8(exterior-tiles3-186)]
 B$96D0,8;44 #HTML[#UDGARRAY1,7,4,1;$96D0-$96D7-8(exterior-tiles3-187)]
 B$96D8,8;44 #HTML[#UDGARRAY1,7,4,1;$96D8-$96DF-8(exterior-tiles3-188)]
 B$96E0,8;44 #HTML[#UDGARRAY1,7,4,1;$96E0-$96E7-8(exterior-tiles3-189)]
 B$96E8,8;44 #HTML[#UDGARRAY1,7,4,1;$96E8-$96EF-8(exterior-tiles3-190)]
 B$96F0,8;44 #HTML[#UDGARRAY1,7,4,1;$96F0-$96F7-8(exterior-tiles3-191)]
 B$96F8,8;44 #HTML[#UDGARRAY1,7,4,1;$96F8-$96FF-8(exterior-tiles3-192)]
 B$9700,8;44 #HTML[#UDGARRAY1,7,4,1;$9700-$9707-8(exterior-tiles3-193)]
 B$9708,8;44 #HTML[#UDGARRAY1,7,4,1;$9708-$970F-8(exterior-tiles3-194)]
 B$9710,8;44 #HTML[#UDGARRAY1,7,4,1;$9710-$9717-8(exterior-tiles3-195)]
 B$9718,8;44 #HTML[#UDGARRAY1,7,4,1;$9718-$971F-8(exterior-tiles3-196)]
 B$9720,8;44 #HTML[#UDGARRAY1,7,4,1;$9720-$9727-8(exterior-tiles3-197)]
 B$9728,8;44 #HTML[#UDGARRAY1,7,4,1;$9728-$972F-8(exterior-tiles3-198)]
 B$9730,8;44 #HTML[#UDGARRAY1,7,4,1;$9730-$9737-8(exterior-tiles3-199)]
 B$9738,8;44 #HTML[#UDGARRAY1,7,4,1;$9738-$973F-8(exterior-tiles3-200)]
 B$9740,8;44 #HTML[#UDGARRAY1,7,4,1;$9740-$9747-8(exterior-tiles3-201)]
 B$9748,8;44 #HTML[#UDGARRAY1,7,4,1;$9748-$974F-8(exterior-tiles3-202)]
 B$9750,8;44 #HTML[#UDGARRAY1,7,4,1;$9750-$9757-8(exterior-tiles3-203)]
 B$9758,8;44 #HTML[#UDGARRAY1,7,4,1;$9758-$975F-8(exterior-tiles3-204)]
 B$9760,8;44 #HTML[#UDGARRAY1,7,4,1;$9760-$9767-8(exterior-tiles3-205)]
; Interior tiles. 194 tiles.
@label=interior_tiles
 B$9768,8;44 #HTML[#UDGARRAY1,7,4,1;$9768-$976F-8(interior-tiles-000)]
 B$9770,8;44 #HTML[#UDGARRAY1,7,4,1;$9770-$9777-8(interior-tiles-001)]
 B$9778,8;44 #HTML[#UDGARRAY1,7,4,1;$9778-$977F-8(interior-tiles-002)]
 B$9780,8;44 #HTML[#UDGARRAY1,7,4,1;$9780-$9787-8(interior-tiles-003)]
 B$9788,8;44 #HTML[#UDGARRAY1,7,4,1;$9788-$978F-8(interior-tiles-004)]
 B$9790,8;44 #HTML[#UDGARRAY1,7,4,1;$9790-$9797-8(interior-tiles-005)]
 B$9798,8;44 #HTML[#UDGARRAY1,7,4,1;$9798-$979F-8(interior-tiles-006)]
 B$97A0,8;44 #HTML[#UDGARRAY1,7,4,1;$97A0-$97A7-8(interior-tiles-007)]
 B$97A8,8;44 #HTML[#UDGARRAY1,7,4,1;$97A8-$97AF-8(interior-tiles-008)]
 B$97B0,8;44 #HTML[#UDGARRAY1,7,4,1;$97B0-$97B7-8(interior-tiles-009)]
 B$97B8,8;44 #HTML[#UDGARRAY1,7,4,1;$97B8-$97BF-8(interior-tiles-010)]
 B$97C0,8;44 #HTML[#UDGARRAY1,7,4,1;$97C0-$97C7-8(interior-tiles-011)]
 B$97C8,8;44 #HTML[#UDGARRAY1,7,4,1;$97C8-$97CF-8(interior-tiles-012)]
 B$97D0,8;44 #HTML[#UDGARRAY1,7,4,1;$97D0-$97D7-8(interior-tiles-013)]
 B$97D8,8;44 #HTML[#UDGARRAY1,7,4,1;$97D8-$97DF-8(interior-tiles-014)]
 B$97E0,8;44 #HTML[#UDGARRAY1,7,4,1;$97E0-$97E7-8(interior-tiles-015)]
 B$97E8,8;44 #HTML[#UDGARRAY1,7,4,1;$97E8-$97EF-8(interior-tiles-016)]
 B$97F0,8;44 #HTML[#UDGARRAY1,7,4,1;$97F0-$97F7-8(interior-tiles-017)]
 B$97F8,8;44 #HTML[#UDGARRAY1,7,4,1;$97F8-$97FF-8(interior-tiles-018)]
 B$9800,8;44 #HTML[#UDGARRAY1,7,4,1;$9800-$9807-8(interior-tiles-019)]
 B$9808,8;44 #HTML[#UDGARRAY1,7,4,1;$9808-$980F-8(interior-tiles-020)]
 B$9810,8;44 #HTML[#UDGARRAY1,7,4,1;$9810-$9817-8(interior-tiles-021)]
 B$9818,8;44 #HTML[#UDGARRAY1,7,4,1;$9818-$981F-8(interior-tiles-022)]
 B$9820,8;44 #HTML[#UDGARRAY1,7,4,1;$9820-$9827-8(interior-tiles-023)]
 B$9828,8;44 #HTML[#UDGARRAY1,7,4,1;$9828-$982F-8(interior-tiles-024)]
 B$9830,8;44 #HTML[#UDGARRAY1,7,4,1;$9830-$9837-8(interior-tiles-025)]
 B$9838,8;44 #HTML[#UDGARRAY1,7,4,1;$9838-$983F-8(interior-tiles-026)]
 B$9840,8;44 #HTML[#UDGARRAY1,7,4,1;$9840-$9847-8(interior-tiles-027)]
 B$9848,8;44 #HTML[#UDGARRAY1,7,4,1;$9848-$984F-8(interior-tiles-028)]
 B$9850,8;44 #HTML[#UDGARRAY1,7,4,1;$9850-$9857-8(interior-tiles-029)]
 B$9858,8;44 #HTML[#UDGARRAY1,7,4,1;$9858-$985F-8(interior-tiles-030)]
 B$9860,8;44 #HTML[#UDGARRAY1,7,4,1;$9860-$9867-8(interior-tiles-031)]
 B$9868,8;44 #HTML[#UDGARRAY1,7,4,1;$9868-$986F-8(interior-tiles-032)]
 B$9870,8;44 #HTML[#UDGARRAY1,7,4,1;$9870-$9877-8(interior-tiles-033)]
 B$9878,8;44 #HTML[#UDGARRAY1,7,4,1;$9878-$987F-8(interior-tiles-034)]
 B$9880,8;44 #HTML[#UDGARRAY1,7,4,1;$9880-$9887-8(interior-tiles-035)]
 B$9888,8;44 #HTML[#UDGARRAY1,7,4,1;$9888-$988F-8(interior-tiles-036)]
 B$9890,8;44 #HTML[#UDGARRAY1,7,4,1;$9890-$9897-8(interior-tiles-037)]
 B$9898,8;44 #HTML[#UDGARRAY1,7,4,1;$9898-$989F-8(interior-tiles-038)]
 B$98A0,8;44 #HTML[#UDGARRAY1,7,4,1;$98A0-$98A7-8(interior-tiles-039)]
 B$98A8,8;44 #HTML[#UDGARRAY1,7,4,1;$98A8-$98AF-8(interior-tiles-040)]
 B$98B0,8;44 #HTML[#UDGARRAY1,7,4,1;$98B0-$98B7-8(interior-tiles-041)]
 B$98B8,8;44 #HTML[#UDGARRAY1,7,4,1;$98B8-$98BF-8(interior-tiles-042)]
 B$98C0,8;44 #HTML[#UDGARRAY1,7,4,1;$98C0-$98C7-8(interior-tiles-043)]
 B$98C8,8;44 #HTML[#UDGARRAY1,7,4,1;$98C8-$98CF-8(interior-tiles-044)]
 B$98D0,8;44 #HTML[#UDGARRAY1,7,4,1;$98D0-$98D7-8(interior-tiles-045)]
 B$98D8,8;44 #HTML[#UDGARRAY1,7,4,1;$98D8-$98DF-8(interior-tiles-046)]
 B$98E0,8;44 #HTML[#UDGARRAY1,7,4,1;$98E0-$98E7-8(interior-tiles-047)]
 B$98E8,8;44 #HTML[#UDGARRAY1,7,4,1;$98E8-$98EF-8(interior-tiles-048)]
 B$98F0,8;44 #HTML[#UDGARRAY1,7,4,1;$98F0-$98F7-8(interior-tiles-049)]
 B$98F8,8;44 #HTML[#UDGARRAY1,7,4,1;$98F8-$98FF-8(interior-tiles-050)]
 B$9900,8;44 #HTML[#UDGARRAY1,7,4,1;$9900-$9907-8(interior-tiles-051)]
 B$9908,8;44 #HTML[#UDGARRAY1,7,4,1;$9908-$990F-8(interior-tiles-052)]
 B$9910,8;44 #HTML[#UDGARRAY1,7,4,1;$9910-$9917-8(interior-tiles-053)]
 B$9918,8;44 #HTML[#UDGARRAY1,7,4,1;$9918-$991F-8(interior-tiles-054)]
 B$9920,8;44 #HTML[#UDGARRAY1,7,4,1;$9920-$9927-8(interior-tiles-055)]
 B$9928,8;44 #HTML[#UDGARRAY1,7,4,1;$9928-$992F-8(interior-tiles-056)]
 B$9930,8;44 #HTML[#UDGARRAY1,7,4,1;$9930-$9937-8(interior-tiles-057)]
 B$9938,8;44 #HTML[#UDGARRAY1,7,4,1;$9938-$993F-8(interior-tiles-058)]
 B$9940,8;44 #HTML[#UDGARRAY1,7,4,1;$9940-$9947-8(interior-tiles-059)]
 B$9948,8;44 #HTML[#UDGARRAY1,7,4,1;$9948-$994F-8(interior-tiles-060)]
 B$9950,8;44 #HTML[#UDGARRAY1,7,4,1;$9950-$9957-8(interior-tiles-061)]
 B$9958,8;44 #HTML[#UDGARRAY1,7,4,1;$9958-$995F-8(interior-tiles-062)]
 B$9960,8;44 #HTML[#UDGARRAY1,7,4,1;$9960-$9967-8(interior-tiles-063)]
 B$9968,8;44 #HTML[#UDGARRAY1,7,4,1;$9968-$996F-8(interior-tiles-064)]
 B$9970,8;44 #HTML[#UDGARRAY1,7,4,1;$9970-$9977-8(interior-tiles-065)]
 B$9978,8;44 #HTML[#UDGARRAY1,7,4,1;$9978-$997F-8(interior-tiles-066)]
 B$9980,8;44 #HTML[#UDGARRAY1,7,4,1;$9980-$9987-8(interior-tiles-067)]
 B$9988,8;44 #HTML[#UDGARRAY1,7,4,1;$9988-$998F-8(interior-tiles-068)]
 B$9990,8;44 #HTML[#UDGARRAY1,7,4,1;$9990-$9997-8(interior-tiles-069)]
 B$9998,8;44 #HTML[#UDGARRAY1,7,4,1;$9998-$999F-8(interior-tiles-070)]
 B$99A0,8;44 #HTML[#UDGARRAY1,7,4,1;$99A0-$99A7-8(interior-tiles-071)]
 B$99A8,8;44 #HTML[#UDGARRAY1,7,4,1;$99A8-$99AF-8(interior-tiles-072)]
 B$99B0,8;44 #HTML[#UDGARRAY1,7,4,1;$99B0-$99B7-8(interior-tiles-073)]
 B$99B8,8;44 #HTML[#UDGARRAY1,7,4,1;$99B8-$99BF-8(interior-tiles-074)]
 B$99C0,8;44 #HTML[#UDGARRAY1,7,4,1;$99C0-$99C7-8(interior-tiles-075)]
 B$99C8,8;44 #HTML[#UDGARRAY1,7,4,1;$99C8-$99CF-8(interior-tiles-076)]
 B$99D0,8;44 #HTML[#UDGARRAY1,7,4,1;$99D0-$99D7-8(interior-tiles-077)]
 B$99D8,8;44 #HTML[#UDGARRAY1,7,4,1;$99D8-$99DF-8(interior-tiles-078)]
 B$99E0,8;44 #HTML[#UDGARRAY1,7,4,1;$99E0-$99E7-8(interior-tiles-079)]
 B$99E8,8;44 #HTML[#UDGARRAY1,7,4,1;$99E8-$99EF-8(interior-tiles-080)]
 B$99F0,8;44 #HTML[#UDGARRAY1,7,4,1;$99F0-$99F7-8(interior-tiles-081)]
 B$99F8,8;44 #HTML[#UDGARRAY1,7,4,1;$99F8-$99FF-8(interior-tiles-082)]
 B$9A00,8;44 #HTML[#UDGARRAY1,7,4,1;$9A00-$9A07-8(interior-tiles-083)]
 B$9A08,8;44 #HTML[#UDGARRAY1,7,4,1;$9A08-$9A0F-8(interior-tiles-084)]
 B$9A10,8;44 #HTML[#UDGARRAY1,7,4,1;$9A10-$9A17-8(interior-tiles-085)]
 B$9A18,8;44 #HTML[#UDGARRAY1,7,4,1;$9A18-$9A1F-8(interior-tiles-086)]
 B$9A20,8;44 #HTML[#UDGARRAY1,7,4,1;$9A20-$9A27-8(interior-tiles-087)]
 B$9A28,8;44 #HTML[#UDGARRAY1,7,4,1;$9A28-$9A2F-8(interior-tiles-088)]
 B$9A30,8;44 #HTML[#UDGARRAY1,7,4,1;$9A30-$9A37-8(interior-tiles-089)]
 B$9A38,8;44 #HTML[#UDGARRAY1,7,4,1;$9A38-$9A3F-8(interior-tiles-090)]
 B$9A40,8;44 #HTML[#UDGARRAY1,7,4,1;$9A40-$9A47-8(interior-tiles-091)]
 B$9A48,8;44 #HTML[#UDGARRAY1,7,4,1;$9A48-$9A4F-8(interior-tiles-092)]
 B$9A50,8;44 #HTML[#UDGARRAY1,7,4,1;$9A50-$9A57-8(interior-tiles-093)]
 B$9A58,8;44 #HTML[#UDGARRAY1,7,4,1;$9A58-$9A5F-8(interior-tiles-094)]
 B$9A60,8;44 #HTML[#UDGARRAY1,7,4,1;$9A60-$9A67-8(interior-tiles-095)]
 B$9A68,8;44 #HTML[#UDGARRAY1,7,4,1;$9A68-$9A6F-8(interior-tiles-096)]
 B$9A70,8;44 #HTML[#UDGARRAY1,7,4,1;$9A70-$9A77-8(interior-tiles-097)]
 B$9A78,8;44 #HTML[#UDGARRAY1,7,4,1;$9A78-$9A7F-8(interior-tiles-098)]
 B$9A80,8;44 #HTML[#UDGARRAY1,7,4,1;$9A80-$9A87-8(interior-tiles-099)]
 B$9A88,8;44 #HTML[#UDGARRAY1,7,4,1;$9A88-$9A8F-8(interior-tiles-100)]
 B$9A90,8;44 #HTML[#UDGARRAY1,7,4,1;$9A90-$9A97-8(interior-tiles-101)]
 B$9A98,8;44 #HTML[#UDGARRAY1,7,4,1;$9A98-$9A9F-8(interior-tiles-102)]
 B$9AA0,8;44 #HTML[#UDGARRAY1,7,4,1;$9AA0-$9AA7-8(interior-tiles-103)]
 B$9AA8,8;44 #HTML[#UDGARRAY1,7,4,1;$9AA8-$9AAF-8(interior-tiles-104)]
 B$9AB0,8;44 #HTML[#UDGARRAY1,7,4,1;$9AB0-$9AB7-8(interior-tiles-105)]
 B$9AB8,8;44 #HTML[#UDGARRAY1,7,4,1;$9AB8-$9ABF-8(interior-tiles-106)]
 B$9AC0,8;44 #HTML[#UDGARRAY1,7,4,1;$9AC0-$9AC7-8(interior-tiles-107)]
 B$9AC8,8;44 #HTML[#UDGARRAY1,7,4,1;$9AC8-$9ACF-8(interior-tiles-108)]
 B$9AD0,8;44 #HTML[#UDGARRAY1,7,4,1;$9AD0-$9AD7-8(interior-tiles-109)]
 B$9AD8,8;44 #HTML[#UDGARRAY1,7,4,1;$9AD8-$9ADF-8(interior-tiles-110)]
 B$9AE0,8;44 #HTML[#UDGARRAY1,7,4,1;$9AE0-$9AE7-8(interior-tiles-111)]
 B$9AE8,8;44 #HTML[#UDGARRAY1,7,4,1;$9AE8-$9AEF-8(interior-tiles-112)]
 B$9AF0,8;44 #HTML[#UDGARRAY1,7,4,1;$9AF0-$9AF7-8(interior-tiles-113)]
 B$9AF8,8;44 #HTML[#UDGARRAY1,7,4,1;$9AF8-$9AFF-8(interior-tiles-114)]
 B$9B00,8;44 #HTML[#UDGARRAY1,7,4,1;$9B00-$9B07-8(interior-tiles-115)]
 B$9B08,8;44 #HTML[#UDGARRAY1,7,4,1;$9B08-$9B0F-8(interior-tiles-116)]
 B$9B10,8;44 #HTML[#UDGARRAY1,7,4,1;$9B10-$9B17-8(interior-tiles-117)]
 B$9B18,8;44 #HTML[#UDGARRAY1,7,4,1;$9B18-$9B1F-8(interior-tiles-118)]
 B$9B20,8;44 #HTML[#UDGARRAY1,7,4,1;$9B20-$9B27-8(interior-tiles-119)]
 B$9B28,8;44 #HTML[#UDGARRAY1,7,4,1;$9B28-$9B2F-8(interior-tiles-120)]
 B$9B30,8;44 #HTML[#UDGARRAY1,7,4,1;$9B30-$9B37-8(interior-tiles-121)]
 B$9B38,8;44 #HTML[#UDGARRAY1,7,4,1;$9B38-$9B3F-8(interior-tiles-122)]
 B$9B40,8;44 #HTML[#UDGARRAY1,7,4,1;$9B40-$9B47-8(interior-tiles-123)]
 B$9B48,8;44 #HTML[#UDGARRAY1,7,4,1;$9B48-$9B4F-8(interior-tiles-124)]
 B$9B50,8;44 #HTML[#UDGARRAY1,7,4,1;$9B50-$9B57-8(interior-tiles-125)]
 B$9B58,8;44 #HTML[#UDGARRAY1,7,4,1;$9B58-$9B5F-8(interior-tiles-126)]
 B$9B60,8;44 #HTML[#UDGARRAY1,7,4,1;$9B60-$9B67-8(interior-tiles-127)]
 B$9B68,8;44 #HTML[#UDGARRAY1,7,4,1;$9B68-$9B6F-8(interior-tiles-128)]
 B$9B70,8;44 #HTML[#UDGARRAY1,7,4,1;$9B70-$9B77-8(interior-tiles-129)]
 B$9B78,8;44 #HTML[#UDGARRAY1,7,4,1;$9B78-$9B7F-8(interior-tiles-130)]
 B$9B80,8;44 #HTML[#UDGARRAY1,7,4,1;$9B80-$9B87-8(interior-tiles-131)]
 B$9B88,8;44 #HTML[#UDGARRAY1,7,4,1;$9B88-$9B8F-8(interior-tiles-132)]
 B$9B90,8;44 #HTML[#UDGARRAY1,7,4,1;$9B90-$9B97-8(interior-tiles-133)]
 B$9B98,8;44 #HTML[#UDGARRAY1,7,4,1;$9B98-$9B9F-8(interior-tiles-134)]
 B$9BA0,8;44 #HTML[#UDGARRAY1,7,4,1;$9BA0-$9BA7-8(interior-tiles-135)]
 B$9BA8,8;44 #HTML[#UDGARRAY1,7,4,1;$9BA8-$9BAF-8(interior-tiles-136)]
 B$9BB0,8;44 #HTML[#UDGARRAY1,7,4,1;$9BB0-$9BB7-8(interior-tiles-137)]
 B$9BB8,8;44 #HTML[#UDGARRAY1,7,4,1;$9BB8-$9BBF-8(interior-tiles-138)]
 B$9BC0,8;44 #HTML[#UDGARRAY1,7,4,1;$9BC0-$9BC7-8(interior-tiles-139)]
 B$9BC8,8;44 #HTML[#UDGARRAY1,7,4,1;$9BC8-$9BCF-8(interior-tiles-140)]
 B$9BD0,8;44 #HTML[#UDGARRAY1,7,4,1;$9BD0-$9BD7-8(interior-tiles-141)]
 B$9BD8,8;44 #HTML[#UDGARRAY1,7,4,1;$9BD8-$9BDF-8(interior-tiles-142)]
 B$9BE0,8;44 #HTML[#UDGARRAY1,7,4,1;$9BE0-$9BE7-8(interior-tiles-143)]
 B$9BE8,8;44 #HTML[#UDGARRAY1,7,4,1;$9BE8-$9BEF-8(interior-tiles-144)]
 B$9BF0,8;44 #HTML[#UDGARRAY1,7,4,1;$9BF0-$9BF7-8(interior-tiles-145)]
 B$9BF8,8;44 #HTML[#UDGARRAY1,7,4,1;$9BF8-$9BFF-8(interior-tiles-146)]
 B$9C00,8;44 #HTML[#UDGARRAY1,7,4,1;$9C00-$9C07-8(interior-tiles-147)]
 B$9C08,8;44 #HTML[#UDGARRAY1,7,4,1;$9C08-$9C0F-8(interior-tiles-148)]
 B$9C10,8;44 #HTML[#UDGARRAY1,7,4,1;$9C10-$9C17-8(interior-tiles-149)]
 B$9C18,8;44 #HTML[#UDGARRAY1,7,4,1;$9C18-$9C1F-8(interior-tiles-150)]
 B$9C20,8;44 #HTML[#UDGARRAY1,7,4,1;$9C20-$9C27-8(interior-tiles-151)]
 B$9C28,8;44 #HTML[#UDGARRAY1,7,4,1;$9C28-$9C2F-8(interior-tiles-152)]
 B$9C30,8;44 #HTML[#UDGARRAY1,7,4,1;$9C30-$9C37-8(interior-tiles-153)]
 B$9C38,8;44 #HTML[#UDGARRAY1,7,4,1;$9C38-$9C3F-8(interior-tiles-154)]
 B$9C40,8;44 #HTML[#UDGARRAY1,7,4,1;$9C40-$9C47-8(interior-tiles-155)]
 B$9C48,8;44 #HTML[#UDGARRAY1,7,4,1;$9C48-$9C4F-8(interior-tiles-156)]
 B$9C50,8;44 #HTML[#UDGARRAY1,7,4,1;$9C50-$9C57-8(interior-tiles-157)]
 B$9C58,8;44 #HTML[#UDGARRAY1,7,4,1;$9C58-$9C5F-8(interior-tiles-158)]
 B$9C60,8;44 #HTML[#UDGARRAY1,7,4,1;$9C60-$9C67-8(interior-tiles-159)]
 B$9C68,8;44 #HTML[#UDGARRAY1,7,4,1;$9C68-$9C6F-8(interior-tiles-160)]
 B$9C70,8;44 #HTML[#UDGARRAY1,7,4,1;$9C70-$9C77-8(interior-tiles-161)]
 B$9C78,8;44 #HTML[#UDGARRAY1,7,4,1;$9C78-$9C7F-8(interior-tiles-162)]
 B$9C80,8;44 #HTML[#UDGARRAY1,7,4,1;$9C80-$9C87-8(interior-tiles-163)]
 B$9C88,8;44 #HTML[#UDGARRAY1,7,4,1;$9C88-$9C8F-8(interior-tiles-164)]
 B$9C90,8;44 #HTML[#UDGARRAY1,7,4,1;$9C90-$9C97-8(interior-tiles-165)]
 B$9C98,8;44 #HTML[#UDGARRAY1,7,4,1;$9C98-$9C9F-8(interior-tiles-166)]
 B$9CA0,8;44 #HTML[#UDGARRAY1,7,4,1;$9CA0-$9CA7-8(interior-tiles-167)]
 B$9CA8,8;44 #HTML[#UDGARRAY1,7,4,1;$9CA8-$9CAF-8(interior-tiles-168)]
 B$9CB0,8;44 #HTML[#UDGARRAY1,7,4,1;$9CB0-$9CB7-8(interior-tiles-169)]
 B$9CB8,8;44 #HTML[#UDGARRAY1,7,4,1;$9CB8-$9CBF-8(interior-tiles-170)]
 B$9CC0,8;44 #HTML[#UDGARRAY1,7,4,1;$9CC0-$9CC7-8(interior-tiles-171)]
 B$9CC8,8;44 #HTML[#UDGARRAY1,7,4,1;$9CC8-$9CCF-8(interior-tiles-172)]
 B$9CD0,8;44 #HTML[#UDGARRAY1,7,4,1;$9CD0-$9CD7-8(interior-tiles-173)]
 B$9CD8,8;44 #HTML[#UDGARRAY1,7,4,1;$9CD8-$9CDF-8(interior-tiles-174)]
 B$9CE0,8;44 #HTML[#UDGARRAY1,7,4,1;$9CE0-$9CE7-8(interior-tiles-175)]
 B$9CE8,8;44 #HTML[#UDGARRAY1,7,4,1;$9CE8-$9CEF-8(interior-tiles-176)]
 B$9CF0,8;44 #HTML[#UDGARRAY1,7,4,1;$9CF0-$9CF7-8(interior-tiles-177)]
 B$9CF8,8;44 #HTML[#UDGARRAY1,7,4,1;$9CF8-$9CFF-8(interior-tiles-178)]
 B$9D00,8;44 #HTML[#UDGARRAY1,7,4,1;$9D00-$9D07-8(interior-tiles-179)]
 B$9D08,8;44 #HTML[#UDGARRAY1,7,4,1;$9D08-$9D0F-8(interior-tiles-180)]
 B$9D10,8;44 #HTML[#UDGARRAY1,7,4,1;$9D10-$9D17-8(interior-tiles-181)]
 B$9D18,8;44 #HTML[#UDGARRAY1,7,4,1;$9D18-$9D1F-8(interior-tiles-182)]
 B$9D20,8;44 #HTML[#UDGARRAY1,7,4,1;$9D20-$9D27-8(interior-tiles-183)]
 B$9D28,8;44 #HTML[#UDGARRAY1,7,4,1;$9D28-$9D2F-8(interior-tiles-184)]
 B$9D30,8;44 #HTML[#UDGARRAY1,7,4,1;$9D30-$9D37-8(interior-tiles-185)]
 B$9D38,8;44 #HTML[#UDGARRAY1,7,4,1;$9D38-$9D3F-8(interior-tiles-186)]
 B$9D40,8;44 #HTML[#UDGARRAY1,7,4,1;$9D40-$9D47-8(interior-tiles-187)]
 B$9D48,8;44 #HTML[#UDGARRAY1,7,4,1;$9D48-$9D4F-8(interior-tiles-188)]
 B$9D50,8;44 #HTML[#UDGARRAY1,7,4,1;$9D50-$9D57-8(interior-tiles-189)]
 B$9D58,8;44 #HTML[#UDGARRAY1,7,4,1;$9D58-$9D5F-8(interior-tiles-190)]
 B$9D60,8;44 #HTML[#UDGARRAY1,7,4,1;$9D60-$9D67-8(interior-tiles-191)]
 B$9D68,8;44 #HTML[#UDGARRAY1,7,4,1;$9D68-$9D6F-8(interior-tiles-192)]
 B$9D70,8;44 #HTML[#UDGARRAY1,7,4,1;$9D70-$9D77-8(interior-tiles-193)]

; Main loop setup.
;
; Used by the routine at #R$F163.
; .
; There seems to be litle point in this: enter_room terminates with 'goto
; main_loop' so it never returns. In fact, the single calling routine (main)
; might just as well goto enter_room instead of goto main_loop_setup.
@label=main_loop_setup
cC$9D78,3;21 The hero enters a room - returns via squash_stack_goto_main

; Main game loop.
;
; Used by the routine at #R$691A.
@label=main_loop
cC$9D7B,3;21 Check morale level, report if (near) zero and inhibit player control if exhausted
 C$9D7E,3;21 Check for a BREAK keypress
 C$9D81,3;21 Incrementally wipe and display queued game messages
 C$9D84,3;21 Process player input
 C$9D87,3;21 Check the hero's map position and colour the flag accordingly
 C$9D8A,3;21 Paint any tiles occupied by visible characters with tiles from tile_buf
 C$9D8D,3;21 Move characters around
 C$9D90,3;21 Make characters follow the hero if he's being suspicious
 C$9D93,3;21 Run through all visible characters, resetting them if they're off-screen
 C$9D96,3;21 Spawn characters
 C$9D99,3;21 Mark nearby items
 C$9D9C,3;21 Ring the alarm bell (1)
 C$9D9F,3;21 Animate all visible characters
 C$9DA2,3;21 Move the map when the hero walks
 C$9DA5,3;21 Incrementally wipe and display queued game messages
 C$9DA8,3;21 Ring the alarm bell (2)
 C$9DAB,3;21 Plot vischars and items in order
 C$9DAE,3;21 Plot the game screen
 C$9DB1,3;21 Ring the alarm bell (3)
 C$9DB4,3;21 {If the nighttime flag is set, turns white screen elements light blue and tracks the hero with a searchlight
 C$9DB7,1;21
 C$9DB8,3;21 }
 C$9DBB,3;21 {If the global current room index is non-zero then slow the game down with a delay loop
 C$9DBE,1;21
 C$9DBF,3;21 }
 C$9DC2,3;21 Wave the morale flag
 C$9DC5,3;21 {Dispatch a timed event event once every 64 ticks of the game counter
 C$9DC8,2;21
 C$9DCA,3;21 }
 C$9DCD,2;21 ...loop forever

; Check morale level, report if (near) zero and inhibit player control if exhausted.
;
; Used by the routine at #R$9D7B.
@label=check_morale
cC$9DCF,3;21 {If morale is greater than one then return
 C$9DD2,2;21
 C$9DD4,1;21 }
 C$9DD5,3;21 {Queue the message "MORALE IS ZERO"
 C$9DD8,3;21 }
 C$9DDB,2;21 {Set the "morale exhausted" flag to inhibit player input
 C$9DDD,3;21 }
 C$9DE0,1;21 {Immediately take automatic control of the hero
 C$9DE1,3;21 }
 C$9DE4,1;21 Return

; Check for a BREAK keypress.
;
; Used by the routine at #R$9D7B.
; .
; If pressed then clear the screen and confirm with the player that they want
; to reset the game. Reset if requested.
@label=keyscan_break
cC$9DE5,3;21 {If shift or space are not pressed then return
 C$9DE8,11;21
 C$9DF3,1;21 }
 C$9DF4,3;21 Reset the screen
 C$9DF7,3;21 Wait for the player to press 'Y' or 'N'
 C$9DFA,3;21 If 'Y' was pressed (Z set) then reset the game
 C$9DFD,3;21 {If the global current room index is room_0_OUTDOORS then
 C$9E00,1;21
 C$9E01,3;21 !(Reset the hero's position, redraw the scene, then zoombox it onto the screen) and return}
 C$9E04,3;21 The hero enters a room - returns via squash_stack_goto_main

; Process player input.
;
; Used by the routine at #R$9D7B.
;
; .
;
@label=process_player_input
; Morale exhausted? If so then don't allow input.
cC$9E07,3;21 Simultaneously load the in_solitary and morale_exhausted flags
 C$9E0A,1;21 {Return if either is set. This inhibits the player's control
 C$9E0B,2;21
 C$9E0D,1;21 }
 C$9E0E,3;21 {Is the hero is picking a lock, or cutting wire?
 C$9E11,2;21 }
 C$9E13,2;21 Jump if not
; Hero is picking a lock, or cutting through a wire fence.
 C$9E15,3;21 {Postpone automatic control for 31 turns of this routine
 C$9E18,2;21 }
 C$9E1A,2;21 Is the hero picking a lock?
 C$9E1C,3;21 Jump to picking_lock if so
 C$9E1F,3;21 Jump to cutting_wire otherwise
@label=process_player_input_no_flags
*C$9E22,3;21 Call the input routine. Input is returned in #REGa. (Note: The routine lives at same address as static_tiles_plot_direction)
 C$9E25,3;21 Take address of the automatic player counter
 C$9E28,2;21 Did the input routine return input_NONE? (zero)
 C$9E2A,3;21 Jump if not
; No user input was received: count down the automatic player counter
 C$9E2D,1;21 {If the automatic player counter is zero then return
 C$9E2E,1;21
 C$9E2F,1;21 }
 C$9E30,1;21 Decrement the automatic player counter
 C$9E31,1;21 Set input to input_NONE
 C$9E32,2;21 Jump to end bit
@label=process_player_input_received
; User input was received.
; .
; Postpone automatic control for 31 turns.
*C$9E34,2;21 Set the automatic player counter to 31
 C$9E36,1;21 Bank input routine result
 C$9E37,3;21 Load hero in bed flag
 C$9E3A,1;21 Is it zero?
 C$9E3B,2;21 Jump to 'hero was in bed' case if not
 C$9E3D,3;21 Load hero at breakfast flag
 C$9E40,1;21 Is it zero?
 C$9E41,2;21 Jump to 'not bed or breakfast' case if so
; Hero was at breakfast: make him stand up
 C$9E43,3;21 {Set hero's route to 43, step 0
 C$9E46,3;21 }
 C$9E49,3;21 {Set hero's (x,y) pos to (52,62)
 C$9E4C,4;21
 C$9E50,2;21 }
 C$9E52,3;21 {Set room definition 25's bench_G object to interiorobject_EMPTY_BENCH
 C$9E55,2;21 }
 C$9E57,3;21 Point #REGhl at hero at breakfast flag
 C$9E5A,2;21 Jump to common part
@label=process_player_input_in_bed
; Hero was in bed: make him get up
*C$9E5C,3;21 {Set hero's route to 44, step 1
 C$9E5F,3;21 }
 C$9E62,3;21 {Set hero's target (x,y) to (46,46)
@nowarn
 C$9E65,3;21 }
 C$9E68,2;21 {Set hero's (x,y) pos to (46,46)
 C$9E6A,3;21
 C$9E6D,3;21 }
 C$9E70,2;21 {Set hero's height to 24
 C$9E72,3;21 }
 C$9E75,3;21 {Set room definition 2's bed object to interiorobject_EMPTY_BED
 C$9E78,2;21 }
 C$9E7A,3;21 Point #REGhl at hero in bed flag
@label=process_player_input_common
*C$9E7D,2;21 Clear the hero at breakfast / hero in bed flag
 C$9E7F,3;21 Expand out the room definition for room_index
 C$9E82,3;21 Expand all of the tile indices in the tiles buffer to full tiles in the screen buffer
@label=process_player_input_check_fire
*C$9E85,1;21 Unbank input routine result
 C$9E86,2;21 Was fire pressed?
 C$9E88,2;21 Jump if not
 C$9E8A,3;21 Check for 'pick up', 'drop' and 'use' input events
 C$9E8D,2;21 Set #REGa to input_KICK ($80)
; If input state has changed then kick a sprite update.
@label=process_player_input_set_kick
@nowarn
*C$9E8F,3;21 {Did the input state change from the hero's existing input?
 C$9E92,1;21 }
 C$9E93,1;21 Return if not
 C$9E94,2;21 {Kick a sprite update if it did
 C$9E96,1;21 }
 C$9E97,1;21 Return

; Locks the player out until the lock is picked.
;
; Used by the routine at #R$9E07.
@label=picking_lock
cC$9E98,3;21 {Return unless player_locked_out_until becomes equal to game_counter
 C$9E9B,4;21
 C$9E9F,1;21 }
; Countdown reached: Unlock the door.
 C$9EA0,3;21 {Clear door_LOCKED ($80) from the door whose lock is being picked
 C$9EA3,2;21 }
 C$9EA5,2;21 {Queue the message "IT IS OPEN"
 C$9EA7,3;21 }
; This entry point is used by the routine at #R$9EB2.
@label=clear_lockpick_wirecut_flags_and_return
*C$9EAA,3;21 {Clear the vischar_FLAGS_PICKING_LOCK and vischar_FLAGS_CUTTING_WIRE flags
 C$9EAD,3;21
 C$9EB0,1;21 }
 C$9EB1,1;21 Return

; Locks the player out until the wire is snipped.
;
; Used by the routine at #R$9E07.
@label=cutting_wire
cC$9EB2,3;21 {How much longer do we have to wait until the wire cutting is complete?
 C$9EB5,3;21
 C$9EB8,1;21 }
 C$9EB9,2;21 Jump if the countdown reached zero
 C$9EBB,2;21 {Return if greater than 3
 C$9EBD,1;21 }
@nowarn
 C$9EBE,3;21 Read current direction
@nowarn
 C$9EC1,3;21 Point at cutting_wire_new_inputs
 C$9EC4,2;21 Mask off direction part
 C$9EC6,1;21 {Look that up in cutting_wire_new_inputs
 C$9EC7,4;21
*C$9ECB,1;21 }
@nowarn
 C$9ECC,3;21 Save new input
 C$9ECF,1;21 Return
; Countdown reached zero: Snip the wire.
@label=cutting_wire_complete
@nowarn
*C$9ED0,3;21 Point #REGhl at hero's direction field
; Bug: An LD A,(HL) instruction is missing here. #REGa is always zero at this point from above, so $800E is always set to zero. The hero will always face top-left (direction_TOP_LEFT is 0) after breaking through a fence.
; Note that the DOS x86 version moves zero into $800E - it has no AND - hardcoding the bug.
 C$9ED3,3;21
 C$9ED6,1;21 {Set vischar.input to input_KICK
 C$9ED7,2;21 }
 C$9ED9,2;21 {Set vischar height to 24
 C$9EDB,3;21 }
 C$9EDE,2;21 Jump to clear_lockpick_wirecut_flags_and_return
; New inputs table.
@label=cutting_wire_new_inputs
 B$9EE0,1;21 input_UP   + input_LEFT  + input_KICK
 B$9EE1,1;21 input_UP   + input_RIGHT + input_KICK
 B$9EE2,1;21 input_DOWN + input_RIGHT + input_KICK
 B$9EE3,1;21 input_DOWN + input_LEFT  + input_KICK

; Maps route indices to arrays of valid rooms or areas.
;
; #R$9F21 uses this to check if the hero is in an area permitted for the
; current route.
@label=route_to_permitted
bB$9EE4,3;40 (Route 42: #R$9EF9)
 B$9EE7,3;40 (Route  5: #R$9EFC)
 B$9EEA,3;40 (Route 14: #R$9F01)
 B$9EED,3;40 (Route 16: #R$9F08)
 B$9EF0,3;40 (Route 44: #R$9F0E)
 B$9EF3,3;40 (Route 43: #R$9F11)
 B$9EF6,3;40 (Route 45: #R$9F13)
; Seven variable-length arrays which encode a list of valid rooms (if top bit
; is set) or permitted areas (0, 1 or 2) for a given route and step within the
; route. Terminated with $FF.
; .
; Note that while routes encode transitions _between_ rooms this table encodes
; individual rooms or areas, so each list here will be one entry longer than
; the corresponding route.
; .
; In the table: R => Room, A => Area
 B$9EF9,3;40 ( R2, R2,                    $FF)
 B$9EFC,5;40 ( R3, A1,  A1,  A1,          $FF)
 B$9F01,7;40 ( A1, A1,  A1,  A0,  A2, A2, $FF)
 B$9F08,6;40 ( A1, A1, R21, R23, R25,     $FF)
 B$9F0E,3;40 ( R3, R2,                    $FF)
 B$9F11,2;40 (R25,                        $FF)
 B$9F13,2;40 ( A1,                        $FF)

; Boundings of the three main exterior areas.
@label=permitted_bounds
bB$9F15,4;28 Corridor to exercise yard
 B$9F19,4;28 Hut area
 B$9F1D,4;28 Exercise yard area

; Check the hero's map position and colour the flag accordingly.
;
; Used by the routine at #R$9D7B.
@label=in_permitted_area
cC$9F21,3;21 Point #REGhl at the hero's vischar position
 C$9F24,3;21 Point #REGde at the hero's map position
 C$9F27,3;21 Get the global current room index
 C$9F2A,1;21 Is it indoors?
 C$9F2B,3;21 Jump if so
; Outdoors.
 C$9F2E,3;21 Scale down the vischar position and assign result to the hero's map position
 C$9F31,3;21 {If the hero's isometric x position is 217 * 8 or higher...
 C$9F34,5;21
 C$9F39,3;21 jump to "hero has escaped"}
 C$9F3C,3;21 {If the hero's isometric y position is 137 * 8 or higher...
 C$9F3F,5;21
 C$9F44,3;21 jump to "hero has escaped"}
 C$9F47,2;21 Otherwise jump over the indoors handling
; Indoors.
*C$9F49,2;21 {Copy position across
 C$9F4B,4;21
 C$9F4F,2;21 }
; Set the flag red if picking a lock, or cutting wire.
*C$9F51,3;21 Read hero's vischar flags
 C$9F54,2;21 AND the flags with (vischar_FLAGS_PICKING_LOCK OR vischar_FLAGS_CUTTING_WIRE)
 C$9F56,3;21 If either of those flags is set then set the morale flag red
; Is it night time?
 C$9F59,3;21 Read the game time
 C$9F5C,2;21 If it's 100 or higher then it's night time
 C$9F5E,2;21 Jump if it's not night time
; At night, home room is the only safe place.
@label=night_time
 C$9F60,3;21 What room are we in?
 C$9F63,2;21 Is it the home room: room_2_HUT2LEFT?
 C$9F65,3;21 Jump to set_flag_green if so
 C$9F68,3;21 Otherwise jump to set_flag_red
; If in solitary then bypass all checks.
@label=day_time
*C$9F6B,3;21 {Are we in solitary?
 C$9F6E,1;21 }
 C$9F6F,3;21 Jump to set_flag_green if we are
 C$9F72,3;21 Point #REGhl at the hero's vischar route
 C$9F75,1;21 Load the route index
 C$9F76,1;21 {Load the route step
 C$9F77,1;21 }
 C$9F78,2;21 Is the route index's route_REVERSED flag set? ($80)
 C$9F7A,2;21 Jump if not
 C$9F7C,1;21 Otherwise increment the route step
*C$9F7D,2;21 Is the route index routeindex_255_WANDER? ($FF)
 C$9F7F,2;21 Jump if not
 C$9F81,1;21 {Load the route step again and clear its bottom three bits
 C$9F82,2;21 }
 C$9F84,2;21 {If step is 8 then set #REGa to 1 (hut area)
 C$9F86,4;21
 C$9F8A,2;21 otherwise set #REGa to 2 (exercise yard area)}
*C$9F8C,3;21 Check that the hero is in the specified room or camp bounds
 C$9F8F,2;21 If within the permitted area (Z set) goto set_flag_green
 C$9F91,2;21 Otherwise goto set_flag_red
; Check regular routes against route_to_permitted.
*C$9F93,2;21 Mask off the route_REVERSED flag
 C$9F95,3;21 Point #REGhl at route_to_permitted[]
 C$9F98,2;21 Set #REGb for seven iterations
; Start loop
*C$9F9A,1;21 {Does the first byte of the entry match the route index?
 C$9F9B,1;21 }
 C$9F9C,2;21 Jump if so
 C$9F9E,1;21 {Otherwise move to the next entry
 C$9F9F,1;21 }
 C$9FA0,2;21 ...loop
 C$9FA2,2;21 Route index wasn't found in the table - jump to set_flag_green
@label=found
*C$9FA4,1;21 {Load #REGde with the sub-table's address
 C$9FA5,1;21
 C$9FA6,1;21 }
 C$9FA7,1;21 {Move it into #REGhl
 C$9FA8,1;21 }
 C$9FA9,2;21 Zero #REGb so we can use #REGbc in the next instruction
 C$9FAB,1;21 {Fetch byte at HL[BC]
 C$9FAC,1;21 }
 C$9FAD,1;21 Save the sub-table's address
 C$9FAE,3;21 Check that the hero is in the specified room or camp bounds
 C$9FB1,1;21 Restore the sub-table address
 C$9FB2,2;21 If within the permitted area (Z set) jump to set_flag_green
 C$9FB4,3;21 Load the hero's vischar route index
 C$9FB7,2;21 {If the route index's route_REVERSED flag is set ($80)
 C$9FB9,2;21
 C$9FBB,1;21 move the sub-table pointer forward by a byte}
; Search through the list for (... CHECK)
*C$9FBC,3;21 Initialise index
; Start loop
*C$9FBF,1;21 Save index
 C$9FC0,1;21 Save sub-table address
 C$9FC1,1;21 {Fetch byte at HL[BC]
 C$9FC2,1;21 }
 C$9FC3,2;21 Did we hit the end of the list?
 C$9FC5,2;21 Jump to pop_and_set_flag_red if we did
 C$9FC7,3;21 Check that the hero is in the specified room or camp bounds
 C$9FCA,1;21 Restore the sub-table address
 C$9FCB,1;21 Restore the index
 C$9FCC,2;21 If within the area (Z set) break out of the loop
 C$9FCE,1;21 Increment counter
 C$9FCF,2;21 ...loop
@label=set_route_then_set_flag_green
*C$9FD1,3;21 {Fetch the hero's route index
 C$9FD4,1;21 }
 C$9FD5,3;21 Set the hero's route (to A,C) unless in solitary
 C$9FD8,2;21 Jump to set_flag_green
@label=pop_and_set_flag_red
*C$9FDA,1;21 {Restore the stack pointer position - don't care about order
 C$9FDB,1;21 }
 C$9FDC,2;21 Jump to set_flag_red
; Green flag code path.
@label=set_flag_green
*C$9FDE,1;21 Clear the red flag
 C$9FDF,2;21 Load #REGc with attribute_BRIGHT_GREEN_OVER_BLACK
@label=flag_select
*C$9FE1,3;21 Assign red_flag
 C$9FE4,1;21 Shuffle wanted attribute value into #REGa
 C$9FE5,3;21 Point #REGhl at the first attribute byte of the morale flag
 C$9FE8,1;21 Is the flag already the correct colour?
 C$9FE9,1;21 Return if so
 C$9FEA,2;21 Are we in the green flag case?
 C$9FEC,3;21 Exit via set_morale_flag_screen_attributes if not
 C$9FEF,2;21 {Silence the bell
 C$9FF1,3;21 }
 C$9FF4,1;21 Shuffle wanted attribute value into #REGa
 C$9FF5,3;21 Exit via set_morale_flag_screen_attributes
; Red flag code path.
@label=set_flag_red
*C$9FF8,2;21 Load #REGc with attribute_BRIGHT_RED_OVER_BLACK
 C$9FFA,3;21 Fetch the first attribute byte of the morale flag
 C$9FFD,1;21 Is the flag already the correct colour?
 C$9FFE,1;21 Return if so
 C$9FFF,1;21 {Set the vischar's input to 0
@nowarn
 C$A000,3;21 }
 C$A003,2;21 Set the red flag flag
 C$A005,2;21 Jump to flag_select

; Check that the hero is in the specified room or camp bounds.
;
; Used by the routine at #R$9F21.
;
; I:A  If bit 7 is set then bits 0..6 contain a room index. Otherwise it's an area index as passed into within_camp_bounds.
; O:F  Z set if in the permitted area.
@label=in_permitted_area_end_bit
cC$A007,3;21 Point #REGhl at the global current room index
 C$A00A,2;21 Was the permitted_route_ROOM flag set on entry? ($80)
 C$A00C,2;21 Jump if not
 C$A00E,2;21 Mask off the room flag
 C$A010,1;21 Does the specified room match the global current room index?
 C$A011,1;21 Return immediately with the result in flags
@label=end_bit_area
*C$A012,1;21 Bank A
 C$A013,1;21 Fetch the global current room index
 C$A014,1;21 Is it room_0_OUTDOORS? (0)
 C$A015,1;21 Return if not
 C$A016,3;21 Point #REGde at hero_map_position
 C$A019,1;21 Unbank A - restoring original A
; FALL THROUGH to within_camp_bounds.

; Is the specified position within the bounds of the indexed area?
;
; Used by the routine at #R$CB98.
;
; I:A  Index (0..2) into permitted_bounds[] table.
; I:DE Pointer to position (a TinyPos).
; O:F  Z set if position is within the area specified.
@label=within_camp_bounds
; Point #REGhl at permitted_bounds[A]
cC$A01A,1;21 {Multiply #REGa by 4
 C$A01B,1;21 }
 C$A01C,1;21 {Move it into #REGbc
 C$A01D,2;21 }
 C$A01F,3;21 Point #REGhl at permitted_bounds
 C$A022,1;21 Add
; Test position against bounds
 C$A023,2;21 Iterate twice - first checking the X axis, then the Y axis
; Start loop
*C$A025,1;21 Fetch a position byte
 C$A026,1;21 Is #REGa less than the lower bound?
 C$A027,1;21 Return with flags NZ if so (outside area)
 C$A028,1;21 Move to x1, or y1 on second iteration
 C$A029,1;21 Is #REGa less than the upper bound?
 C$A02A,2;21 Jump to the next loop iteration if so (inside area)
 C$A02C,2;21 {Otherwise return with flags NZ (outside area)
 C$A02E,1;21 }
*C$A02F,1;21 Advance to second axis for position
 C$A030,1;21 Advance to second axis for bounds
 C$A031,2;21 ...loop
 C$A033,1;21 {Return with flags Z (within area)
 C$A034,1;21 }

; Wave the morale flag.
;
; Used by the routines at #R$9D7B and #R$F4B7.
@label=wave_morale_flag
cC$A035,3;21 Point #REGhl at the game counter
 C$A038,1;21 Increment the game counter in-place
; Wave the flag on every other turn.
 C$A039,1;21 Now fetch the game counter
 C$A03A,2;21 Is its bottom bit set?
 C$A03C,1;21 Return if so
 C$A03D,1;21 Save the game counter pointer
 C$A03E,3;21 Fetch morale
 C$A041,3;21 Point #REGhl at currently displayed morale
 C$A044,1;21 Is the currently displayed morale different to the actual morale?
 C$A045,2;21 It's equal - jump straight to wiggling the flag
 C$A047,3;21 Actual morale exceeds displayed morale - jump to the increasing case
; Decreasing morale.
 C$A04A,1;21 Decrement displayed morale
 C$A04B,3;21 Get the current screen address of the morale flag
 C$A04E,3;21 Given a screen address, return the same position on the next scanline down
 C$A051,2;21 Jump over increasing morale block
; Increasing morale.
*C$A053,1;21 Increment displayed morale
 C$A054,3;21 Get the current screen address of the morale flag
 C$A057,3;21 Given a screen address, returns the same position on the next scanline up
*C$A05A,3;21 Set the screen address of the morale flag
; Wiggle and draw the flag.
*C$A05D,3;21 Point #REGde at bitmap_flag_down
 C$A060,1;21 Restore the game counter pointer
 C$A061,2;21 Is bit 1 set?
 C$A063,2;21 Skip next instruction if not
; Note that the last three rows of the bitmap_flag_up bitmap overlap with the
; first three of the bitmap_flag_down bitmap.
 C$A065,3;21 Point #REGde at bitmap_flag_up
*C$A068,3;21 Get the screen address of the morale flag
 C$A06B,3;21 Plot the flag always at 24x25 pixels in size
 C$A06E,3;21 exit via plot_bitmap

; Set the screen attributes of the morale flag.
;
; Used by the routines at #R$9F21 and #R$F163.
;
; I:A Screen attributes to use.
@label=set_morale_flag_screen_attributes
cC$A071,3;21 Point #REGhl at the top-left attribute byte of the morale flag
 C$A074,3;21 Set #REGde to the rowskip (32 attributes per row, minus 2)
 C$A077,2;21 The flag is 19 attributes high
; Start loop
*C$A079,1;21 {Write out three attribute bytes
 C$A07A,3;21
 C$A07D,1;21 }
 C$A07E,1;21 Move to next row
 C$A07F,2;21 ...loop
 C$A081,1;21 Return

; Given a screen address, returns the same position on the next scanline up.
;
; Spectrum screen memory addresses have the form:
; .
; #TABLE(default)
;   bit: { 15 | 14 | 13 | 12 | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 }
; field: { =c3 0-1-0 | =c2 Y7-Y6 | =c3 Y2-Y1-Y0 | =c3 Y5-Y4-Y3 | =c5 X4-X3-X2-X1-X0 }
; TABLE#
; .
; To calculate the address of the previous scanline (that is the next scanline
; higher up) we test two of the fields in sequence and subtract accordingly:
; .
; Y2-Y1-Y0: If this field is non-zero it's an easy case: we can just decrement
;           the top byte (e.g. using DEC H). Only the bottom three bits of Y
;           will be affected.
; .
; Y5-Y4-Y3: If this field is zero we can add $FFE0 (-32) to HL. This is like
;           adding "-1" to the register starting from bit 5 upwards. Since
;           Y2-Y1-Y0 and Y5-Y4-Y3 are both zero here we don't care about bits
;           propagating across boundaries.
; .
;           Otherwise we add $06E0 (0000 0110 1110 0000) to HL. This will add
;           111 binary or "-1" to the Y5-Y4-Y3 field, which will carry out into
;           Y0 for all possible values. Simultaneously it adds 110 binary or
;           "-2" to the Y2-Y1-Y0 field (all zeroes) so the complete field
;           becomes 111. Thus the complete field is decremented.
; .
; Used by the routine at #R$A035.
;
; I:HL Original screen address.
; O:HL Updated screen address.
@label=next_scanline_up
cC$A082,1;21 {If Y2-Y1-Y0 zero jump to the complicated case
 C$A083,2;21
 C$A085,2;21 }
; Easy case.
 C$A087,1;21 Just decrement the high byte of the address to go back a scanline
 C$A088,1;21 Return
; Complicated case.
*C$A089,3;21 Load #REGde with $06E0 by default
 C$A08C,1;21 {Is L < 32?
 C$A08D,2;21 }
 C$A08F,2;21 Jump if not
 C$A091,2;21 If so bits Y5-Y4-Y3 are clear. Load #REGde with $FFE0 (-32)
*C$A093,1;21 Add
 C$A094,1;21 Return

; Delay loop called only when the hero is indoors.
;
; Used by the routine at #R$9D7B.
@label=interior_delay_loop
cC$A095,3;21 {Count down from 4095
*C$A098,1;21
 C$A099,2;21
 C$A09B,2;21 }
 C$A09D,1;21 Return

; Ring the alarm bell.
;
; Used by the routine at #R$9D7B.
; .
; Called three times from main_loop.
@label=ring_bell
cC$A09E,3;21 Point #REGhl at bell ring counter/flag
 C$A0A1,1;21 Fetch its value
 C$A0A2,2;21 {If it's bell_STOP then return
 C$A0A4,1;21 }
 C$A0A5,1;21 {If it's bell_RING_PERPETUAL then jump over decrement code
 C$A0A6,2;21 }
; Decrement the ring counter.
 C$A0A8,1;21 {Decrement and store
 C$A0A9,1;21 }
 C$A0AA,2;21 If it didn't hit zero then jump over the stop code
; Counter hit zero - stop ringing.
 C$A0AC,2;21 {Stop the bell
 C$A0AE,1;21 }
 C$A0AF,1;21 Return
; Fetch visible state of bell from the screen.
*C$A0B0,3;21 Fetch the bell ringing graphic from the screen
 C$A0B3,2;21 Is it $3F? (63)
 C$A0B5,3;21 If so, jump to plot "off" code
@rfix-begin
 C$A0B8,3;21 Bug: Pointless jump to adjacent instruction
@rfix-end
; Plot UDG for the bell ringer "on" and make the bell sound
*C$A0BB,3;21 Point #REGde at bell_ringer_bitmap_on
 C$A0BE,3;21 Plot ringer
 C$A0C1,3;21 {Play the "bell ringing" sound, exiting via it
 C$A0C4,2;21 }
; Plot UDG for the bell ringer "off".
*C$A0C6,3;21 Point #REGde at bell_ringer_bitmap_on
; FALL THROUGH to plot_ringer.

; Plot ringer.
;
; Used by the routine at #R$A09E.
;
; I:HL Source bitmap.
@label=plot_ringer
cC$A0C9,3;21 Point #REGhl at screenaddr_bell_ringer
 C$A0CC,3;21 {Plot the bell always at 8x12 pixels in size, exiting via it
 C$A0CF,3;21 }

; Increase morale level.
;
; Used by the routines at #R$A0E9 and #R$A0F2.
;
; I:B Amount to increase morale level by. (Preserved)
@label=increase_morale
cC$A0D2,3;21 {Fetch morale level and add #REGb onto it
 C$A0D5,1;21 }
 C$A0D6,2;21 {Clamp morale level to morale_MAX (112)
 C$A0D8,2;21
 C$A0DA,2;21 }
; FALL THROUGH into set_morale.

; Set morale level.
;
; Used by the routines at #R$A0D2 and #R$A0E0.
;
; I:A Morale.
@label=set_morale
cC$A0DC,3;21 Set morale level to #REGa
 C$A0DF,1;21 Return

; Decrease morale level.
;
; Used by the routines at #R$A1D3, #R$AE78, #R$CB98 and #R$CD31.
;
; I:B Amount to decrease morale level by. (Preserved)
@label=decrease_morale
cC$A0E0,3;21 {Fetch morale level and subtract #REGb from it
 C$A0E3,1;21 }
 C$A0E4,2;21 {Clamp morale level to morale_MIN (0)
 C$A0E6,1;21 }
 C$A0E7,2;21 Jump to set_morale

; Increase morale by 10, score by 50.
;
; Used by the routines at #R$B107, #R$B387, #R$B3C4, #R$B3E1, #R$B3F6, #R$B4B8
; and #R$EFCB.
@label=increase_morale_by_10_score_by_50
cC$A0E9,2;21 {Increase morale by 10
 C$A0EB,3;21 }
 C$A0EE,2;21 {Increase score by 50, exiting via it
 C$A0F0,2;21 }

; Increase morale by 5, score by 5.
;
; Used by the routine at #R$7B36.
@label=increase_morale_by_5_score_by_5
cC$A0F2,2;21 {Increase morale by 5
 C$A0F4,3;21 }
 C$A0F7,2;21 Increase score by 5, exiting via it

; Increases the score then plots it.
;
; Used by the routines at #R$68F4, #R$A0E9 and #R$A0F2.
;
; I:B Amount to increase score by.
;
; Increment the score digit-wise until #REGb is zero.
@label=increase_score
cC$A0F9,2;21 Set #REGa to our base: 10
 C$A0FB,3;21 Point #REGhl at the last of the score digits
; Start loop
*C$A0FE,1;21 Save HL
@label=increment_score
*C$A0FF,1;21 Increment the pointed-to score digit by one
 C$A100,1;21 Has the pointed-to digit incremented to equal our base 10?
 C$A101,2;21 No - loop
 C$A103,2;21 Yes - reset the current digit to zero
 C$A105,1;21 Move to the next higher digit
 C$A106,2;21 "Recurse" - we'll arrive at the next instruction when we increment a digit which doesn't roll over
*C$A108,1;21 Restore HL
 C$A109,2;21 ...loop until the (score specified on entry) turns have been had
; FALL THROUGH into plot_score.

; Draws the current score to screen.
;
; Used by the routines at #R$B75A and #R$F163.
@label=plot_score
cC$A10B,3;21 Point #REGhl at the first of the score digits
 C$A10E,3;21 Point #REGde at the screen address of the score
 C$A111,2;21 Plot five digits
; Start loop
*C$A113,1;21 Save BC
 C$A114,3;21 Plot a single glyph pointed to by #REGhl at #REGde
 C$A117,1;21 Move to the next score digit
 C$A118,1;21 Move to the next character position (in addition to plot_glyph's increment)
 C$A119,1;21 Restore BC
 C$A11A,2;21 ...loop until all digits plotted
 C$A11C,1;21 Return

; Plays a sound.
;
; Used by the routines at #R$7B36, #R$7B8B, #R$A09E, #R$C4E0 and #R$CA81.
;
; I:B Number of iterations to play for.
; I:C Delay inbetween each iteration.
@label=play_speaker
cC$A11D,1;21 {Self-modify the delay loop at $A126
 C$A11E,3;21 }
 C$A121,2;21 Initially set the speaker bit on
; Start loop
*C$A123,2;21 Play the speaker (and set the border)
 C$A125,2;21 {Delay
*C$A127,1;21
 C$A128,2;21 }
 C$A12A,2;21 Toggle the speaker bit
 C$A12C,2;21 ...loop
 C$A12E,1;21 Return

; Game counter.
;
; Counts 00..FF then wraps.
; .
; Read-only by main_loop, picking_lock, cutting_wire, action_wiresnips,
; action_lockpick.
; .
; Write/read-write by wave_morale_flag.
@label=game_counter
gB$A12F,1

; Bell.
;
; #TABLE(default,centre)
; { =h Value | =h Meaning }
; { 0 | Ring indefinitely }
; { 255 | Don't ring }
; { N | Ring for N calls }
; TABLE#
; .
; Read-only by automatics.
; .
; Write/read-write by in_permitted_area, ring_bell, event_wake_up,
; event_go_to_roll_call, event_go_to_breakfast_time, event_breakfast_time,
; event_go_to_exercise_time, event_exercise_time, event_go_to_time_for_bed,
; searchlight_caught, solitary, guards_follow_suspicious_character,
; event_roll_call.
@label=bell
gB$A130,1

; Unreferenced byte.
uB$A131,1

; Score digits.
;
; Read-only by plot_score.
; .
; Write/read-write by increase_score, reset_game.
@label=score_digits
gB$A132,5

; 'Hero is at breakfast' flag.
;
; Write/read-write by process_player_input, end_of_breakfast,
; hero_sit_sleep_common.
@label=hero_in_breakfast
gB$A137,1

; 'Red morale flag' flag.
;
; #TABLE(default,centre)
; { =h Value | =h Meaning }
; { 0 | The hero is in a permitted area }
; { 255 | The hero is not in a permitted area }
; TABLE#
; .
; Read-only by automatics, guards_follow_suspicious_character.
; .
; Write/read-write by in_permitted_area.
@label=red_flag
gB$A138,1

; Automatic player counter.
;
; Counts down until zero at which point CPU control of the player is assumed.
; It's usually set to 31 by input events.
; .
; Read-only by touch, automatics, character_behaviour.
; .
; Write/read-write by check_morale, process_player_input,
; charevnt_hero_release, solitary.
@label=automatic_player_counter
gB$A139,1

; 'In solitary' flag.
;
; Stops set_hero_route working.
; .
; Used to set flag colour.
; .
; Read-only by process_player_input, in_permitted_area,
; set_hero_route, automatics.
; .
; Write/read-write by charevnt_solitary_ends, solitary.
@label=in_solitary
gB$A13A,1

; 'Morale exhausted' flag.
;
; Inhibits user input when non-zero.
; .
; Set by check_morale.
; .
; Reset by reset_game.
; .
; Read-only by process_player_input.
; .
; Write/read-write by check_morale.
@label=morale_exhausted
gB$A13B,1

; Remaining morale.
;
; Ranges morale_MIN..morale_MAX.
; .
; Read-only by check_morale, wave_morale_flag.
; .
; Write/read-write by increase_morale, decrease_morale, reset_game.
@label=morale
gB$A13C,1

; Game clock.
;
; Ranges 0..139.
; .
; Read-only by in_permitted_area.
; .
; Write/read-write by dispatch_timed_event, reset_map_and_characters.
@label=clock
gB$A13D,1

; 'Character index is valid' flag.
;
; In character_bed_state etc.: when non-zero, character_index is valid,
; otherwise IY points to character_struct.
; .
; Read-only by charevnt_bed, charevnt_breakfast.
; .
; Write/read-write by set_route, spawn_character, move_characters,
; automatics, set_route.
@label=entered_move_characters
gB$A13E,1

; 'Hero in bed' flag.
;
; Read-only by event_night_time,
; .
; Write/read-write by process_player_input, wake_up, hero_sit_sleep_common.
@label=hero_in_bed
gB$A13F,1

; Currently displayed morale.
;
; This lags behind actual morale while the flag moves steadily to its target.
; .
; Write/read-write by wave_morale_flag.
@label=displayed_morale
gB$A140,1

; Pointer to the screen address where the morale flag was last plotted.
;
; Write/read-write by wave_morale_flag.
@label=moraleflag_screen_address
gW$A141,2

; Address of door (in locked_doors[]) in which bit 7 is cleared when picked.
;
; Read-only by picking_lock.
; .
; Write/read-write by action_lockpick.
@label=ptr_to_door_being_lockpicked
gW$A143,2

; The game time when player control will be restored.
;
; e.g. when picking a lock or cutting wire.
; .
; Read-only by picking_lock, cutting_wire.
; .
; Write/read-write by action_wiresnips, action_lockpick.
@label=player_locked_out_until
gB$A145,1

; 'Night-time' flag.
;
; #TABLE(default,centre)
; { =h Value | =h Meaning }
; { 0 | Daytime }
; { 255 | Night-time }
; TABLE#
; .
; Read-only by main_loop, choose_game_window_attributes.
; .
; Write/read-write by set_day_or_night, reset_map_and_characters.
@label=day_or_night
gB$A146,1

; Bell ringer bitmaps.
;
; These are the bitmaps for the left hand side of the bell graphic which
; animates when the bell rings.
; .
; 8x12 pixels.
@label=bell_ringer_bitmap_off
bB$A147,1*12
@label=bell_ringer_bitmap_on
 B$A153,1*12

; Set game window attributes.
;
; Used by the routines at #R$7B36, #R$7B8B, #R$A1D3, #R$A50B, #R$B83B and
; #R$F350.
; .
; Starting at $5847, set 23 columns of 16 rows to the specified attribute byte.
;
; I:A Attribute byte.
@label=set_game_window_attributes
cC$A15F,3;21 Point #REGhl at the top-left game window attribute
 C$A162,2;21 Set rows to 16
 C$A164,3;21 Set rowskip to 9 (32 - 23 columns)
; Start loop
*C$A167,2;21 Set columns to 23
; Start loop
*C$A169,1;21 Set attribute byte
 C$A16A,1;21 Step to the next
 C$A16B,2;21 ...loop
 C$A16D,1;21 Add rowskip
 C$A16E,1;21 Decrement row counter
 C$A16F,3;21 ...loop
 C$A172,1;21 Return

; Timed events.
;
; Array of 15 structures which map game times to event handlers.
@label=timed_events
bB$A173,3;24 (   0, event_another_day_dawns ),
 B$A176,3;24 (   8, event_wake_up ),
 B$A179,3;24 (  12, event_new_red_cross_parcel ),
 B$A17C,3;24 (  16, event_go_to_roll_call ),
 B$A17F,3;24 (  20, event_roll_call ),
 B$A182,3;24 (  21, event_go_to_breakfast_time ),
 B$A185,3;24 (  36, event_breakfast_time ),
 B$A188,3;24 (  46, event_go_to_exercise_time ),
 B$A18B,3;24 (  64, event_exercise_time ),
 B$A18E,3;24 (  74, event_go_to_roll_call ),
 B$A191,3;24 (  78, event_roll_call ),
 B$A194,3;24 (  79, event_go_to_time_for_bed ),
 B$A197,3;24 (  98, event_time_for_bed ),
 B$A19A,3;24 ( 100, event_night_time ),
 B$A19D,3;24 ( 130, event_search_light ),

; Dispatch timed events.
;
; Used by the routine at #R$9D7B.
; .
; Dispatches time-based game events like parcels, meals, exercise and roll
; calls.
;
; .
;
; Increment the clock, wrapping at 140.
@label=dispatch_timed_event
cC$A1A0,3;21 Point #REGhl at the game clock
 C$A1A3,1;21 Load the game clock
 C$A1A4,1;21 ...and increment it
 C$A1A5,2;21 {If it hits 140 then reset it to zero
 C$A1A7,2;21
 C$A1A9,1;21 }
*C$A1AA,1;21 Then save the game clock back
; Find an event for the current clock
 C$A1AB,3;21 Point #REGhl at the timed events table
 C$A1AE,2;21 There are fifteen timed events
; Start loop
@label=find_event
*C$A1B0,1;21 {Does the current event's time match the game clock?
 C$A1B1,1;21 }
 C$A1B2,2;21 Jump to setup event handler if so
 C$A1B4,1;21 {Skip the event handler address
 C$A1B5,1;21 }
 C$A1B6,2;21 ...loop
 C$A1B8,1;21 Return with no event matched
; Found an event
@label=event_found
*C$A1B9,1;21 {Read the event handler address into #REGhl
 C$A1BA,2;21
 C$A1BC,1;21 }
; Most events need to sound the bell, so prepare for that
 C$A1BD,2;21 Set #REGa to bell_RING_40_TIMES
 C$A1BF,3;21 Point #REGbc at bell
 C$A1C2,1;21 Jump to the event handler

; Event: Night time.
@label=event_night_time
cC$A1C3,3;21 {Is the hero already in his bed?
 C$A1C6,1;21 }
 C$A1C7,2;21 Skip route setting if so
 C$A1C9,3;21 {If not in bed set the hero's route to (routeindex_44_HUT2_RIGHT_TO_LEFT, 1)
 C$A1CC,3;21 to make him move to bed}
*C$A1CF,2;21 Set the night time flag ($FF)
 C$A1D1,2;21 Jump to set_attrs

; Event: Another day dawns.
@label=event_another_day_dawns
cC$A1D3,2;21 {Queue the message "ANOTHER DAY DAWNS"
 C$A1D5,3;21 }
 C$A1D8,2;21 {Decrease morale by 25
 C$A1DA,3;21 }
 C$A1DD,1;21 Clear the night time flag
; This entry point is used by the routine at #R$A1C3.
@label=set_attrs
*C$A1DE,3;21 Set the day_or_night flag to #REGa
 C$A1E1,3;21 Choose game window attributes
 C$A1E4,3;21 Exit via set_game_window_attributes

; Event: Wake up.
@label=event_wake_up
cC$A1E7,1;21 Ring the bell 40 times as passed in
 C$A1E8,2;21 {Queue the message "TIME TO WAKE UP"
 C$A1EA,3;21 }
 C$A1ED,3;21 Exit via wake_up

; Event: Go to roll call.
@label=event_go_to_roll_call
cC$A1F0,1;21 Ring the bell 40 times as passed in
 C$A1F1,2;21 {Queue the nessage "ROLL CALL"
 C$A1F3,3;21 }
 C$A1F6,3;21 Exit via go_to_roll_call

; Event: Go to breakfast time.
@label=event_go_to_breakfast_time
cC$A1F9,1;21 Ring the bell 40 times as passed in
 C$A1FA,2;21 {Queue the message "BREAKFAST TIME"
 C$A1FC,3;21 }
 C$A1FF,3;21 Exit via set_route_go_to_breakfast

; Event: Breakfast time.
@label=event_breakfast_time
cC$A202,1;21 Ring the bell 40 times as passed in
 C$A203,3;21 Exit via end_of_breakfast

; Event: Go to exercise time.
@label=event_go_to_exercise_time
cC$A206,1;21 Ring the bell 40 times as passed in
 C$A207,2;21 {Queue the message "EXERCISE TIME"
 C$A209,3;21 }
 C$A20C,3;21 {Unlock the gates to the exercise yard
 C$A20F,3;21 }
 C$A212,3;21 Exit via set_route_go_to_yard

; Event: Exercise time.
@label=event_exercise_time
cC$A215,1;21 Ring the bell 40 times as passed in
 C$A216,3;21 Exit via set_route_go_to_yard_reversed

; Event: Go to time for bed.
@label=event_go_to_time_for_bed
cC$A219,1;21 Ring the bell 40 times as passed in
 C$A21A,3;21 {Lock the gates to the exercise yard
 C$A21D,3;21 }
 C$A220,2;21 {Queue the message "TIME FOR BED"
 C$A222,3;21 }
 C$A225,3;21 Exit via go_to_time_for_bed

; Event: New red cross parcel.
;
; .
;
; .
;
@label=event_new_red_cross_parcel
; Don't deliver a new red cross parcel while the previous one still exists.
cC$A228,3;24 Fetch the red cross parcel's room (and flags)
 C$A22B,2;24 Mask off the room part
 C$A22D,2;24 Is it $3F? (i.e. room_NONE ($FF) masked)
 C$A22F,1;24 Return if not
; Select the contents of the next parcel; choosing the first item from the list
; which does not already exist.
@nowarn
 C$A230,3;24 Point #REGde at the red cross parcel contents list
 C$A233,2;24 There are four entries in the list
; Start loop
*C$A235,1;24 Fetch item number
 C$A236,3;24 Turn it into an itemstruct
 C$A239,1;24 {Get its room and mask it
 C$A23A,1;24
 C$A23B,2;24 }
 C$A23D,2;24 Is it $3F? (i.e. room_NONE ($FF) masked)
 C$A23F,2;24 Jump to parcel_found if so
 C$A241,1;24
 C$A242,2;24 ...loop while (...)
 C$A244,1;24 Return - a parcel could not be spawned
@label=parcel_found
*C$A245,1;24 {Set red_cross_parcel_current_contents to the item number
 C$A246,3;24 }
 C$A249,3;24 {Copy the red cross parcel reset data over the red cross parcel item struct
@nowarn
 C$A24C,6;24
 C$A252,2;24 }
 C$A254,2;24 {Queue the message "RED CROSS PARCEL" and exit via
 C$A256,3;24 }
; Red cross parcel reset data.
@label=red_cross_parcel_reset_data
 B$A259,1;24 Room: room_20_REDCROSS
 B$A25A,3;24 TinyPos: (44, 44, 12)
 B$A25D,2;24 Coord: (128, 244)
; Red cross parcel contents list.
@label=red_cross_parcel_contents_list
 B$A25F,1;24 item_PURSE
 B$A260,1;24 item_WIRESNIPS
 B$A261,1;24 item_BRIBE
 B$A262,1;24 item_COMPASS

; Current contents of red cross parcel.
@label=red_cross_parcel_current_contents
gB$A263,1

; Event: Time for bed.
@label=event_time_for_bed
cC$A264,2;21 {Set route to (REVERSED routeindex_38_GUARD_12_BED, 3)
 C$A266,2;21 }
 C$A268,2;21 Jump to $A26E

; Event: Search light.
@label=event_search_light
cC$A26A,2;21 {Set route to (routeindex_38_GUARD_12_BED, 0)
 C$A26C,2;21 }
; This entry point is used by the routine at #R$A264.
; .
; Common end of event_time_for_bed and event_search_light. Sets the route for
; guards 12..15 to (#REGc + 0, #REGa)..(#REGc + 3, #REGa) respectively.
; .
; TODO: Split off to its own routine
@label=set_guards_route
*C$A26E,1;21 bank
 C$A26F,2;21 Set character index to character_12_GUARD_12
 C$A271,2;21 4 iterations
; Start loop
*C$A273,1;21
 C$A274,3;21 Set the route for a character in #REGa to route (#REGa', #REGc)
 C$A277,1;21
 C$A278,1;21 Increment the character index
 C$A279,1;21
 C$A27A,1;21 Increment the route index
 C$A27B,1;21
 C$A27C,2;21 ...loop
 C$A27E,1;21 Return

; List of non-player characters: six prisoners and four guards.
;
; Read-only by set_prisoners_and_guards_route,
; set_prisoners_and_guards_route_B.
@label=prisoners_and_guards
bB$A27F,1;21 character_12_GUARD_12
 B$A280,1;21 character_13_GUARD_13
 B$A281,1;21 character_20_PRISONER_1
 B$A282,1;21 character_21_PRISONER_2
 B$A283,1;21 character_22_PRISONER_3
 B$A284,1;21 character_14_GUARD_14
 B$A285,1;21 character_15_GUARD_15
 B$A286,1;21 character_23_PRISONER_4
 B$A287,1;21 character_24_PRISONER_5
 B$A288,1;21 character_25_PRISONER_6

; Wake up.
;
; Used by the routine at #R$A1E7.
@label=wake_up
cC$A289,3;21 {if (hero_in_bed) <% // odd that this jumps into a point which sets hero_in_bed to zero when it's already zero
 C$A28C,1;21
 C$A28D,3;21 }
; Hero gets out of bed.
 C$A290,3;21 {  $800F = 46; // hero's X position
 C$A293,2;21 }
 C$A295,1;21 {  $8011 = 46; %> // hero's Y position
 C$A296,1;21
 C$A297,2;21 }
*C$A299,1;21 {hero_in_bed = 0;
 C$A29A,3;21 }
 C$A29D,3;21 {set_hero_route(location_002A);
 C$A2A0,3;21 }
; Position all six prisoners.
 C$A2A3,3;21 HL = &characterstruct_20.room;
 C$A2A6,5
 C$A2AB,2;21 B = 3; // 3 iterations
*C$A2AD,1;21 do <% *HL = room_3_HUT2RIGHT;
 C$A2AE,1;21 HL += 7; // characterstruct stride
 C$A2AF,2;21 %> while (--B);
 C$A2B1,2
 C$A2B3,2;21 B = 3; // 3 iterations
*C$A2B5,1;21 do <% *HL = room_5_HUT3RIGHT;
 C$A2B6,1;21 HL += 7; // characterstruct stride
 C$A2B7,2;21 %> while (--B);
 C$A2B9,2;21 A = 5; // incremented by set_prisoners_and_guards_route_B
 C$A2BB,1
 C$A2BC,2;21 C = 0; // BC = 0
 C$A2BE,3;21 set_prisoners_and_guards_route_B();
; Update all the bed objects to be empty.
 C$A2C1,2
 C$A2C3,3;21 HL = &beds[0];
@bfix-begin
; Bug: Seven iterations are specified here BUT there are only six beds in the
; 'beds' array. This results in a spurious write to ROM location $1A42.
 C$A2C6,2;21 B = 7; // 7 iterations
@bfix+else
 $A2C6 LD B,$06      ; B = 6; // 6 iterations
@bfix+end
*C$A2C8,1;21 {do <% E = *HL++;
 C$A2C9,1;21 }
 C$A2CA,1;21 {  D = *HL++;
 C$A2CB,1;21 }
 C$A2CC,1;21 *DE = interiorobject_EMPTY_BED;
 C$A2CD,2;21 %> while (--B);
; Update the hero's bed object to be empty and redraw if required.
 C$A2CF,3;21 {room_2_hut2_left.bed = interiorobject_EMPTY_BED;
 C$A2D2,1;21 }
 C$A2D3,3;21 {if (room_index == room_0_OUTDOORS || room_index >= room_6) return;
 C$A2D6,4;21
 C$A2DA,1;21 }
 C$A2DB,3;21 setup_room();
 C$A2DE,3;21 plot_interior_tiles();
 C$A2E1,1;21 return;

; End of breakfast time.
;
; Used by the routine at #R$A202.
@label=end_of_breakfast
cC$A2E2,3;21 {if (hero_in_breakfast) <%
 C$A2E5,1;21
 C$A2E6,3;21 }
 C$A2E9,3;21 {  $800F = 52; // hero X position
 C$A2EC,2;21 }
 C$A2EE,1;21 {  $8011 = 62; %> // hero Y position
 C$A2EF,1;21
 C$A2F0,2;21 }
*C$A2F2,1;21 {hero_in_breakfast = 0;
 C$A2F3,3;21 }
 C$A2F6,3;21 {set_hero_route(location_0390);
 C$A2F9,3;21 }
 C$A2FC,3;21 HL = &characterstruct_20.room; // character_20_PRISONER_1
 C$A2FF,5
 C$A304,2;21 B = 3; // 3 iterations
*C$A306,1;21 do <% *HL = room_25_BREAKFAST;
 C$A307,1;21 HL += 7; // stride
 C$A308,2;21 %> while (--B);
 C$A30A,2
 C$A30C,2;21 B = 3; // 3 iterations
*C$A30E,1;21 do <% *HL = room_23_BREAKFAST;
 C$A30F,1;21 HL += 7; // stride
 C$A310,2;21 %> while (--B);
 C$A312,2;21 A = 144; // incremented by set_prisoners_and_guards_route_B
 C$A314,1
 C$A315,2;21 C = 3;
 C$A317,3;21 set_prisoners_and_guards_route_B();
 C$A31A,2
; Update all the benches to be empty.
 C$A31C,3;21 roomdef_23_breakfast.bench_A = interiorobject_EMPTY_BENCH;
 C$A31F,3;21 roomdef_23_breakfast.bench_B = interiorobject_EMPTY_BENCH;
 C$A322,3;21 roomdef_23_breakfast.bench_C = interiorobject_EMPTY_BENCH;
 C$A325,3;21 roomdef_25_breakfast.bench_D = interiorobject_EMPTY_BENCH;
 C$A328,3;21 roomdef_25_breakfast.bench_E = interiorobject_EMPTY_BENCH;
 C$A32B,3;21 roomdef_25_breakfast.bench_F = interiorobject_EMPTY_BENCH;
 C$A32E,3;21 roomdef_25_breakfast.bench_G = interiorobject_EMPTY_BENCH;
 C$A331,3;21 {if (room_index == room_0_OUTDOORS || room_index >= room_29_SECOND_TUNNEL_START) return;
 C$A334,4;21
 C$A338,1;21 }
 C$A339,3;21 setup_room();
 C$A33C,3;21 plot_interior_tiles(); return; // exit via // note that this differs to wake_up's ending

; Set the hero's route, unless in solitary.
;
; Used by the routines at #R$9F21, #R$A1C3, #R$A289, #R$A2E2, #R$A351, #R$A3F8,
; #R$A4A9, #R$A4B7, #R$A4C5, #R$A4D8 and #R$A4FD.
; .
;
; I:B Route index.
; I:C Route step.
@label=set_hero_route
cC$A33F,3;21 {if (in_solitary) return;
 C$A342,1;21
 C$A343,1;21 }
; This entry point is used by the routine at #R$C7C6.
*C$A344,3;21 {$8001 &= ~vischar_FLAGS_TARGET_IS_DOOR;
 C$A347,2;21 }
 C$A349,1;21 {$8002 = B;
 C$A34A,1;21 }
 C$A34B,1;21 {$8003 = C;
 C$A34C,1;21 }
 C$A34D,3;21 set_route();
 C$A350,1;21 return;

; Go to time for bed.
;
; Used by the routine at #R$A219.
@label=go_to_time_for_bed
cC$A351,3;21 {set_hero_route(location_0285);
 C$A354,3;21 }
 C$A357,2;21 Adash = 133;
 C$A359,1
 C$A35A,2;21 C = 2;
 C$A35C,3;21 set_prisoners_and_guards_route_B(); return; // exit via

; Set ascending routes for all characters in prisoners_and_guards.
;
; The route passed in (A',C) is assigned to the first character. The second character gets route (A'+1,C) and so on.
; .
; Used by the routine at #R$A4FD.
;
; I:A' Route index.
; I:C  Route step.
@label=set_prisoners_and_guards_route
cC$A35F,3;21 HL = &prisoners_and_guards[0];
 C$A362,2;21 B = 10;
*C$A364,1;21 do <%
 C$A365,1
 C$A366,1;21 A = *HL;
 C$A367,3;21 set_character_route();
 C$A36A,1;21 {
 C$A36B,1;21 Adash++;
 C$A36C,1;21 }
 C$A36D,2
 C$A36F,1;21 HL++;
 C$A370,2;21 %> while (--B);
 C$A372,1;21 return;

; Set the routes of all characters in prisoners_and_guards.
;
; The first half of the list (guards 12,13 and prisoners 1,2,3) are set to the route passed in (A',C). The second half of the list (guards 14,15 and prisoners 4,5,6) are set to route (A'+1,C).
; .
; Used by the routines at #R$A289, #R$A2E2, #R$A351, #R$A4A9, #R$A4B7 and
; #R$A4C5.
;
; I:A' Route index.
; I:C  Route step.
@label=set_prisoners_and_guards_route_B
cC$A373,3;21 HL = &prisoners_and_guards[0];
 C$A376,2;21 B = 10;
*C$A378,1;21 do <%
 C$A379,1
 C$A37A,1;21 A = *HL;
 C$A37B,3;21 set_character_route();
 C$A37E,1
; When this is 6, the character being processed is character_22_PRISONER_3 and
; the next is character_14_GUARD_14, the start of the second half of the list.
 C$A37F,1;21 {  if (B == 6) Adash++; // array index 6 is character
 C$A380,2;21 22
 C$A382,2;21
 C$A384,1
 C$A385,1;21
 C$A386,1;21 }
*C$A387,1
 C$A388,1;21 HL++;
 C$A389,2;21 %> while (--B);
 C$A38B,1;21 return;

; Set the route for a character.
;
; Used by the routines at #R$A26A, #R$A35F and #R$A373.
; .
; Finds a charstruct, or a vischar, and stores a route.
;
; I:A  Character index.
; I:A' Route index.
; I:C  Route step.
@label=set_character_route
cC$A38C,3;21 HL = get_character_struct(A);
 C$A38F,2;21 {if ((*HL & characterstruct_FLAG_DISABLED) == 0) goto not_set; // disabled?
 C$A391,3;21 }
 C$A394,1
 C$A395,1;21 {A = *HL & characterstruct_CHARACTER_MASK;
 C$A396,2;21 }
; Search non-player characters to see if this character is already on-screen.
 C$A398,2;21 B = 7; // 7 iterations
 C$A39A,3;21 DE = 32; // stride
@nowarn
 C$A39D,3;21 HL = $8020; // iterate over non-player characters
*C$A3A0,1;21 {do <% if (A == *HL) goto found;
 C$A3A1,2;21 }
 C$A3A3,1;21 HL += DE;
 C$A3A4,2;21 %> while (--B);
 C$A3A6,1
 C$A3A7,2;21 goto exit;
 B$A3A9,1;21 Unreferenced byte.
*C$A3AA,1;21 {not_set: HL += 5; // HL = charstruct->route
 C$A3AB,3;21
 C$A3AE,1;21 }
 C$A3AF,3;21 store_route();
*C$A3B2,1;21 exit: return;
*C$A3B3,1;21 found:
 C$A3B4,1;21 HL++;
 C$A3B5,2;21 {*HL++ &= ~vischar_FLAGS_TARGET_IS_DOOR;
 C$A3B7,1;21 }
 C$A3B8,3;21 store_route(); // HL = vischar->route
; FALL THROUGH into set_route.

; Not yet understood.
;
; Used by the routine at #R$A33F.
@label=set_route
cC$A3BB,1;21 {entered_move_characters = 0;
 C$A3BC,3;21 }
 C$A3BF,2
 C$A3C1,1;21 HL--;
 C$A3C2,3;21 get_target();
 C$A3C5,1;21 // DE = the HL stored at $A3C0
 C$A3C6,1;21 DE++;
 C$A3C7,2;21 *DE++ = *HL++; BC--;
 C$A3C9,2;21 *DE++ = *HL++; BC--;
 C$A3CB,2;21 {if (A == 255) <%
 C$A3CD,3;21 }
 C$A3D0,1;21 {  DE -= 6;
 C$A3D1,2;21
 C$A3D3,1;21 }
 C$A3D4,1;21 {  IY = DE;
 C$A3D5,2;21 }
 C$A3D7,1
 C$A3D8,1;21 {  HL += 2;
 C$A3D9,1;21 }
 C$A3DA,3;21 get_target_assign_pos();
 C$A3DD,1;21 // could have just ended the block here
 C$A3DE,1;21 return; %>
*C$A3DF,2;21 {else if (A == 128) <%
 C$A3E1,3;21 }
 C$A3E4,1;21 {  DE -= 5;
 C$A3E5,2;21
 C$A3E7,1;21 }
 C$A3E8,1
 C$A3E9,2;21 *HL |= vischar_FLAGS_TARGET_IS_DOOR; %> // sampled HL=$8001
*C$A3EB,1
 C$A3EC,1;21 return;

; Store an xy_t at the specified address.
;
; Used by the routine at #R$A38C.
;
; I:A' Route index.
; I:C  Route step.
; I:HL Pointer to route.
@label=store_route
cC$A3ED,1;21 {
 C$A3EE,1;21 *HL++ = Adash;
 C$A3EF,1;21
 C$A3F0,1;21 }
 C$A3F1,1;21 *HL = C;
 C$A3F2,1;21 return;

; entered_move_characters is non-zero.
;
; Used by the routine at #R$C7C6.
;
; I:HL Pointer to location.
@label=character_bed_state
cC$A3F3,3;21 A = character_index;
 C$A3F6,2;21 goto character_bed_common;

; entered_move_characters is zero.
;
; Used by the routine at #R$C7C6.
; .
; Gets hit when hero enters hut at end of day.
;
; I:HL Pointer to location.
@label=character_bed_vischar
cC$A3F8,3;21 A = IY[0]; // IY=$8000 // must be a character index
 C$A3FB,1;21 {if (A != 0) goto character_bed_common;
 C$A3FC,2;21 }
 C$A3FE,3;21 { set_hero_route(location_002C); // exit via
 C$A401,3;21 }

; Common end of above two routines.
;
; Used by the routines at #R$A3F3 and #R$A3F8.
@label=character_bed_common
cC$A404,1;21 {HL[1] = 0; // HL=$766B,$7672 characterstruct + 5 (characterstruct + 6 when zeroed)
 C$A405,2;21 }
 C$A407,2;21 {if (A > 19) <%
 C$A409,3;21
 C$A40C,3;21 }
 C$A40F,2;21 A -= 13; %> // 20.. => 7..
 C$A411,2;21 else <%
*C$A413,2;21 {  old_A = A; A = 13; if (old_A & (1<<0)) <% // tmp introduced to avoid interleaving
 C$A415,2;21
 C$A417,2;21 }
 C$A419,2;21 HL[1] = 1; // HL=$7681,$7673 // characterstruct_N + 6
 C$A41B,2;21 A |= 0x80; %> %>
*C$A41D,1;21 {HL[0] = A; // characterstruct_N + 5
 C$A41E,1;21 }
 C$A41F,1;21 return;

; Character sits.
;
; Used by the routine at #R$C7C6.
;
; I:A Character.
; I:HL Pointer to location.
@label=character_sits
cC$A420,2
 C$A422,2;21 A -= 18; // first three characters
 C$A424,3;21 HL = &roomdef_25_breakfast.bench_D;
 C$A427,2;21 {if (A >= 3) <% // second three characters
 C$A429,2;21 }
 C$A42B,3;21 HL = &roomdef_23_breakfast.bench_A;
 C$A42E,2;21 A -= 3; %>
; Poke object.
*C$A430,1;21 {HL += A * 3;
 C$A431,5;21
 C$A436,1;21 }
 C$A437,2;21 *HL = interiorobject_PRISONER_SAT_MID_TABLE;
 C$A439,1
 C$A43A,2;21 C = room_25_BREAKFAST;
 C$A43C,2;21 {if (A >= character_21_PRISONER_2) C = room_23_BREAKFAST;
 C$A43E,2;21
 C$A440,2;21 }
 C$A442,2;21 goto character_sit_sleep_common;

; Character sleeps.
;
; Used by the routine at #R$C7C6.
;
; I:A Character.
; I:HL Pointer to location.
@label=character_sleeps
cC$A444,1
 C$A445,2;21 {A -= 7;
 C$A447,1;21 }
 C$A448,1
; Poke object.
 C$A449,1;21 {BC = beds[A];
 C$A44A,8;21
 C$A452,1;21 }
 C$A453,2;21 {*BC = interiorobject_OCCUPIED_BED;
 C$A455,1;21 }
 C$A456,1
 C$A457,2;21 {if (A < character_10_GUARD_10)
 C$A459,3;21 }
 C$A45C,2;21 C = room_3_hut2_right;
 C$A45E,2;21 else
*C$A460,2;21 C = room_5_hut3_right;
; FALL THROUGH into character_sit_sleep_common.

; Common end of character sits/sleeps.
;
; Used by the routines at #R$A420 and #R$A444.
;
; .
;
; I:C Room.
; .
; I:DE Pointer to location.
@label=character_sit_sleep_common
cC$A462,1
 C$A463,2;21 *HL = 0;  // $8022, $76B8, $76BF, $76A3  (can be vischar OR characterstruct - weird)
 C$A465,1
 C$A466,3;21 {if (room_index != C) <%
 C$A469,1;21
 C$A46A,2;21 }
 C$A46C,1;21 {  HL -= 4;
 C$A46D,2;21
 C$A46F,1;21 }
 C$A470,2;21 *HL = 255;
 C$A472,1;21 return; %>
; Force a refresh.
*C$A473,1;21 {HL += 26;
 C$A474,2;21
 C$A476,1;21 }
 C$A477,2;21 *HL = 255;
; FALL THROUGH into select_room_and_plot.

; Select room and plot.
;
; Used by the routine at #R$A491.
@label=select_room_and_plot
cC$A479,3;21 select_room_and_plot: setup_room();
 C$A47C,3;21 plot_interior_tiles(); return;

; The hero sits.
;
; Used by the routine at #R$C7C6.
@label=hero_sits
cC$A47F,3;21 {roomdef_25_breakfast.bench_G = interiorobject_PRISONER_SAT_DOWN_END_TABLE;
 C$A482,2;21 }
 C$A484,3;21 HL = &hero_in_breakfast;
 C$A487,2;21 goto hero_sit_sleep_common;

; The hero sleeps.
;
; Used by the routines at #R$B75A and #R$C7C6.
@label=hero_sleeps
cC$A489,3;21 {roomdef_2_hut2_left.bed = interiorobject_OCCUPIED_BED;
 C$A48C,2;21 }
 C$A48E,3;21 HL = &hero_in_bed;
; FALL THROUGH into hero_sit_sleep_common.

; Common end of hero_sits/sleeps.
;
; Used by the routine at #R$A47F.
;
; I:HL Pointer to hero_in_breakfast or hero_in_bed.
@label=hero_sit_sleep_common
cC$A491,2;21 *HL = 0xFF; // set in breakfast, or in bed
 C$A493,1;21 A = 0;
 C$A494,3;21 {$8002 = A; // zero route index only
 C$A497,1;21 }
; Set hero's position to zero.
 C$A498,3;21 {memset($800F, 0, 4);
 C$A49B,2;21
*C$A49D,1;21
 C$A49E,1;21
 C$A49F,2;21 }
 C$A4A1,3;21 HL = $8000;
 C$A4A4,3;21 calc_vischar_iso_pos_from_vischar(); // reset hero
 C$A4A7,2;21 goto select_room_and_plot;

; Set hero's and prisoners_and_guards's routes to "go to yard".
;
; Used by the routine at #R$A206.
@label=set_route_go_to_yard
cC$A4A9,3;21 {set_hero_route(0x000E);
 C$A4AC,3;21 }
 C$A4AF,2;21 A = 0x0E;
 C$A4B1,1
 C$A4B2,2;21 C = 0;
 C$A4B4,3;21 set_prisoners_and_guards_route_B(); return; // exit via

; Set hero's and prisoners_and_guards's routes to "go to yard" reversed.
;
; Used by the routine at #R$A215.
@label=set_route_go_to_yard_reversed
cC$A4B7,3;21 {set_hero_route(0x048E);
 C$A4BA,3;21 }
 C$A4BD,2;21 A = 0x8E;
 C$A4BF,1
 C$A4C0,2;21 C = 4;
 C$A4C2,3;21 set_prisoners_and_guards_route_B(); return; // exit via

; Set hero's and prisoners_and_guards's routes to "go to breakfast".
;
; Used by the routine at #R$A1F9.
@label=set_route_go_to_breakfast
cC$A4C5,3;21 {set_hero_route(0x0010);
 C$A4C8,3;21 }
 C$A4CB,2;21 A = 0x10;
 C$A4CD,1
 C$A4CE,2;21 C = 0;
 C$A4D0,3;21 set_prisoners_and_guards_route_B(); return; // exit via

; entered_move_characters is non-zero (another one).
;
; Used by the routine at #R$C7C6.
; .
; Something character related [very similar to the routine at $A3F3].
@label=charevnt_breakfast_state
cC$A4D3,3;21 A = character_index;
 C$A4D6,2;21 goto $A4E4;

; entered_move_characters is zero (another one).
;
; Used by the routine at #R$C7C6.
@label=charevnt_breakfast_vischar
cC$A4D8,3;21 A = IY[0]; // character index
 C$A4DB,1;21 {if (A != character_0_COMMANDANT) goto charevnt_breakfast_common;
 C$A4DC,2;21 }
 C$A4DE,3;21 { set_hero_route(location_002B); // exit via
 C$A4E1,3;21 }

; Common end of above two routines.
;
; Used by the routines at #R$A4D3 and #R$A4D8.
;
; I:A Character.
; I:HL Pointer to location.
@label=charevnt_breakfast_common
cC$A4E4,1;21 {HL[1] = 0;
 C$A4E5,2;21 }
 C$A4E7,2;21 {if (A > 19) <% // change this to 20 and character_21? stands in place of a guard
 C$A4E9,3;21
 C$A4EC,3;21 }
 C$A4EF,2;21 tmp_A = A - 2; %> // seems to affect position at table 20.. => 18..
 C$A4F1,2;21 else <%
*C$A4F3,2
 C$A4F5,2;21 tmp_A = 24; // interleaved // guard character?
 C$A4F7,2;21 {  if (A & (1<<0)) tmp_A++; %>
 C$A4F9,1;21 }
*C$A4FA,1;21 {HL[0] = tmp_A;
 C$A4FB,1;21 }
 C$A4FC,1;21 return;

; Go to roll call.
;
; Used by the routine at #R$A1F0.
@label=go_to_roll_call
cC$A4FD,2;21 A = 26;
 C$A4FF,1
 C$A500,2;21 C = 0;
 C$A502,3;21 set_prisoners_and_guards_route();
 C$A505,3;21 {set_hero_route(location_002D);
 C$A508,3;21 }

; Reset the screen.
;
; Used by the routines at #R$9DE5 and #R$A51C.
@label=screen_reset
cC$A50B,3;21 wipe_visible_tiles();
 C$A50E,3;21 plot_interior_tiles();
 C$A511,3;21 zoombox();
 C$A514,3;21 plot_game_window();
 C$A517,2;21 A = attribute_WHITE_OVER_BLACK;
 C$A519,3;21 set_game_window_attributes(); return; // exit via

; Hero has escaped.
;
; Used by the routine at #R$9F21.
; .
; Print 'well done' message then test to see if the correct objects were used
; in the escape attempt.
@label=escaped
cC$A51C,3;21 screen_reset();
; Print standard prefix messages.
 C$A51F,3;21 HL = &escape_strings[0];
 C$A522,3;21 screenlocstring_plot(); // WELL DONE
 C$A525,3;21 screenlocstring_plot(); // YOU HAVE ESCAPED
 C$A528,3;21 screenlocstring_plot(); // FROM THE CAMP
; Form escape items bitfield.
 C$A52B,2;21 C = 0; // zero flag
 C$A52D,3;21 HL = &items_held[0];
 C$A530,3;21 join_item_to_escapeitem();
 C$A533,1;21 HL++; // &items_held[1];
 C$A534,3;21 join_item_to_escapeitem();
; Print item-tailored messages.
 C$A537,1;21 A = C;
 C$A538,2;21 {if (A == escapeitem_COMPASS + escapeitem_PURSE) goto success;
 C$A53A,2;21 }
 C$A53C,2;21 {else if (A != escapeitem_COMPASS + escapeitem_PAPERS) goto captured;
 C$A53E,2;21 }
@label=escaped_success
@nowarn
*C$A540,3;21 success: HL = &escape_strings[3];
 C$A543,3;21 screenlocstring_plot(); // AND WILL CROSS THE
 C$A546,3;21 screenlocstring_plot(); // BORDER SUCCESSFULLY
 C$A549,2;21 A = 0xFF; // success - reset game
 C$A54B,1
 C$A54C,2;21 goto press_any_key;
@label=escaped_captured
*C$A54E,1;21 captured:
@nowarn
 C$A54F,3;21 HL = &escape_strings[5];
 C$A552,3;21 screenlocstring_plot(); // BUT WERE RECAPTURED
 C$A555,2
 C$A557,2;21 {if (A >= escapeitem_UNIFORM) goto plot; // at least a uniform => 'but were recaptured' // bug? plotting twice
 C$A559,2;21 }
@nowarn
 C$A55B,3;21 HL = &escape_strings[7];
 C$A55E,1;21 {if (A == 0) goto plot; // no objects => 'totally unprepared'
 C$A55F,2;21 }
@nowarn
 C$A561,3;21 HL = &escape_strings[8];
 C$A564,2;21 {if ((A & escapeitem_COMPASS) == 0) goto plot; // no compass => 'totally lost'
 C$A566,2;21 }
@nowarn
 C$A568,3;21 HL = &escape_strings[9];
@label=escaped_plot
*C$A56B,3;21 plot: screenlocstring_plot();
@nowarn
@label=escaped_press_any_key
*C$A56E,3;21 press_any_key: HL = &escape_strings[10];
 C$A571,3;21 screenlocstring_plot(); // PRESS ANY KEY
; Wait for a keypress.
*C$A574,3;21 {do <% keyscan_all(); %> while (!Z); // down press
 C$A577,2;21 }
*C$A579,3;21 {do <% keyscan_all(); %> while (Z); // up press
 C$A57C,2;21 }
 C$A57E,1
; Reset the game, or send the hero to solitary.
 C$A57F,2;21 {if (A == 0xFF || A >= escapeitem_UNIFORM) <% reset_game(); return; %> // exit via
 C$A581,5;21
 C$A586,3;21 }
 C$A589,3;21 solitary(); return; // exit via

; Key scan of all ports.
;
; Used by the routine at #R$A51C.
;
; O:A Pressed key.
@label=keyscan_all
cC$A58C,3;21 BC = $FEFE;
*C$A58F,2;21 do <%
 C$A591,1;21 {  A = ~A & 0x1F;
 C$A592,2;21 }
 C$A594,1;21 if (A) return;
 C$A595,2;21 RLC B
 C$A597,3;21 %> while (carry);
 C$A59A,1;21 A = 0;
 C$A59B,1;21 return;

; Call item_to_escapeitem then merge result with a previous escapeitem.
;
; Used by the routine at #R$A51C.
;
; I:C  Previous return value.
; I:HL Pointer to (single) item slot.
; O:C  Previous return value + escapeitem_ flag.
@label=join_item_to_escapeitem
cC$A59C,1;21 A = *HL;
 C$A59D,3;21 item_to_escapeitem();
 C$A5A0,1;21 {C += A;
 C$A5A1,1;21 }
 C$A5A2,1;21 return;

; Return a bitmask indicating the presence of items required for escape.
;
; Used by the routine at #R$A59C.
;
; I:A Item.
; O:A Bitfield.
@label=item_to_escapeitem
cC$A5A3,2;21 {if (A == item_COMPASS) <% A = escapeitem_COMPASS; return;
 C$A5A5,2;21 %>
 C$A5A7,2;21
 C$A5A9,1;21 }
*C$A5AA,2;21 {if (A == item_PAPERS)  <% A = escapeitem_PAPERS; return;
 C$A5AC,2;21 %>
 C$A5AE,2;21
 C$A5B0,1;21 }
*C$A5B1,2;21 {if (A == item_PURSE)   <% A = escapeitem_PURSE; return;
 C$A5B3,2;21 %>
 C$A5B5,2;21
 C$A5B7,1;21 }
*C$A5B8,2;21 {if (A == item_UNIFORM) <% A = escapeitem_UNIFORM; return;
 C$A5BA,2;21 %>
 C$A5BC,1;21 }
 C$A5BD,1;21 A = 0; // have no required objects
 C$A5BE,1;21 return;

; Plot a screenlocstring.
;
; Used by the routines at #R$A51C, #R$EFFC and #R$F1E0.
;
; I:HL Pointer to screenlocstring.
; O:HL Pointer to byte after screenlocstring.
@label=screenlocstring_plot
cC$A5BF,1;21 {E = *HL++; // read screen address into DE
 C$A5C0,1;21 }
 C$A5C1,1;21 {D = *HL++;
 C$A5C2,1;21 }
 C$A5C3,1;21 {B = *HL++; // iterations / nbytes
 C$A5C4,1;21 }
*C$A5C5,1;21 do <%
 C$A5C6,3;21 plot_glyph();
 C$A5C9,1;21 HL++;
 C$A5CA,1
 C$A5CB,2;21 %> while (--B);
 C$A5CD,1;21 return;

; Escape messages.
@label=escape_strings
tB$A5CE,12;108 "WELL DONE"  [/ #HTML[#CALL:decode_screenlocstring($A5CE)]]
 B$A5DA,19;108 "YOU HAVE ESCAPED"  #HTML[/ #CALL:decode_screenlocstring($A5DA)]
 B$A5ED,16;108 "FROM THE CAMP"  #HTML[/ #CALL:decode_screenlocstring($A5ED)]
 B$A5FD,21;108 "AND WILL CROSS THE"  #HTML[/ #CALL:decode_screenlocstring($A5FD)]
 B$A612,22;108 "BORDER SUCCESSFULLY"  #HTML[/ #CALL:decode_screenlocstring($A612)]
 B$A628,22;108 "BUT WERE RECAPTURED"  #HTML[/ #CALL:decode_screenlocstring($A628)]
 B$A63E,20;108 "AND SHOT AS A SPY"  #HTML[/ #CALL:decode_screenlocstring($A63E)]
 B$A652,21;108 "TOTALLY UNPREPARED"  #HTML[/ #CALL:decode_screenlocstring($A652)]
 B$A667,15;108 "TOTALLY LOST"  #HTML[/ #CALL:decode_screenlocstring($A667)]
 B$A676,24;108 "DUE TO LACK OF PAPERS"  #HTML[/ #CALL:decode_screenlocstring($A676)]
 B$A68E,16;108 "PRESS ANY KEY"  #HTML[/ #CALL:decode_screenlocstring($A68E)]

; Bitmap font definition.
;
; 0..9, A..Z (omitting O), space, full stop
; .
; #UDGTABLE
; { #FONT$A69E,35,7,2{0,0,560,16}(font) }
; TABLE#
@label=bitmap_font
bB$A69E,8;44 0
 B$A6A6,8;44 1
 B$A6AE,8;44 2
 B$A6B6,8;44 3
 B$A6BE,8;44 4
 B$A6C6,8;44 5
 B$A6CE,8;44 6
 B$A6D6,8;44 7
 B$A6DE,8;44 8
 B$A6E6,8;44 9
 B$A6EE,8;44 A
 B$A6F6,8;44 B
 B$A6FE,8;44 C
 B$A706,8;44 D
 B$A70E,8;44 E
 B$A716,8;44 F
 B$A71E,8;44 G
 B$A726,8;44 H
 B$A72E,8;44 I
 B$A736,8;44 J
 B$A73E,8;44 K
 B$A746,8;44 L
 B$A74E,8;44 M
 B$A756,8;44 N
 B$A75E,8;44 P
 B$A766,8;44 Q
 B$A76E,8;44 R
 B$A776,8;44 S
 B$A77E,8;44 T
 B$A786,8;44 U
 B$A78E,8;44 V
 B$A796,8;44 W
 B$A79E,8;44 X
 B$A7A6,8;44 Y
 B$A7AE,8;44 Z
 B$A7B6,8;44 SPACE
 B$A7BE,8;44 FULL STOP

; An index used only by move_map().
@label=move_map_y
gB$A7C6,1

; Game window plotting offset.
@label=game_window_offset
gW$A7C7,2

; Get supertiles.
;
; Used by the routines at #R$A9E4, #R$AA05, #R$AA26, #R$AA4B, #R$AA6C, #R$AA8D
; and #R$B2FC.
; .
; Uses map_position to copy supertile indices from map into the buffer at
; $FF58.
;
; .
;
; Get vertical offset.
@label=get_supertiles
cC$A7C9,3;21 {A = (map_position >> 8) & 0xFC; // A = 0, 4, 8, 12, ...
 C$A7CC,2;21 }
; Multiply A by 13.5. (A is a multiple of 4, so this goes 0, 54, 108, 162, ...)
 C$A7CE,1;21 {HL = &map_tiles[-54] + (A + (A >> 1)) * 9; // must be skipping the first row.
 C$A7CF,10;21
*C$A7D9,1;21
 C$A7DA,8;21
 C$A7E2,1;21 }
; Add horizontal offset.
 C$A7E3,3;21 {HL += (map_position & 0xFF) >> 2;
 C$A7E6,7;21
 C$A7ED,1;21 }
; Populate map_buf with 7x5 array of supertile refs.
 C$A7EE,2;21 A = 5; // 5 iterations
 C$A7F0,3;21 DE = &map_buf[0];
*C$A7F3,2;21 {do <% memcpy(DE, HL, 7); DE += 7;
 C$A7F5,10;21
 C$A7FF,2;21 }
 C$A801,3;21 {  HL += 54; // stride - width of map
 C$A804,1;21 }
 C$A805,1;21 {%> while (--A);
 C$A806,3;21 }
 C$A809,1;21 return;

; Plot the complete bottommost row of tiles.
;
; Used by the routines at #R$AA26 and #R$AA4B.
@label=plot_bottommost_tiles
@nowarn
cC$A80A,3;21 DE = &tile_buf[24 * 16];
 C$A80D,1
@nowarn
 C$A80E,3;21 HLdash = &map_buf[28];
 C$A811,3;21 A = map_position >> 8; // map_position hi
@nowarn
 C$A814,3;21 DEdash = &window_buf[24 * 16 * 8];
 C$A817,2;21 goto plot_horizontal_tiles_common;

; Plot the complete topmost row of tiles.
;
; Used by the routines at #R$AA6C and #R$AA8D.
@label=plot_topmost_tiles
cC$A819,3;21 DE = &state->tile_buf[0];
 C$A81C,1
 C$A81D,3;21 HLdash = &state->map_buf[0];
 C$A820,3;21 A = map_position >> 8; // map_position hi
 C$A823,3;21 DEdash = &state->window_buf[0];

; Plotting supertiles.
;
; Used by the routine at #R$A80A.
@label=plot_horizontal_tiles_common
cC$A826,2;21 {A = (A & 3) * 4;
 C$A828,1;21
 C$A829,1;21 }
 C$A82A,3;21 ($A86A) = A; // self modify
 C$A82D,1;21 Cdash = A;
 C$A82E,3;21 {A = (map_position[0] & 3) + Cdash;
 C$A831,2;21
 C$A833,1;21 }
 C$A834,1
 C$A835,1;21 Adash = *HLdash;
 C$A836,1
; Initial edge.
 C$A837,1;21 {HL = &super_tiles[0] + Adash * 16;
 C$A838,9;21
 C$A841,1;21 }
 C$A842,1
 C$A843,1;21 A += L;
 C$A844,1;21 L = A;
 C$A845,2;21 {A = -A & 3;
 C$A847,2;21 }
 C$A849,2;21 {if (A == 0) A = 4;
 C$A84B,2;21 }
*C$A84D,1;21 B = A; // 1..4 iterations
*C$A84E,1;21 do <% A = *HL; // A = tile index
 C$A84F,1;21 *DE = A;
 C$A850,3;21 plot_tile();
 C$A853,1;21 HL++;
 C$A854,1;21 DE++;
 C$A855,2;21 %> while (--B);
 C$A857,1
 C$A858,1;21 HLdash++;
; Middle loop.
 C$A859,2;21 Bdash = 5; // 5 iterations
*C$A85B,1;21 do <% PUSH BCdash
 C$A85C,1;21 A = *HLdash;
 C$A85D,1
 C$A85E,1;21 {  HL = &super_tiles[A];
 C$A85F,9;21
 C$A868,1;21 }
 C$A869,2;21 A = 0; // self modified by $A82A
 C$A86B,1;21 {  L += A;
 C$A86C,1;21 }
 C$A86D,2;21 B = 4; // 4 iterations
*C$A86F,1;21 do <% A = *HL;
 C$A870,1;21 *DE = A;
 C$A871,3;21 plot_tile();
 C$A874,1;21 HL++;
 C$A875,1;21 DE++;
 C$A876,2;21 %> while (--B);
 C$A878,1
 C$A879,1;21 HLdash++;
 C$A87A,1;21 POP BCdash
 C$A87B,2;21 %> while (--Bdash);
; Trailing edge.
 C$A87D,1;21 A = Cdash; // assigned but never used?
 C$A87E,1;21 // unpaired?
 C$A87F,1;21 A = *HLdash;
 C$A880,1
 C$A881,1;21 {HL = &super_tiles[A];
 C$A882,9;21
 C$A88B,1;21 }
 C$A88C,3;21 A = ($A86A); // read self modified
 C$A88F,1;21 {L += A;
 C$A890,1;21 }
 C$A891,3;21 {A = map_position[0] & 3; // map_position lo
 C$A894,2;21 }
 C$A896,1;21 if (A == 0) return;
 C$A897,1;21 B = A;
*C$A898,1;21 do <% A = *HL;
 C$A899,1;21 *DE = A;
 C$A89A,3;21 plot_tile();
 C$A89D,1;21 HL++;
 C$A89E,1;21 DE++;
 C$A89F,2;21 %> while (--B);
 C$A8A1,1;21 return;

; Plot all tiles.
;
; Used by the routines at #R$7B36 and #R$B2FC.
; .
; Note: Exits with banked registers active.
@label=plot_all_tiles
cC$A8A2,3;21 DE = &tile_buf[0]; // visible tiles array
 C$A8A5,1
 C$A8A6,3;21 HLdash = &map_buf[0]; // 7x5 supertile refs
 C$A8A9,3;21 DEdash = &window_buf[0]; // screen buffer start address
 C$A8AC,3;21 A = map_position[0];
 C$A8AF,2;21 Bdash = 24; // 24 iterations (screen rows?)
*C$A8B1,1;21 do <% PUSH BCdash
 C$A8B2,1;21 PUSH DEdash
 C$A8B3,1;21 PUSH HLdash
 C$A8B4,1;21 PUSH AFdash
 C$A8B5,3
 C$A8B8,3;21 plot_vertical_tiles_common();
 C$A8BB,2
 C$A8BD,1;21 DE++;
 C$A8BE,2
 C$A8C0,1;21 POP HLdash
 C$A8C1,1;21 {  Cdash = ++A;
 C$A8C2,1;21 }
 C$A8C3,2;21 {  if ((A & 3) == 0) HLdash++;
 C$A8C5,2;21
 C$A8C7,1;21 }
*C$A8C8,1;21 A = Cdash;
 C$A8C9,1;21 POP DEdash
 C$A8CA,1;21 DEdash++;
 C$A8CB,1;21 POP BCdash
 C$A8CC,2;21 %> while (--Bdash);
 C$A8CE,1;21 return;

; Plot the complete rightmost column of tiles.
;
; Used by the routines at #R$A9E4 and #R$AA8D.
@label=plot_rightmost_tiles
@nowarn
cC$A8CF,3;21 DE = &tile_buf[23];
 C$A8D2,1;21 // unpaired
 C$A8D3,3;21 HL = &map_buf[6];
 C$A8D6,3;21 DE = &window_buf[23];
 C$A8D9,3;21 {A = map_position[0] & 3; // map_position lo
 C$A8DC,2;21 }
 C$A8DE,2;21 {if (A == 0) HL--;
 C$A8E0,1;21 }
*C$A8E1,3;21 {A = map_position[0] - 1; // map_position lo
 C$A8E4,1;21 }
 C$A8E5,2;21 goto plot_vertical_tiles_common;

; Plot the complete leftmost column of tiles.
;
; Used by the routines at #R$AA05 and #R$AA26.
@label=plot_leftmost_tiles
cC$A8E7,3;21 DE = &tile_buf[0]; // visible tiles array
 C$A8EA,1
 C$A8EB,3;21 HLdash = &map_buf[0]; // 7x5 supertile refs
 C$A8EE,3;21 DEdash = &window_buf[0]; // screen buffer start address
 C$A8F1,3;21 A = map_position[0]; // map_position lo

; Plotting vertical tiles (common part).
;
; The comments here assume banked registers on entry.
;
; Used by the routines at #R$A8A2 and #R$A8CF.
@label=plot_vertical_tiles_common
cC$A8F4,2;21 A &= 3;
 C$A8F6,3;21 ($A94C + 1) = A; // self modify
 C$A8F9,1;21 Cdash = A;
 C$A8FA,3;21 {A = ((map_position >> 8) & 3) * 4 + Cdash;
 C$A8FD,4;21
 C$A901,1;21 }
 C$A902,1
; Initial edge.
 C$A903,1;21 Adash = *HLdash;
 C$A904,1
 C$A905,1;21 {HL = &super_tiles[0] + Adash * 16; // supertiles
 C$A906,9;21
 C$A90F,1;21 }
 C$A910,1
 C$A911,1;21 A += L;
 C$A912,1;21 L = A;
 C$A913,1;21 RRA
 C$A914,1;21 RRA
 C$A915,2;21 {A = -(A & 3) & 3;
 C$A917,2;21
 C$A919,2;21 }
 C$A91B,2;21 {if (A == 0) A = 4;
 C$A91D,2;21 }
*C$A91F,1
 C$A920,3;21 BC = 24; // 24 iterations (screen rows?)
*C$A923,1;21 do <%
 C$A924,1;21 A = *DE;
 C$A925,1;21 *HL = A;
 C$A926,3;21 plot_tile_then_advance();
 C$A929,2;21 {  DE += 4; // stride
 C$A92B,1;21
 C$A92C,1;21 }
 C$A92D,1;21 HL += BC;
 C$A92E,1
 C$A92F,1;21 {%> while (--A);
 C$A930,3;21 }
 C$A933,2
 C$A935,1;21 {HL += 7;
 C$A936,5;21
 C$A93B,1;21 }
; Middle loop.
*C$A93C,2;21 B = 3; // 3 iterations
*C$A93E,1;21 do <%
 C$A93F,1;21 A = *HL;
 C$A940,1
 C$A941,1;21 {  HL = &super_tiles[0] + A * 16; // supertiles
 C$A942,9;21
 C$A94B,1;21 }
@label=supertile_plot_vertical_common_iters
 C$A94C,2;21 A = 0; // self modified by $A8F6
 C$A94E,1;21 A += L;
 C$A94F,1;21 L = A;
 C$A950,3;21 BC = 24; // stride
 C$A953,1
 C$A954,2;21 A = 4;
*C$A956,1;21 do <%
 C$A957,1;21 A = *DE;
 C$A958,1;21 *HL = A;
 C$A959,3;21 plot_tile_then_advance();
 C$A95C,1;21 HL += BC;
 C$A95D,2;21 {    DE += 4; // stride
 C$A95F,1;21
 C$A960,1;21 }
 C$A961,1
 C$A962,1;21 {  %> while (--A);
 C$A963,3;21 }
 C$A966,2
 C$A968,1;21 {  HL += 7;
 C$A969,5;21
 C$A96E,1;21 }
*C$A96F,1
 C$A970,2;21 %> while (--B);
; Trailing edge.
 C$A972,1;21 A = *HL;
 C$A973,1
 C$A974,1;21 {HL = &super_tiles[0] + A * 16; // supertiles
 C$A975,9;21
 C$A97E,1;21 }
 C$A97F,3;21 {HL += ($A94C + 1); // read self modified
 C$A982,1;21
 C$A983,1;21 }
 C$A984,3;21 {A = ((map_position >> 8) & 3) + 1;
 C$A987,2;21
 C$A989,1;21 }
 C$A98A,3;21 BC = 24; // stride
 C$A98D,1
*C$A98E,1;21 do <%
 C$A98F,1;21 A = *DE;
 C$A990,1;21 *HL = A;
 C$A991,3;21 plot_tile_then_advance();
 C$A994,2;21 A = 4;
 C$A996,1;21 A += E;
 C$A997,1;21 E = A;
 C$A998,1;21 HL += BC;
 C$A999,1
 C$A99A,1;21 {%> while (--A);
 C$A99B,3;21 }
 C$A99E,1
 C$A99F,1;21 return;

; Call plot_tile then advance DE' by a row.
;
; Used by the routine at #R$A8F4.
@label=plot_tile_then_advance
cC$A9A0,3;21 plot_tile();
 C$A9A3,1
 C$A9A4,1;21 {DEdash += 0xBF; // 0xBF = 24 * 8 - 1
 C$A9A5,5;21
 C$A9AA,1;21 }
*C$A9AB,1
 C$A9AC,1;21 return;

; Plot a tile then increment DE' by 1.
;
; Used by the routines at #R$A826 and #R$A9A0.
;
; I:A Tile index
; I:DE' Output buffer start address.
; I:HL' Pointer to supertile index (used to select the correct tile group).
@label=plot_tile
cC$A9AD,2
 C$A9AF,1;21 Adash = *HLdash; // get supertile index
 C$A9B0,3;21 BCdash = &exterior_tiles[0];
 C$A9B3,2;21 {if (Adash < 45) goto chosen;
 C$A9B5,2;21 }
 C$A9B7,3;21 BCdash = &exterior_tiles[145]; // set 2
 C$A9BA,2;21 {if (Adash < 139 || Adash >= 204) goto chosen;
 C$A9BC,4;21
 C$A9C0,2;21 }
 C$A9C2,3;21 BCdash = &exterior_tiles[145 + 220]; // set 3
@label=plot_tile_chosen
*C$A9C5,1;21 chosen: PUSH HLdash;
 C$A9C6,1
 C$A9C7,1;21 {HLdash = A * 8 + BCdash;
 C$A9C8,5;21
 C$A9CD,1;21 }
 C$A9CE,1;21 PUSH DEdash;
 C$A9CF,1;21 EX DEdash,HLdash;
 C$A9D0,3;21 BCdash = 24;
 C$A9D3,2;21 A = 8; // 8 iterations
@label=plot_tile_loop
*C$A9D5,1;21 do <%
 C$A9D6,1;21 Adash = *DEdash;
 C$A9D7,1;21 *HLdash = Adash;
 C$A9D8,1;21 HLdash += BCdash; // stride
 C$A9D9,1;21 E++;
 C$A9DA,1
 C$A9DB,1;21 A--;
 C$A9DC,3;21 %> while (A);
 C$A9DF,1;21 POP DEdash;
 C$A9E0,1;21 DEdash++;
 C$A9E1,1;21 POP HLdash;
 C$A9E2,1
 C$A9E3,1;21 return;

; Shunt the map left.
;
; Used by the routine at #R$AAB2.
@label=shunt_map_left
cC$A9E4,3;21 HL = &map_position;
 C$A9E7,1;21 (*HL)++;
 C$A9E8,3;21 get_supertiles();
 C$A9EB,3;21 HL = &tile_buf[1];
 C$A9EE,3;21 DE = &tile_buf[0];
 C$A9F1,3;21 BC = tile_buf_length - 1;
 C$A9F4,2
@nowarn
 C$A9F6,3;21 HL = &window_buf[1];
 C$A9F9,3;21 DE = &window_buf[0];
 C$A9FC,3;21 BC = window_buf_length - 1;
 C$A9FF,2
 C$AA01,3;21 plot_rightmost_tiles();
 C$AA04,1;21 return;

; Shunt the map right.
;
; Used by the routine at #R$AAB2.
@label=shunt_map_right
cC$AA05,3;21 HL = &map_position;
 C$AA08,1;21 (*HL)--;
 C$AA09,3;21 get_supertiles();
@nowarn
 C$AA0C,3;21 HL = &tile_buf[24 * 17 - 2];
 C$AA0F,3;21 DE = &tile_buf[24 * 17 - 1];
 C$AA12,3;21 BC = tile_buf_length - 1;
 C$AA15,2
 C$AA17,3;21 HL = &window_buf[24 * 17 * 8 - 1];
 C$AA1A,3;21 DE = &window_buf[24 * 17 * 8];
 C$AA1D,3;21 BC = window_buf_length; // Bug: One byte too long.
 C$AA20,2
 C$AA22,3;21 plot_leftmost_tiles();
 C$AA25,1;21 return;

; Shunt the map up-right.
;
; Used by the routine at #R$AAB2.
@label=shunt_map_up_right
cC$AA26,1;21 L--;
 C$AA27,1;21 H++;
 C$AA28,3;21 map_position = HL;
 C$AA2B,3;21 get_supertiles();
 C$AA2E,3;21 HL = &tile_buf[24];
 C$AA31,3;21 DE = &tile_buf[1];
 C$AA34,3;21 BC = tile_buf_length - 24;
 C$AA37,2
@nowarn
 C$AA39,3;21 HL = &window_buf[24 * 8];
@nowarn
 C$AA3C,3;21 DE = &window_buf[1];
 C$AA3F,3;21 BC = window_buf_length - 24 * 8;
 C$AA42,2
 C$AA44,3;21 plot_bottommost_tiles();
 C$AA47,3;21 plot_leftmost_tiles();
 C$AA4A,1;21 return;

; Shunt the map up.
;
; Used by the routine at #R$AAB2.
@label=shunt_map_up
cC$AA4B,3;21 HL = &map_position[1];
 C$AA4E,1;21 (*HL)++;
 C$AA4F,3;21 get_supertiles();
 C$AA52,3;21 HL = &tile_buf[24];
 C$AA55,3;21 DE = &tile_buf[0];
 C$AA58,3;21 BC = tile_buf_length - 24;
 C$AA5B,2
@nowarn
 C$AA5D,3;21 HL = &window_buf[24 * 8];
 C$AA60,3;21 DE = &window_buf[0];
 C$AA63,3;21 BC = window_buf_length - 24 * 8;
 C$AA66,2
 C$AA68,3;21 plot_bottommost_tiles();
 C$AA6B,1;21 return;

; Shunt the map down.
;
; Used by the routine at #R$AAB2.
@label=shunt_map_down
cC$AA6C,3;21 HL = &map_position[1];
 C$AA6F,1;21 (*HL)--;
 C$AA70,3;21 get_supertiles();
@nowarn
 C$AA73,3;21 HL = &tile_buf[24 * 16 - 1];
 C$AA76,3;21 DE = &tile_buf[24 * 17 - 1];
 C$AA79,3;21 BC = tile_buf_length - 24;
 C$AA7C,2
 C$AA7E,3;21 HL = &window_buf[24 * 16 * 8 - 1];
 C$AA81,3;21 DE = &window_buf[24 * 17 * 8 - 1];
 C$AA84,3;21 BC = window_buf_length - 24 * 8;
 C$AA87,2
 C$AA89,3;21 plot_topmost_tiles();
 C$AA8C,1;21 return;

; Shunt the map down left.
;
; Used by the routine at #R$AAB2.
@label=shunt_map_down_left
cC$AA8D,1;21 L++;
 C$AA8E,1;21 H--;
 C$AA8F,3;21 map_position = HL;
 C$AA92,3;21 get_supertiles();
@nowarn
 C$AA95,3;21 HL = &tile_buf[24 * 16 - 1];
@nowarn
 C$AA98,3;21 DE = &tile_buf[24 * 17 - 2];
 C$AA9B,3;21 BC = tile_buf_length - 24 - 1;
 C$AA9E,2
 C$AAA0,3;21 HL = &window_buf[24 * 16 * 8 - 1];
 C$AAA3,3;21 DE = &window_buf[24 * 17 * 8 - 2];
 C$AAA6,3;21 BC = window_buf_length - 24 * 8 - 1;
 C$AAA9,2
 C$AAAB,3;21 plot_topmost_tiles();
 C$AAAE,3;21 plot_rightmost_tiles();
 C$AAB1,1;21 return;

; Move the map when the hero walks.
;
; Used by the routines at #R$6939 and #R$9D7B.
;
; O:HL == map_position
@label=move_map
cC$AAB2,3;21 {if (room_index) return; // Can't move the map when indoors.
 C$AAB5,1;21
 C$AAB6,1;21 }
 C$AAB7,3;21 {if ($8007 & vischar_BYTE7_TOUCHING) return; // don't move the map if touch() is entered?
 C$AABA,2;21
 C$AABC,1;21 }
 C$AABD,3;21 HL = $800A;
 C$AAC0,1;21 {E = *HL++;
 C$AAC1,1;21 }
 C$AAC2,1;21 {D = *HL++;
 C$AAC3,1;21 }
 C$AAC4,1;21 C = *HL; // $800C
 C$AAC5,1;21 {DE += 3;
 C$AAC6,1;21
 C$AAC7,1;21 }
 C$AAC8,1;21 A = *DE;
 C$AAC9,2;21 {if (A == 255) return; // don't move
 C$AACB,1;21 }
 C$AACC,2;21 {if (C & vischar_ANIMINDEX_BIT7) A ^= 2; // exchange up and down
 C$AACE,2;21
 C$AAD0,2;21 }
*C$AAD2,1
 C$AAD3,1;21 {HL = &move_map_jump_table[A];
 C$AAD4,3;21
@nowarn
 C$AAD7,3;21
 C$AADA,1;21 }
 C$AADB,1;21 {A = *HL++; // ie. HL = (word at HL); HL += 2;
 C$AADC,1;21 }
 C$AADD,1;21 H = *HL;
 C$AADE,1;21 L = A;
 C$AADF,3
@keep
 C$AAE2,3;21 B, C = 0x7C, 0x00;
 C$AAE5,2;21 {if (A >= 2) B = 0x00; // bottom of the map clamp
 C$AAE7,2;21
 C$AAE9,2;21 }
*C$AAEB,2;21 {if (A != 1 && A != 2) C = 0xC0; // left of the map clamp
 C$AAED,6;21
 C$AAF3,2;21 }
*C$AAF5,3;21 HL = map_position;
 C$AAF8,1;21 {if (L == C || H == B) <%
 C$AAF9,1;21
 C$AAFA,2;21 }
*C$AAFC,1;21 popret:
 C$AAFD,1
 C$AAFE,1;21 {  return; %>
*C$AAFF,1;21
 C$AB00,1;21
 C$AB01,2;21 }
 C$AB03,1
 C$AB04,3;21 HL = &move_map_y; // screen offset of some sort?
 C$AB07,2;21 {if (A < 2) <%
 C$AB09,2;21 }
 C$AB0B,1;21 {  A = *HL + 1; %>
 C$AB0C,1;21 }
 C$AB0D,2;21 else <%
*C$AB0F,1;21 {  A = *HL - 1; %>
 C$AB10,1;21 }
*C$AB11,2;21 A &= 3;
 C$AB13,1;21 *HL = A;
 C$AB14,1
 C$AB15,3;21 HL = 0x0000;
 C$AB18,1;21 {if (A == 0) goto $AB2A;
 C$AB19,2;21 }
 C$AB1B,2;21 L = 0x60;
 C$AB1D,2;21 {if (A == 2) goto $AB2A;
 C$AB1F,2;21 }
 C$AB21,3;21 HL = 0xFF30;
 C$AB24,2;21 {if (A == 1) goto $AB2A;
 C$AB26,2;21 }
 C$AB28,2;21 L = 0x90;
*C$AB2A,3;21 game_window_offset = HL;
 C$AB2D,3;21 HL = map_position;
 C$AB30,1;21 return; // pops and calls move_map_* routine pushed at $AAE0
; move_map jump table.
@label=move_map_jump_table
 W$AB31,2;21 move_map_up_left
 W$AB33,2;21 move_map_up_right
 W$AB35,2;21 move_map_down_right
 W$AB37,2;21 move_map_down_left
; Called when player moves down-right (map is shifted up-left).
@label=move_map_up_left
 C$AB39,1;21 A = *DE;
 C$AB3A,1;21 {if (A == 0) goto shunt_map_up;
 C$AB3B,3;21 }
 C$AB3E,2;21 {if ((A & 1) == 0) return;
 C$AB40,1;21 }
 C$AB41,3;21 goto shunt_map_left;
; Called when player moves down-left (map is shifted up-right).
@label=move_map_up_right
 C$AB44,1;21 A = *DE;
 C$AB45,1;21 {if (A == 0) goto shunt_map_up_right;
 C$AB46,3;21 }
 C$AB49,2;21 {if (A != 2) return;
 C$AB4B,1;21 }
 C$AB4C,3;21 goto shunt_map_right;
; Called when player moves up-left (map is shifted down-right).
@label=move_map_down_right
 C$AB4F,1;21 A = *DE;
 C$AB50,2;21 {if (A == 3) goto shunt_map_down;
 C$AB52,3;21 }
 C$AB55,1;21 {if ((A & 1) == 0) goto shunt_map_right;
 C$AB56,3;21 }
 C$AB59,1;21 return;
; Called when player moves up-right (map is shifted down-left).
@label=move_map_down_left
 C$AB5A,1;21 A = *DE;
 C$AB5B,2;21 {if (A == 1) goto shunt_map_left;
 C$AB5D,3;21 }
 C$AB60,2;21 {if (A == 3) goto shunt_map_down_left;
 C$AB62,3;21 }
 C$AB65,1;21 return;

; Zoombox stuff.
@label=zoombox_x
gB$AB66,1
@label=zoombox_horizontal_count
 B$AB67,1
@label=zoombox_y
 B$AB68,1
@label=zoombox_vertical_count
 B$AB69,1

; Game window current attribute byte.
@label=game_window_attribute
gB$AB6A,1

; Choose game window attributes.
;
; Used by the routines at #R$7B36, #R$7B8B, #R$A1D3, #R$ABA0, #R$B3F6 and
; #R$B83B.
;
; O:A Chosen attribute.
@label=choose_game_window_attributes
cC$AB6B,3;21 {if (room_index < room_29_SECOND_TUNNEL_START) <%
 C$AB6E,2;21
 C$AB70,2;21 }
; The hero is outside, or in a room, but not in a tunnel.
 C$AB72,3;21 A = day_or_night;
 C$AB75,2;21 C = attribute_WHITE_OVER_BLACK;
 C$AB77,1;21 {  if (A == 0) goto set_attribute_from_C;
 C$AB78,2;21 }
 C$AB7A,3;21 A = room_index;
 C$AB7D,2;21 C = attribute_BRIGHT_BLUE_OVER_BLACK;
 C$AB7F,1;21 {  if (A == 0) goto set_attribute_from_C;
 C$AB80,2;21 }
 C$AB82,2;21 C = attribute_CYAN_OVER_BLACK;
*C$AB84,1;21 set_attribute_from_C: A = C;
*C$AB85,3;21 set_attribute_from_A: game_window_attribute = A;
 C$AB88,1;21 return; %>
; The hero is in a tunnel.
*C$AB89,2;21 else <% C = attribute_RED_OVER_BLACK;
 C$AB8B,3;21 HL = items_held;
; If the hero holds a torch - draw the room.
 C$AB8E,2;21 {  if (L == item_TORCH || H == item_TORCH) goto set_attribute_from_C;
 C$AB90,4;21
 C$AB94,2;21 }
; The hero holds no torch - draw nothing.
 C$AB96,3;21 wipe_visible_tiles();
 C$AB99,3;21 plot_interior_tiles();
 C$AB9C,2;21 A = attribute_BLUE_OVER_BLACK;
 C$AB9E,2;21 goto set_attribute_from_A; %>

; Zoombox.
;
; Used by the routines at #R$68F4, #R$A50B and #R$B2FC.
@label=zoombox
cC$ABA0,2;21 {zoombox_x = 12;
 C$ABA2,3;21 }
 C$ABA5,2;21 {zoombox_y = 8;
@nowarn
 C$ABA7,3;21 }
 C$ABAA,3;21 choose_game_window_attributes();
 C$ABAD,1;21 H = A;
 C$ABAE,1;21 L = A;
 C$ABAF,3;21 ($5932) = HL; // set 2 attrs
 C$ABB2,3;21 ($5952) = HL; // set 2 attrs
 C$ABB5,1;21 {zoombox_horizontal_count = 0;
 C$ABB6,3;21 }
 C$ABB9,3;21 zoombox_vertical_count = 0;
*C$ABBC,3;21 do <% HL = &zoombox_x;
 C$ABBF,1;21 A = *HL;
 C$ABC0,2;21 {  if (A != 1) <%
 C$ABC2,3;21 }
 C$ABC5,1;21 (*HL)--;
 C$ABC6,1;21 A--;
 C$ABC7,1;21 HL++;
 C$ABC8,1;21 (*HL)++;
 C$ABC9,1;21 HL--; %>
*C$ABCA,1;21 HL++;
 C$ABCB,1;21 A += *HL;
 C$ABCC,2;21 {  if (A < 22) (*HL)++;
 C$ABCE,3;21
 C$ABD1,1;21 }
*C$ABD2,1;21 HL++;
 C$ABD3,1;21 A = *HL;
 C$ABD4,2;21 {  if (A != 1) <%
 C$ABD6,3;21 }
 C$ABD9,1;21 (*HL)--;
 C$ABDA,1;21 A--;
 C$ABDB,1;21 HL++;
 C$ABDC,1;21 (*HL)++;
 C$ABDD,1;21 HL--; %>
*C$ABDE,1;21 HL++;
 C$ABDF,1;21 A += *HL;
 C$ABE0,2;21 {  if (A < 15) (*HL)++;
 C$ABE2,3;21
 C$ABE5,1;21 }
*C$ABE6,3;21 zoombox_fill();
 C$ABE9,3;21 zoombox_draw_border();
 C$ABEC,3;21 {  A = zoombox_vertical_count + zoombox_horizontal_count;
 C$ABEF,3;21
 C$ABF2,1;21 }
 C$ABF3,2;21 {%> while (A < 35);
 C$ABF5,3;21 }
 C$ABF8,1;21 return;

; Zoombox. partial copy of window buffer contents?
;
; Used by the routine at #R$ABA0.
@label=zoombox_fill
cC$ABF9,3;21 A = zoombox_y;
 C$ABFC,1;21 { DE = zoombox_y * 128
 C$ABFD,5;21
 C$AC02,1;21 }
 C$AC03,2;21 { HL = zoombox_y * 64
 C$AC05,1;21
 C$AC06,1;21 }
 C$AC07,1;21 {HL += DE + zoombox_x;
 C$AC08,7;21
 C$AC0F,1;21 }
@nowarn
*C$AC10,3;21 DE = &state->window_buf[1];
 C$AC13,1;21 HL += DE;
 C$AC14,1
@nowarn
 C$AC15,3;21 {HL = game_window_start_addresses[zoombox_y * 8]; // ie. * 16
 C$AC18,12;21
*C$AC24,1;21
 C$AC25,2;21
 C$AC27,1;21 }
 C$AC28,3;21 {HL += zoombox_x;
 C$AC2B,1;21
 C$AC2C,1;21 }
 C$AC2D,1
 C$AC2E,3;21 A = zoombox_horizontal_count;
 C$AC31,3;21 ($AC55) = A; // self modify
 C$AC34,2;21 {A = -A + 24;
 C$AC36,2;21 }
 C$AC38,3;21 ($AC4D) = A; // self modify
 C$AC3B,3;21 A = zoombox_vertical_count;
 C$AC3E,1;21 B = A; // iterations
*C$AC3F,1;21 do <%
 C$AC40,1
 C$AC41,2;21 A = 8; // 8 iterations
*C$AC43,1;21 do <%
 C$AC44,3;21 {    BC = zoombox_horizontal_count;
 C$AC47,1;21
 C$AC48,2;21 }
 C$AC4A,2;21
 C$AC4C,2;21 Adash = 0; // self modified
 C$AC4E,1;21 {    HL += Adash;
 C$AC4F,3;21
 C$AC52,1;21 }
*C$AC53,1;21 Adash = E;
 C$AC54,2;21 Adash -= 0; // self modified
 C$AC56,1;21 E = Adash;
 C$AC57,1;21 D++;
 C$AC58,1
 C$AC59,1;21 {  %> while (--A);
 C$AC5A,3;21 }
 C$AC5D,2
 C$AC5F,3;21 BC = 0x0020;
 C$AC62,1;21 {  if (L >= 224) B = 0x07;
 C$AC63,4;21
 C$AC67,2;21 }
*C$AC69,1;21 HL += BC;
 C$AC6A,2
 C$AC6C,2;21 %> while (--B);
 C$AC6E,1;21 return;

; Draw zoombox border.
;
; Used by the routine at #R$ABA0.
@label=zoombox_draw_border
@nowarn
cC$AC6F,3;21 {HL = game_window_start_addresses[(zoombox_y - 1) * 8]; // ie. * 16
 C$AC72,13;21
*C$AC7F,1;21
 C$AC80,2;21
 C$AC82,1;21 }
; Top left.
 C$AC83,3;21 {HL += zoombox_x - 1;
 C$AC86,2;21
 C$AC88,1;21 }
 C$AC89,2;21 {zoombox_draw_tile(zoombox_tile_TL);
 C$AC8B,3;21 }
 C$AC8E,1;21 HL++;
; Horizontal, moving right.
 C$AC8F,3;21 {B = zoombox_horizontal_count; // iterations
 C$AC92,1;21 }
*C$AC93,2;21 {do <% zoombox_draw_tile(zoombox_tile_HZ);
 C$AC95,3;21 }
 C$AC98,1;21 HL++;
 C$AC99,2;21 %> while (--B);
; Top right.
 C$AC9B,2;21 {zoombox_draw_tile(zoombox_tile_TR);
 C$AC9D,3;21 }
 C$ACA0,3;21 DE = 32;
 C$ACA3,1;21 {if (L >= 224) D = 0x07;
 C$ACA4,4;21
 C$ACA8,2;21 }
*C$ACAA,1;21 HL += DE;
; Vertical, moving down.
 C$ACAB,3;21 {B = zoombox_vertical_count; // iterations
 C$ACAE,1;21 }
*C$ACAF,2;21 {do <% zoombox_draw_tile(zoombox_tile_VT);
 C$ACB1,3;21 }
 C$ACB4,3;21 DE = 32;
 C$ACB7,1;21 {  if (L >= 224) D = 0x07;
 C$ACB8,4;21
 C$ACBC,2;21 }
*C$ACBE,1;21 HL += DE;
 C$ACBF,2;21 %> while (--B);
; Bottom right.
 C$ACC1,2;21 {zoombox_draw_tile(zoombox_tile_BR);
 C$ACC3,3;21 }
 C$ACC6,1;21 HL--;
; Horizontal, moving left.
 C$ACC7,3;21 {B = zoombox_horizontal_count; // iterations
 C$ACCA,1;21 }
*C$ACCB,2;21 {do <% zoombox_draw_tile(zoombox_tile_HZ);
 C$ACCD,3;21 }
 C$ACD0,1;21 HL--;
 C$ACD1,2;21 %> while (--B);
; Bottom left.
 C$ACD3,2;21 {zoombox_draw_tile(zoombox_tile_BL);
 C$ACD5,3;21 }
 C$ACD8,3;21 DE = 0xFFE0;
 C$ACDB,1;21 {if (L < 32) DE = 0xF8E0;
 C$ACDC,4;21
 C$ACE0,3;21 }
*C$ACE3,1;21 HL += DE;
; Vertical, moving up.
 C$ACE4,3;21 {B = zoombox_vertical_count; // iterations
 C$ACE7,1;21 }
*C$ACE8,2;21 {do <% zoombox_draw_tile(zoombox_tile_VT);
 C$ACEA,3;21 }
 C$ACED,3;21 DE = 0xFFE0;
 C$ACF0,1;21 {  if (L < 32) DE = 0xF8E0;
 C$ACF1,4;21
 C$ACF5,3;21 }
*C$ACF8,1;21 HL += DE;
 C$ACF9,2;21 %> while (--B);
 C$ACFB,1;21 return;

; Draw a single zoombox border tile.
;
; Used by the routine at #R$AC6F.
;
; I:A Index of tile to draw.
; I:BC (preserved)
; I:HL Destination address.
@label=zoombox_draw_tile
cC$ACFC,4
 C$AD00,1;21 {HL = &zoombox_tiles[A];
 C$AD01,8;21
 C$AD09,1;21 }
 C$AD0A,2;21 B = 8; // 8 iterations
*C$AD0C,1;21 {do <% *DE = *HL++;
 C$AD0D,1;21 }
 C$AD0E,1;21 {  DE += 256;
 C$AD0F,1;21 }
 C$AD10,2;21 %> while (--B);
 C$AD12,1;21 {A = D - 1; // ie. (DE - 256) >> 8
 C$AD13,1;21 }
 C$AD14,2;21 H = 0x58; // attributes
 C$AD16,1;21 L = E;
 C$AD17,2;21 {if (A >= 0x48) <% H++;
 C$AD19,2;21
 C$AD1B,1;21 }
 C$AD1C,2;21 {  if (A >= 0x50) H++; %>
 C$AD1E,2;21
 C$AD20,1;21 }
*C$AD21,3;21 {*HL = game_window_attribute;
 C$AD24,1;21 }
 C$AD25,3
 C$AD28,1;21 return;

; Searchlight movement data.
@label=searchlight_movements
wB$AD29,5;36 x, y, step, direction, counter
 W$AD2E,2;20 searchlight_path_2
 B$AD30,5;36 x, y, step, direction, counter
 W$AD35,2;20 searchlight_path_1
 B$AD37,5;36 x, y, step, direction, counter
 W$AD3C,2;20 searchlight_path_0
@label=searchlight_path_0
 B$AD3E,5
@label=searchlight_path_1
 B$AD43,17
@label=searchlight_path_2
 B$AD54,5

; Decides searchlight movement.
;
; Used by the routine at #R$ADBD.
;
; I:HL Pointer to a searchlight movement data.
@label=searchlight_movement
cC$AD59,1;21 {E = *HL++;
 C$AD5A,1;21 }
 C$AD5B,1;21 {D = *HL++;
 C$AD5C,1;21 }
 C$AD5D,1;21 (*HL)--;
 C$AD5E,3;21 if (Z) <%
 C$AD61,1;21 {  HL += 2;
 C$AD62,1;21 }
 C$AD63,1;21 A = *HL; // sampled HL=$AD3B,$AD34,$AD2D
 C$AD64,2;21 {  if (A & (1<<7)) <% // sign
 C$AD66,3;21 }
 C$AD69,2;21 A &= 0x7F;
 C$AD6B,3;21 if (A == 0) <%
 C$AD6E,2;21 *HL &= ~(1<<7); %> // clear sign bit when magnitude hits zero
 C$AD70,2;21 else <%
*C$AD72,1;21 (*HL)--; // count down
 C$AD73,1;21 A--; %> %> // just a copy
*C$AD74,2;21 else <%
*C$AD76,1;21 A++; // count up
 C$AD77,1;21 *HL = A; %>
*C$AD78,1;21 HL++;
 C$AD79,1;21 {  C = *HL++;
 C$AD7A,1;21 }
 C$AD7B,1;21 B = *HL;
 C$AD7C,1;21 {  HL -= 2;
 C$AD7D,1;21 }
 C$AD7E,1;21 {  BC += A * 2;
 C$AD7F,4;21
 C$AD83,1;21 }
*C$AD84,1;21 A = *BC;
 C$AD85,2;21 {  if (A == 0xFF) <% // end of list?
 C$AD87,3;21 }
 C$AD8A,1;21 (*HL)--; // overshot? count down counter byte
 C$AD8B,2;21 *HL |= 1<<7; // go negative
 C$AD8D,1;21 {    BC -= 2;
 C$AD8E,1;21 }
 C$AD8F,1;21 A = *BC; %>/* This is a flaw in original code: A is fetched but never used again. */
*C$AD90,1;21 {  HL -= 2;
 C$AD91,1;21 }
; Copy counter + direction_t.
 C$AD92,1;21 {  *HL++ = *BC++;
 C$AD93,2;21
 C$AD95,1;21 }
 C$AD96,1;21 {  *HL = *BC;
 C$AD97,1;21 }
 C$AD98,1;21 return; %>
*C$AD99,1;21 else <% HL++;
 C$AD9A,1;21 {  A = *HL++;
 C$AD9B,1;21 }
 C$AD9C,2;21 {  if (*HL & (1<<7)) A ^= 2; // if -ve, toggle up-down
 C$AD9E,2;21
 C$ADA0,2;21 }
*C$ADA2,2;21 {  if (A < 2) D -= 2;
 C$ADA4,3;21
 C$ADA7,1;21 }
*C$ADA8,1;21 D++;
 C$ADA9,1;21 {  if (A != 0 && A != 3) <% E += 2; %> else <% E -= 2
 C$ADAA,2;21 %>;
 C$ADAC,8;21
*C$ADB4,1;21
 C$ADB5,1;21 }
*C$ADB6,1;21 {  HL -= 3;
 C$ADB7,1;21
 C$ADB8,1;21 }
 C$ADB9,1;21 {  *HL-- = D;
 C$ADBA,1;21 }
 C$ADBB,1;21 *HL = E;
 C$ADBC,1;21 return; %>

; Turns white screen elements light blue and tracks the hero with a
; searchlight.
;
; Used by the routine at #R$9D7B.
@label=nighttime
cC$ADBD,3;21 HL = &searchlight_state;
 C$ADC0,1;21 {if (*HL == searchlight_STATE_SEARCHING) goto not_tracking;
 C$ADC1,2;21
 C$ADC3,3;21 }
 C$ADC6,3;21 {if (room_index) <% // hero is indoors
 C$ADC9,1;21
 C$ADCA,2;21 }
; If the hero goes indoors then the searchlight loses track.
 C$ADCC,2;21 *HL = searchlight_STATE_SEARCHING;
 C$ADCE,1;21 return; %>
; The hero is outdoors.
; .
; If the searchlight previously caught the hero, then track him.
*C$ADCF,1;21 {if (*HL == searchlight_STATE_CAUGHT) <%
 C$ADD0,2;21
 C$ADD2,3;21 }
 C$ADD5,3;21 HL = map_position;
 C$ADD8,1;21 {  E = L + 4;
 C$ADD9,2;21
 C$ADDB,1;21 }
 C$ADDC,1;21 D = H;
 C$ADDD,3;21 HL = searchlight_caught_coord;
 C$ADE0,1;21 {  if (L == E) <%
 C$ADE1,1;21
 C$ADE2,2;21 }
 C$ADE4,1;21 {    if (H == D) return; %> // If the highlight doesn't need to move, quit.
 C$ADE5,1;21
 C$ADE6,1;21 }
 C$ADE7,2;21 else <%
; Move searchlight left/right to focus on the hero.
*C$ADE9,3;21 if (L < E) <%
 C$ADEC,1;21 L++; %>
 C$ADED,2;21 else <%
*C$ADEF,1;21 L--; %>
*C$ADF0,1;21 %>
; Move searchlight up/down to focus on the hero.
*C$ADF1,1;21 {  if (H != D) <%
 C$ADF2,1;21
 C$ADF3,2;21 }
 C$ADF5,3;21 if (H < D) <%
 C$ADF8,1;21 H++; %>
 C$ADF9,2;21 else <%
*C$ADFB,1;21 H--; %>
*C$ADFC,1;21 %>
*C$ADFD,3;21 searchlight_caught_coord = HL; %>
*C$AE00,4;21 DE = map_position;
 C$AE04,3;21 HL = $AE77; // &searchlight_caught_coord + 1 byte; // compensating for HL--; jumped into
 C$AE07,2;21 B = 1; // 1 iteration
 C$AE09,2
 C$AE0B,2;21 goto $AE3F;
*C$AE0D,3;21 not_tracking: HL = &searchlight_movements[0];
 C$AE10,2;21 B = 3; // 3 iterations == three searchlights
*C$AE12,1;21 do <%
 C$AE13,1
 C$AE14,3;21 searchlight_movement();
 C$AE17,2
 C$AE19,3;21 searchlight_caught();
 C$AE1C,2
 C$AE1E,4;21 DE = map_position;
; if (E + 23 < x || x + 16 < E) goto next;
; .
; if (D + 16 < y || y + 16 < D) goto next;
 C$AE22,1;21 {  if (E + 23 < *HL) goto next;
 C$AE23,3;21
 C$AE26,3;21 }
 C$AE29,1;21 {  if (*HL + 16 < E) goto next;
 C$AE2A,3;21
 C$AE2D,3;21 }
 C$AE30,1;21 HL++;
 C$AE31,1;21 {  if (D + 16 < *HL) goto next;
 C$AE32,3;21
 C$AE35,3;21 }
 C$AE38,1;21 {  if (*HL + 16 < D) goto next;
 C$AE39,3;21
 C$AE3C,3;21 }
*C$AE3F,1;21 A = 0;
 C$AE40,1
 C$AE41,1;21 HL--;
 C$AE42,2;21 B = 0x00;
 C$AE44,1;21 {  if (*HL - E < 0) <%
 C$AE45,1;21
 C$AE46,3;21 }
 C$AE49,2;21 B = 0xFF;
 C$AE4B,1
 C$AE4C,1;21 A = ~A;
 C$AE4D,1;21 %>
*C$AE4E,1;21 C = Adash;
 C$AE4F,1;21 {  Adash = *++HL;
 C$AE50,1;21 }
 C$AE51,2;21 H = 0x00;
 C$AE53,1;21 Adash -= D;
 C$AE54,3;21 {  if (Adash < 0) H = 0xFF; // -ve
 C$AE57,2;21 }
*C$AE59,1;21 L = Adash;
; HL must be row, BC must be column
 C$AE5A,1;21 {  HL *= 32;
 C$AE5B,3;21
 C$AE5E,1;21 }
 C$AE5F,1;21 HL += BC;
 C$AE60,3;21 {  HL += 0x5846; // address of top-left game window attribute
 C$AE63,1;21 }
 C$AE64,2
 C$AE66,3;21 searchlight_clip_left = A;
 C$AE69,3;21 searchlight_plot();
*C$AE6C,1;21 next:
 C$AE6D,1
 C$AE6E,3;21 {  HL += 7;
 C$AE71,1;21 }
 C$AE72,2;21 %> while (--B);
 C$AE74,1;21 return;

; Searchlight stuff
;
; (<- nighttime, searchlight_plot)
@label=searchlight_clip_left
gB$AE75,1
; Coordinates of searchlight when hero is caught.
@label=searchlight_caught_coord
 W$AE76,2

; Is the hero is caught in the searchlight?
;
; Used by the routine at #R$ADBD.
;
; I:HL Pointer to searchlight movement data.
@label=searchlight_caught
cC$AE78,4;21 DE = map_position;
 C$AE7C,1;21 {if (HL[0] + 5 >= E + 12 || HL[0] + 10 < E + 10) return;
 C$AE7D,13;21
 C$AE8A,1;21 }
 C$AE8B,1;21 {if (HL[1] + 5 >= D + 10 || D + 6 >= HL[1] + 12) return;
 C$AE8C,16;21
 C$AE9C,1;21 }
; It seems odd to not do this (cheaper) test sooner.
 C$AE9D,3;21 {if (searchlight_state == searchlight_STATE_CAUGHT) return;
 C$AEA0,2;21
 C$AEA2,1;21 }
 C$AEA3,2;21 {searchlight_state = searchlight_STATE_CAUGHT;
 C$AEA5,3;21 }
 C$AEA8,1;21 {D = HL[0];
 C$AEA9,1;21 }
 C$AEAA,1;21 E = HL[1];
 C$AEAB,4;21 searchlight_caught_coord = DE;
 C$AEAF,1;21 {bell = bell_RING_PERPETUAL;
 C$AEB0,3;21 }
 C$AEB3,2;21 {decrease_morale(10); // exit via
 C$AEB5,3;21 }

; Searchlight plotter.
;
; Used by the routine at #R$ADBD.
;
; I:DE Pointer to screen attributes.
@label=searchlight_plot
cC$AEB8,1
@nowarn
 C$AEB9,3;44 DEdash = &searchlight_shape[0];
 C$AEBC,2;44 Cdash = 16; // iterations  / width?
*C$AEBE,1;44 do <%
 C$AEBF,3;44 A = searchlight_clip_left;
@nowarn
 C$AEC2,3;44 HL = 0x5A40; // screen attribute address (column 0 + bottom of game window)
 C$AEC5,1;44 {  if (A != 0 && (E & 31) >= 22) L = 32;
 C$AEC6,10;44
 C$AED0,2;44 }
*C$AED2,2;44
 C$AED4,1;44 RET C  // if (HL < DE) return; // what about carry?
 C$AED5,1
@nowarn
 C$AED6,3;44 HL = 0x5840; // screen attribute address (column 0 + top of game window)
 C$AED9,1;44 {  if (A != 0 && (E & 31) >= 7) L = 32;
 C$AEDA,10;44
 C$AEE4,2;44 }
*C$AEE6,2;44
 C$AEE8,2;44 JR C,$AEF0  // if (HL < DE) goto $AEF0;
 C$AEEA,1
 C$AEEB,1;44 {  DEdash += 2;
 C$AEEC,1;44 }
 C$AEED,1
 C$AEEE,2;44 goto nextrow;
*C$AEF0,1
 C$AEF1,1
 C$AEF2,2;44 Bdash = 2;
*C$AEF4,1;44 do <% A = *DEdash;
 C$AEF5,1
 C$AEF6,3;44 DE = 0x071E;
 C$AEF9,1;44 C = A;
 C$AEFA,2;44 B = 8;
*C$AEFC,3;44 do <% A = searchlight_clip_left;
 C$AEFF,1;44 if (A != 0) ...
 C$AF00,1;44 A = L; // interleaved
 C$AF01,3;44 ... goto $AF0C;
 C$AF04,2;44 {      if ((A & 31) >= 22) goto $AF1B;
 C$AF06,2;44
 C$AF08,2;44 }
 C$AF0A,2;44 goto $AF18;
*C$AF0C,2;44 {      if ((A & 31) < E) goto $AF18;
 C$AF0E,1;44
 C$AF0F,2;44 }
 C$AF11,1
*C$AF12,1;44 {      do <% DEdash++; %> while (--Bdash);
 C$AF13,2;44 }
 C$AF15,1
 C$AF16,2;44 goto nextrow;
*C$AF18,1;44 {      if (A < D) <%
 C$AF19,2;44 }
*C$AF1B,2;44 RL C %> // looks like bit extraction ...
 C$AF1D,2;44 else <%
*C$AF1F,2;44 RL C
 C$AF21,3;44 if (carry) <%
 C$AF24,2;44 *HL = attribute_YELLOW_OVER_BLACK; %>
 C$AF26,2;44 else <%
*C$AF28,2;44 *HL = attribute_BRIGHT_BLUE_OVER_BLACK; %> %>
*C$AF2A,1;44 HL++;
 C$AF2B,2;44 %> while (--B);
 C$AF2D,1
 C$AF2E,1;44 DEdash++;
 C$AF2F,2;44 %> while (--Bdash);
 C$AF31,1
*C$AF32,1;44 nextrow:
 C$AF33,3;44 {  HL += 32;
 C$AF36,1;44 }
 C$AF37,2
 C$AF39,1;44 {%> while (--Cdash);
 C$AF3A,3;44 }
 C$AF3D,1;44 return;
; Searchlight circle shape.
@label=searchlight_shape
 B$AF3E,2;20 {searchlight_shape
 B$AF40,2*14;20
 B$AF5C,2;20 }

; Barbed wire tiles used by the zoombox effect.
@label=zoombox_tiles
bB$AF5E,8;44 top left tile, zoombox_tile_wire_tl #HTML[#UDG$AF5E]
 B$AF66,8;44 horizontal tile, zoombox_tile_wire_hz #HTML[#UDG$AF66]
 B$AF6E,8;44 top right tile, zoombox_tile_wire_tr #HTML[#UDG$AF6E]
 B$AF76,8;44 vertical tile, zoombox_tile_wire_vt #HTML[#UDG$AF76]
 B$AF7E,8;44 bottom right tile, zoombox_tile_wire_br #HTML[#UDG$AF7E]
 B$AF86,8;44 bottom left tile, zoombox_tile_wire_bl #HTML[#UDG$AF86]

; Bribed character.
@label=bribed_character
gB$AF8E,1

; Stuff is touching. Also assigns saved_pos to specified vischar's pos and sets
; the sprite_index.
;
; Used by the routine at #R$B5CE.
;
; I:A' Flip flag + sprite offset.
; I:IY Pointer to visible character block.
@label=touch
cC$AF8F,1
 C$AF90,3;22 touch_stashed_A = A;
 C$AF93,4;22 {IY[7] |= vischar_BYTE7_TOUCHING | vischar_BYTE7_LOCATABLE; // wild guess: clamp character in position?
 C$AF97,4;22 }
 C$AF9B,2;22 {HL = IY;
 C$AF9D,1;22 }
 C$AF9E,1
; If hero is player controlled, then check for door transitions.
 C$AF9F,1;22 {if (L == 0 && automatic_player_counter > 0) door_handling(); // L == 0 => HL == 0x8000
 C$AFA0,10;22
*C$AFAA,1;22 }
; If non-player character or hero is not cutting the fence.
 C$AFAB,1;22 {if (L || (($8001 & (vischar_FLAGS_PICKING_LOCK | vischar_FLAGS_CUTTING_WIRE)) != vischar_FLAGS_CUTTING_WIRE)) <% if (bounds_check()) return 1;
 C$AFAC,5;22
 C$AFB1,2;22 %>
 C$AFB3,2;22
*C$AFB5,3;22
 C$AFB8,1;22 }
; Cutting wire only from here onwards?
 C$AFB9,3;22 A = IY[0]; // $8000,$8020,$8040,$8060
 C$AFBC,2;22 {if (A <= character_25_PRISONER_6) <% // a character index
 C$AFBE,2;22 }
 C$AFC0,3;22 collision();
 C$AFC3,1;22 if (!Z) return; %>
; noncolliding characters and items only at this point
*C$AFC4,4;22 IY[7] &= ~vischar_BYTE7_TOUCHING; // clear counter_and_flag
 C$AFC8,3;22 {memcpy(IY + 15, &saved_pos_x, 6); // $800F // vischar
 C$AFCB,2;22 pos = saved_pos
 C$AFCD,8;22
 C$AFD5,2;22 }
 C$AFD7,3;22 {IY[0x17] = touch_stashed_A; // left/right flip flag / sprite offset
 C$AFDA,3;22 }
 C$AFDD,1;22 A = 0;
 C$AFDE,1;22 return 0;

; (unknown) Definitely something to do with moving objects around. Collisions?
;
; Used by the routines at #R$AF8F and #R$C4E0.
@label=collision
cC$AFDF,3;23 HL = $8001; // &vischar[0].byte1;
 C$AFE2,2;23 B = 8; // 8 iterations
*C$AFE4,2;23 {do <% if (*HL & vischar_FLAGS_NO_COLLIDE) goto next;
 C$AFE6,3;23 // $8001, $8021, ...}
 C$AFE9,2
 C$AFEB,2;23 {  HL += 0x0E; // $800F etc. - X axis position
 C$AFED,1;23
 C$AFEE,1;23 }
; --------
 C$AFEF,1;23 {  C = *HL++;
 C$AFF0,1;23 }
 C$AFF1,1;23 B = *HL;
 C$AFF2,1
 C$AFF3,3;23 HL = saved_pos_x;
 C$AFF6,2;23 {  BC += 4;
 C$AFF8,5;23
 C$AFFD,1;23 }
*C$AFFE,2;23 {  if (HL != BC) <%
 C$B000,2;23 }
 C$B002,3;23 if (HL > BC) goto pop_next;
 C$B005,2;23 {    BC -= 8; // ie -4 over original
 C$B007,4;23
 C$B00B,1;23 }
*C$B00C,3;23 {    HL = saved_pos_x;
 C$B00F,2;23 }
 C$B011,3;23 if (HL < BC) goto pop_next; %>
*C$B014,1
 C$B015,1;23 HL++;
; --------
 C$B016,1;23 {  C = *HL++;
 C$B017,1;23 }
 C$B018,1;23 B = *HL;
 C$B019,1
 C$B01A,3;23 HL = saved_pos_y;
 C$B01D,2;23 {  BC += 4;
 C$B01F,5;23
 C$B024,1;23 }
*C$B025,2;23 {  if (HL != BC) <%
 C$B027,2;23 }
 C$B029,3;23 if (HL > BC) goto pop_next;
 C$B02C,2;23 {    BC -= 8;
 C$B02E,4;23
 C$B032,1;23 }
*C$B033,3;23 {    HL = saved_pos_y;
 C$B036,2;23 }
 C$B038,3;23 if (HL < BC) goto pop_next; %>
*C$B03B,1
 C$B03C,1;23 HL++;
; --------
 C$B03D,1;23 C = *HL;
 C$B03E,3;23 {  A = saved_height - C;
 C$B041,1;23 }
 C$B042,2;23 if (A < 0) <%
 C$B044,2;23 A = -A; %>
*C$B046,2;23 {  if (A >= 24) goto pop_next;
 C$B048,3;23 }
; If specified vischar character has a bribe pending...
 C$B04B,3;23 {  A = IY[1] & 0x0F; // sampled IY=$8020,$8040,$8060,$8000 // but this is *not* vischar_FLAGS_MASK, which is 0x1F
 C$B04E,2;23 }
 C$B050,2;23 {  if (A == vischar_FLAGS_PURSUE) <%
 C$B052,2;23 }
; and current vischar is not the hero...
 C$B054,1
 C$B055,1;23 // sampled HL=$8021,$8041,$8061,$80A1
 C$B056,1;23 HL--;
 C$B057,1;23 {    if ((HL & 0xFF) == 0) <% // ie. $8000
 C$B058,1;23
 C$B059,2;23 }
 C$B05B,3;23 {      if (bribed_character == IY[0]) <%
 C$B05E,3;23
 C$B061,2;23 }
 C$B063,3;23 accept_bribe(); %>
 C$B066,2;23 else <%
; A hostile catches the hero!
*C$B068,1
 C$B069,1
 C$B06A,2;23 {        HL = IY + 1;
 C$B06C,1;23
 C$B06D,1;23 }
 C$B06E,3;23 solitary(); return; // exit via %> %> %>
*C$B071,1
 C$B072,1;23 HL--;
 C$B073,1;23 A = *HL; // sampled HL=$80C0,$8040,$8000,$8020,$8060 // vischar_BYTE0
 C$B074,2;23 {  if (A >= 26) <%
 C$B076,2;23 }
 C$B078,2
 C$B07A,2;23 {    HL += 17; // &vischar->mi.pos.y
 C$B07C,1;23
 C$B07D,1;23 }
 C$B07E,1;23 tmpA = A; // retrieve character index
 C$B07F,3;23 B = 7; C = 35;
 C$B082,2
 C$B084,3;23 A = IY[14]; // interleaved
 C$B087,2;23 if (tmpA == character_28_CRATE) <%
 C$B089,1;23 {      L -= 2; // &vischar->mi.pos.x
 C$B08A,1;23 }
 C$B08B,2;23 C = 54;
 C$B08D,2;23 A ^= 1; %>
*C$B08F,1;23 {    if (A == 0) <%
 C$B090,2;23 }
 C$B092,1;23 A = *HL;
 C$B093,1;23 {      if (A != C) <%
 C$B094,2;23 }
 C$B096,2;23 {        if (C > A) (*HL) -= 2; // decrement by -2 then execute +1 anyway to avoid branch
 C$B098,1;23
 C$B099,1;23 }
*C$B09A,1;23 (*HL)++; %> %>
 C$B09B,2;23 {    else if (A == 1) <%
*C$B09D,2;23
 C$B09F,2;23 }
 C$B0A1,1;23 {      A = C + B;
 C$B0A2,1;23 }
 C$B0A3,1;23 {      if (A != *HL) (*HL)++; %>
 C$B0A4,2;23
 C$B0A6,1;23 }
 C$B0A7,2;23 {    else if (A == 2) <%
*C$B0A9,2;23
 C$B0AB,2;23 }
 C$B0AD,1;23 {      A = C - B;
 C$B0AE,1;23 }
 C$B0AF,1;23 *HL = A; %>
 C$B0B0,2;23 else <%
*C$B0B2,1;23 {      A = C - B;
 C$B0B3,1;23 }
 C$B0B4,1;23 {      if (A != *HL) (*HL)--; %>
 C$B0B5,2;23
 C$B0B7,1;23 }
*C$B0B8,1
*C$B0B9,1;23 %>
 C$B0BA,1;23 {  HL += 13;
 C$B0BB,2;23
 C$B0BD,1;23 }
 C$B0BE,1;23 {  A = *HL & ~input_KICK; // mask off kick flag // sampled HL=$806D,$804D,$802D,$808D,$800D}
 C$B0BF,2;23
 C$B0C1,2;23 if (A) <%
 C$B0C3,1;23 HL++;
 C$B0C4,1;23 {    A = *HL ^ 2; // swap direction: top <=> bottom
 C$B0C5,2;23 }
 C$B0C7,3;23 {    if (A != IY[14]) <%
 C$B0CA,2;23 }
 C$B0CC,4;23 IY[13] = input_KICK;
*C$B0D0,3;23 {      IY[7] = (IY[7] & vischar_BYTE7_MASK_HI) | 5; // preserve flags and set 5? // sampled IY=$8000,$80E0
 C$B0D3,4;23
 C$B0D7,3;23 }
 C$B0DA,1;23 if (!Z) return; /* odd */ %> %>
*C$B0DB,3;23 {  BC = IY[14]; // sampled IY=$8000,$8040,$80E0
 C$B0DE,2;23 }
@nowarn
 C$B0E0,3;23 {  IY[13] = collision_new_inputs[BC];
 C$B0E3,2;23
 C$B0E5,3;23 }
 C$B0E8,2;23 {  if ((C & 1) == 0) <%
 C$B0EA,2;23 }
 C$B0EC,4;23 IY[7] &= ~vischar_BYTE7_Y_DOMINANT;
 C$B0F0,2;23 goto $B0D0; %>
*C$B0F2,4;23 else <% IY[7] |= vischar_BYTE7_Y_DOMINANT;
 C$B0F6,2;23 goto $B0D0; %>
; New inputs.
@label=collision_new_inputs
 B$B0F8,1;23 input_DOWN + input_LEFT  + input_KICK
 B$B0F9,1;23 input_UP   + input_LEFT  + input_KICK
 B$B0FA,1;23 input_UP   + input_RIGHT + input_KICK
 B$B0FB,1;23 input_DOWN + input_RIGHT + input_KICK
*C$B0FC,1;23 pop_next:
 C$B0FD,1
*C$B0FE,1;23 {  next: HL += 32;
 C$B0FF,2;23
 C$B101,1;23 }
 C$B102,1;23 {%> while (--B);
 C$B103,3;23 }
 C$B106,1;23 return; // return with Z set

; Character accepts the bribe.
;
; Used by the routines at #R$AFDF and #R$CA81.
;
; I:IY Pointer to visible character.
@label=accept_bribe
cC$B107,3;23 increase_morale_by_10_score_by_50();
 C$B10A,4;23 IY[1] = 0;
 C$B10E,2;23 {HL = IY + 2;
 C$B110,2;23
 C$B112,1;23 }
 C$B113,3;23 get_target_assign_pos();
 C$B116,3;23 DE = &items_held[0];
 C$B119,1;23 {if (*DE != item_BRIBE && *++DE != item_BRIBE) return; // have no bribes
 C$B11A,8;23
 C$B122,1;23 }
; We have a bribe, take it away.
*C$B123,2;23 {*DE = item_NONE;
 C$B125,1;23 }
 C$B126,2;23 {item_structs[item_BRIBE].room = itemstruct_ROOM_MASK;
 C$B128,3;23 }
 C$B12B,3;23 draw_all_items();
 C$B12E,2;23 B = 7; // 7 iterations
; Iterate over hostile + visible non-player characters.
@nowarn
 C$B130,3;23 HL = $8020;
*C$B133,1;23 {do <% if (HL[0] <= character_19_GUARD_DOG_4) <% // Hostile characters only.
 C$B134,2;23
 C$B136,2;23 }
 C$B138,1;23 {    HL[1] = vischar_FLAGS_SAW_BRIBE; %> // hostile will look for bribed character?
 C$B139,2;23
 C$B13B,1;23 }
*C$B13C,1;23 {  HL += 32;
 C$B13D,2;23
 C$B13F,1;23 }
 C$B140,2;23 %> while (--B);
 C$B142,2;23 {queue_message(message_HE_TAKES_THE_BRIBE);
 C$B144,3;23 }
 C$B147,2;23 queue_message(message_AND_ACTS_AS_DECOY);
 C$B149,3;23 return; // exit via

; Check the character is inside of permitted areas.
;
; Used by the routines at #R$AF8F and #R$C4E0.
;
; I:IY Pointer to visible character.
@label=bounds_check
cC$B14C,3;21 {if (room_index) <% interior_bounds_check(); return; %>
 C$B14F,1;21
 C$B150,3;21 }
 C$B153,2;21 B = 24; // 24 iterations
 C$B155,3;21 DE = &walls[0];
*C$B158,1;21 do <%
 C$B159,1
 C$B15A,1;21 {
 C$B15B,3;21 }
 C$B15E,1;21 {  if ((saved_pos_x >= DE[0] * 8 + 2) &&
 C$B15F,6;21
 C$B165,2;21 }
 C$B167,1;21 {
 C$B168,1;21
 C$B169,3;21 }
 C$B16C,1;21 {      (saved_pos_x <  DE[1] * 8 + 4) &&
 C$B16D,8;21
 C$B175,2;21 }
 C$B177,1;21 {
 C$B178,1;21
 C$B179,3;21 }
 C$B17C,3;21 {      (saved_pos_y >= DE[2] * 8)     &&
 C$B17F,2;21
 C$B181,2;21 }
 C$B183,1;21 {
 C$B184,1;21
 C$B185,3;21 }
 C$B188,1;21 {      (saved_pos_y <  DE[3] * 8 + 4) &&
 C$B189,8;21
 C$B191,2;21 }
 C$B193,1;21 {
 C$B194,1;21
 C$B195,3;21 }
 C$B198,3;21 {      (saved_height >= DE[4] * 8)     &&
 C$B19B,2;21
 C$B19D,2;21 }
 C$B19F,1;21 {
 C$B1A0,1;21
 C$B1A1,3;21 }
 C$B1A4,1;21 {      (saved_height <  DE[5] * 8 + 2)) <%
 C$B1A5,6;21
 C$B1AB,2;21 }
; Found it.
 C$B1AD,2
 C$B1AF,3;21 {    IY[7] ^= vischar_BYTE7_Y_DOMINANT; // sampled IY=$80A0,$8080,$8060
 C$B1B2,2;21
 C$B1B4,3;21 }
 C$B1B7,2;21 A |= 1; // return NZ
 C$B1B9,1;21 return; %>
*C$B1BA,1
 C$B1BB,1
 C$B1BC,3;21 {  DE += 6;
 C$B1BF,1;21
 C$B1C0,1;21 }
 C$B1C1,1;21 {%> while (--B);
 C$B1C2,3;21 }
 C$B1C5,1;21 A &= B; // return Z
 C$B1C6,1;21 return;

; Multiplies A by 8, returning the result in BC.
;
; Used by the routines at #R$B14C, #R$C4E0, #R$CA11, #R$CA49 and #R$DBEB.
;
; I:A  Argument.
; O:BC Result of (A << 3).
@label=multiply_by_8
cC$B1C7,2;21 B = 0;
 C$B1C9,1;21 A <<= 1;
 C$B1CA,2;21 B = (B << 1) + carry;
 C$B1CC,1;21 A <<= 1;
 C$B1CD,2;21 B = (B << 1) + carry;
 C$B1CF,1;21 A <<= 1;
 C$B1D0,2;21 B = (B << 1) + carry;
 C$B1D2,1;21 C = A;
 C$B1D3,1;21 return;

; Locate current door, queuing a message if it's locked.
;
; Used by the routines at #R$B1F5 and #R$B32D.
;
; O:F Z set if door open.
@label=is_door_locked
cC$B1D4,2;21 {C = current_door & ~door_LOCKED; // probably door_REVERSE
 C$B1D6,4;21
 C$B1DA,1;21 }
 C$B1DB,3;21 HL = &locked_doors[0];
 C$B1DE,2;21 B = 9; // 9 iterations
*C$B1E0,1;21 {do <% if (*HL & ~door_LOCKED == C) <%
 C$B1E1,2;21
 C$B1E3,2;21 }
 C$B1E5,2;21 {    if ((*HL & door_LOCKED) == 0) return; // Door is open.
 C$B1E7,1;21
 C$B1E8,2;21 }
 C$B1EA,3;21 queue_message(message_THE_DOOR_IS_LOCKED);
 C$B1ED,2;21 A |= 1; // set NZ // Door is locked.
 C$B1EF,1;21 return; %>
*C$B1F0,1;21 HL++;
 C$B1F1,2;21 %> while (--B);
 C$B1F3,1;21 A &= B; // set Z (B is zero) // Door is open.
 C$B1F4,1;21 return;

; Door handling.
;
; Used by the routine at #R$AF8F.
;
; I:IY Pointer to visible character.
@label=door_handling
cC$B1F5,3;21 A = room_index;
; Interior doors are handled by another routine.
 C$B1F8,1;21 {if (A) goto door_handling_interior; // exit via
 C$B1F9,3;21 }
; Select start position in doors[] based on the direction the hero is
; facing.
 C$B1FC,3;21 HL = &doors[0];
 C$B1FF,3;21 E = IY[14]; // walk/crawl flag byte
 C$B202,1;21 {if (E >= 2) HL = &door_position[1]; /* BOTTOM_RIGHT or BOTTOM_LEFT */
 C$B203,4;21
 C$B207,3;21 }
*C$B20A,2;21 D = 3;  // mask
 C$B20C,2;21 B = 16; // 16 is the length of what?
*C$B20E,1;21 {do <% A = *HL & D;
 C$B20F,1;21 }
 C$B210,1;21 {  if (A == E) <%
 C$B211,2;21 }
 C$B213,3
 C$B216,3;21 door_in_range();
 C$B219,3
 C$B21C,2;21 if (!C) goto found; %>
*C$B21E,2;21 {  HL += 8; // step forward two entries
 C$B220,4;21
 C$B224,1;21 }
*C$B225,2;21 %> while (--B);
 C$B227,1;21 A &= B; // set Z (B is zero) // seems to exist to set Z, but routine doesn't return anything?
 C$B228,1;21 return;
*C$B229,2;21 {found: A = 16 - B;
 C$B22B,1;21 }
 C$B22C,3;21 current_door = A;
 C$B22F,1
 C$B230,3;21 is_door_locked();
 C$B233,1;21 if (!Z) return; // door was locked - return nonzero?
 C$B234,1
 C$B235,1;21 {IY[28] = (*HL >> 2) & 0x3F; // sampled HL=$792E (in doors[])
 C$B236,4;21
 C$B23A,3;21 }
 C$B23D,1;21 {if ((*HL & 3) >= 2) <% /* BR or BL */
 C$B23E,4;21
 C$B242,2;21 }
 C$B244,1;21 {  HL += 5; // point at the next door's pos
 C$B245,3;21
 C$B248,1;21 }
 C$B249,3;21 transition(); return; %> // seems to goto reset then jump back to main (icky)
*C$B24C,1;21 {else <% HL -= 3; // point at the previous door's pos
 C$B24D,1;21
 C$B24E,1;21 }
 C$B24F,3;21 transition(); return; %>

; Door in range.
;
; Used by the routines at #R$B1F5 and #R$B4D0.
; .
; (saved_X,saved_Y) within (-2,+2) of HL[1..] scaled << 2
;
; I:HL Pointer to (byte before) coord byte pair.
; O:F  C/NC if nomatch/match.
@label=door_in_range
cC$B252,1;21 {A = HL[1];
 C$B253,1;21 }
 C$B254,1
 C$B255,3;21 multiply_by_4();
 C$B258,1;21 {if (saved_pos_x < BC - 3 || saved_pos_x >= BC + 3) return; // with C set
 C$B259,6;21
*C$B25F,3;21
 C$B262,10;21
*C$B26C,3;21
 C$B26F,3;21
 C$B272,1;21 }
 C$B273,1
 C$B274,1;21 {A = HL[2];
 C$B275,1;21 }
 C$B276,3;21 multiply_by_4();
 C$B279,1
 C$B27A,1;21 {if (saved_pos_y < BC - 3 || saved_pos_y >= BC + 3) return; // with C set
 C$B27B,6;21
*C$B281,3;21
 C$B284,10;21
*C$B28E,3;21
 C$B291,2;21
 C$B293,1;21 }
 C$B294,1;21 return; // C not set

; Multiplies A by 4, returning the result in BC.
;
; Used by the routines at #R$68A2 and #R$B252.
;
; I:A  Argument.
; O:BC Result of (A << 2).
@label=multiply_by_4
cC$B295,2;21 B = 0;
 C$B297,1;21 A <<= 1;
 C$B298,2;21 B = (B << 1) + carry;
 C$B29A,1;21 A <<= 1;
 C$B29B,2;21 B = (B << 1) + carry;
 C$B29D,1;21 C = A;
 C$B29E,1;21 return;

; Check the character is inside of bounds, when indoors.
;
; Used by the routine at #R$B14C.
;
; I:IY Pointer to visible character.
; O:F  Z clear if boundary hit, set otherwise.
@label=interior_bounds_check
cC$B29F,3;21 {BC = &roomdef_dimensions[roomdef_bounds_index];
 C$B2A2,9;21
 C$B2AB,1;21 }
*C$B2AC,3;21 HL = &saved_pos_x;
 C$B2AF,1;21 A = *BC;
 C$B2B0,1;21 {if (A < *HL) goto stop;
 C$B2B1,2;21 }
 C$B2B3,1;21 {A = *++BC + 4;
 C$B2B4,1;21
 C$B2B5,2;21 }
 C$B2B7,1;21 {if (A >= *HL) goto stop;
 C$B2B8,2;21 }
 C$B2BA,1;21 {HL += 2;
 C$B2BB,1;21 }
; Bug: This instruction is stray code. DE is incremented but never used.
 C$B2BC,1;21 DE++;
 C$B2BD,1;21 {A = *++BC - 4;
 C$B2BE,1;21
 C$B2BF,2;21 }
 C$B2C1,1;21 {if (A < *HL) goto stop;
 C$B2C2,2;21 }
 C$B2C4,1;21 {A = *++BC;
 C$B2C5,1;21 }
 C$B2C6,1;21 {if (A >= *HL) goto stop;
 C$B2C7,2;21 }
 C$B2C9,3;21 HL = &roomdef_object_bounds[0];
 C$B2CC,1;21 {B = *HL; // iterations
 C$B2CD,1;21 }
 C$B2CE,1;21 {if (B == 0) return;
 C$B2CF,1;21 }
 C$B2D0,1;21 HL++;
*C$B2D1,1;21 do <%
 C$B2D2,1
 C$B2D3,3;21 DE = &saved_pos_x;
 C$B2D6,2;21 B = 2; // 2 iterations
*C$B2D8,1;21 do <% A = *DE;
 C$B2D9,1;21 {    if (A < HL[0] || A >= HL[1]) goto next; // next outer loop iteration
 C$B2DA,4;21
 C$B2DE,2;21 }
 C$B2E0,1;21 {    DE += 2;
 C$B2E1,1;21 }
 C$B2E2,1;21 HL += 2; // increment moved - hope it's still correct
 C$B2E3,2;21 %> while (--B);
; Found.
 C$B2E5,2
*C$B2E7,3;21 {stop: IY[7] ^= vischar_BYTE7_Y_DOMINANT; // stop character?
 C$B2EA,2;21
 C$B2EC,3;21 }
 C$B2EF,2;21 A |= 1;
 C$B2F1,1;21 return; // return NZ
; Next iteration.
*C$B2F2,1;21 next:
 C$B2F3,3;21 {  HL += 4;
 C$B2F6,1;21 }
 C$B2F7,1
 C$B2F8,2;21 %> while (--B);
; Not found.
 C$B2FA,1;21 A &= B; // B is zero here
 C$B2FB,1;21 return; // return Z

; Reset the hero's position, redraw the scene, then zoombox it onto the screen.
;
; Used by the routines at #R$68A2 and #R$9DE5.
;
; .
;
; Reset hero.
@label=reset_outdoors
cC$B2FC,3;21 HL = $8000;
 C$B2FF,3;21 calc_vischar_iso_pos_from_vischar();
; Centre the screen on the hero.
 C$B302,3;21 HL = $8018; // (vischar.screenpos.x)
 C$B305,1;21 {A = *HL++;
 C$B306,1;21 }
 C$B307,1;21 C = *HL;
 C$B308,3;21 divide_by_8(C,A);
 C$B30B,2;21 {map_position.x = A - 11; // 11 would be screen width minus half of character width?
 C$B30D,3;21 }
 C$B310,1;21 HL++;
 C$B311,1;21 {A = *HL++;
 C$B312,1;21 }
 C$B313,1;21 C = *HL;
 C$B314,3;21 divide_by_8(C,A);
 C$B317,2;21 {map_position.y = A - 6; // 6 would be screen height minus half of character height?
 C$B319,3;21 }
 C$B31C,1;21 {room_index = room_0_OUTDOORS;
 C$B31D,3;21 }
 C$B320,3;21 get_supertiles();
 C$B323,3;21 plot_all_tiles();
 C$B326,3;21 setup_movable_items();
 C$B329,3;21 zoombox();
 C$B32C,1;21 return;

; Door handling (indoors).
;
; Used by the routine at #R$B1F5.
;
; I:IY Pointer to visible character.
@label=door_handling_interior
cC$B32D,3;21 HL = &interior_doors;
*C$B330,1;21 for (;;) <% A = *HL;
 C$B331,2;21 {  if (A == door_NONE) return; /* Reached end of list. */
 C$B333,1;21 }
 C$B334,1
 C$B335,3;21 current_door = A;
 C$B338,3;21 HL = get_door();
 C$B33B,1;21 A = *HLdash;
 C$B33C,1;21 Cdash = A;
 C$B33D,2;21 {  Bdash = A & door_FLAGS_MASK_DIRECTION;
 C$B33F,1;21 }
 C$B340,3;21 {  if ((IY->direction & vischar_DIRECTION_MASK) != Bdash) goto next;
 C$B343,3;21
 C$B346,2;21 }
 C$B348,1;21 HLdash++;
 C$B349,1
 C$B34A,3;21 DEdash = &saved_pos_x; // reusing saved_pos as 8-bit here?
 C$B34D,2;21 Bdash = 2; // 2 iterations
*C$B34F,1;21 {  do <% A = *HLdash - 3;
 C$B350,2;21 }
 C$B352,1;21 {    if (A >= *DEdash || A + 6 < *DEdash) goto next; // -3 .. +3
 C$B353,5;21
 C$B358,2;21 }
 C$B35A,1;21 {    DEdash += 2;
 C$B35B,1;21 }
 C$B35C,1;21 HLdash++;
 C$B35D,2;21 %> while (--Bdash);
 C$B35F,1;21 HLdash++;
 C$B360,1
 C$B361,1;21 PUSH HLdash
 C$B362,1;21 PUSH BCdash
 C$B363,3;21 is_door_locked();
 C$B366,1;21 POP BCdash
 C$B367,1;21 POP HLdash
 C$B368,1;21 if (!Z) return; /* The door was locked. */
 C$B369,1;21 {  IY[28] = (Cdash >> 2) & 0x3F;
 C$B36A,4;21
 C$B36E,3;21 }
 C$B371,1;21 HLdash++;
 C$B372,3;21 {  if (current_door & door_REVERSE) <% HLdash -= 8; %>
 C$B375,10;21
 C$B37F,1;21 }
*C$B380,3;21 transition(); return; // exit via // with banked registers...
*C$B383,1;21 next:
 C$B384,1;21 HL++;
 C$B385,2;21 %>

; The hero has tried to open the red cross parcel.
@label=action_red_cross_parcel
cC$B387,2;21 {item_structs[item_RED_CROSS_PARCEL].room = itemstruct_ROOM_MASK; // room_NONE & 0x3F;
 C$B389,3;21 }
 C$B38C,3;21 HL = &items_held;
 C$B38F,2;21 {if (*HL != item_RED_CROSS_PARCEL) HL++; /* One or the other must be a red cross parcel item, so advance. */
 C$B391,3;21
 C$B394,1;21 }
*C$B395,2;21 *HL = item_NONE; /* Parcel opened. */
 C$B397,3;21 draw_all_items();
 C$B39A,3;21 A = red_cross_parcel_current_contents;
 C$B39D,3;21 drop_item_tail();
 C$B3A0,2;21 {queue_message(message_YOU_OPEN_THE_BOX);
 C$B3A2,3;21 }
 C$B3A5,3;21 increase_morale_by_10_score_by_50(); return; // exit via

; The hero tries to bribe a prisoner.
;
; This searches visible friendly characters only and returns the first found.
;
; .
;
; Walk non-player visible characters.
@label=action_bribe
@nowarn
cC$B3A8,3;21 HL = $8020; // iterate over non-player characters
 C$B3AB,2;21 B = 7; // 7 iterations
*C$B3AD,1;21 do <% A = *HL;
 C$B3AE,2;21 {  if ((A != character_NONE) && (A >= character_20_PRISONER_1)) goto found;
 C$B3B0,4;21
 C$B3B4,2;21 }
*C$B3B6,2;21 {  HL += 32; // sizeof a character struct
 C$B3B8,1;21
 C$B3B9,1;21 }
 C$B3BA,2;21 %> while (--B);
 C$B3BC,1;21 return;
*C$B3BD,3;21 found: bribed_character = A;
 C$B3C0,1;21 {HL[1] = vischar_FLAGS_PURSUE; // $8021 etc. // flag
 C$B3C1,2;21 }
 C$B3C3,1;21 return;

; Use poison.
@label=action_poison
cC$B3C4,3;21 Load items_held.
 C$B3C7,2;21 Load item_FOOD.
 C$B3C9,1;21 Is 'low' slot item_FOOD?
 C$B3CA,2;21 Yes - goto have_food.
 C$B3CC,1;21 Is 'high' slot item_FOOD?
 C$B3CD,1;21 No - return.
@label=action_poison_have_food
*C$B3CE,3;21 have_food: &item_structs[item_FOOD].item
 C$B3D1,2;21 Bit 5 set?
 C$B3D3,1;21 Yes - return.
 C$B3D4,2;21 Set bit 5.
 C$B3D6,2;21 {Set item_attribute: FOOD to bright-purple/black.
 C$B3D8,3;21 }
 C$B3DB,3;21 draw_all_items()
 C$B3DE,3;21 goto increase_morale_by_10_score_by_50

; Use uniform.
@label=action_uniform
cC$B3E1,3;21 HL = $8015; // current character sprite set
 C$B3E4,3;21 DE = &sprite_guard;
 C$B3E7,1;21 {if (*HL == E) return; // cheap equality test /* Already in uniform. */
 C$B3E8,1;21
 C$B3E9,1;21 }
 C$B3EA,3;21 {if (room_index >= room_29_SECOND_TUNNEL_START) return; // can't don uniform when in a tunnel
 C$B3ED,2;21
 C$B3EF,1;21 }
 C$B3F0,1;21 *HL++ = E;
 C$B3F1,1;21 {*HL = D;
 C$B3F2,1;21 }
 C$B3F3,3;21 increase_morale_by_10_score_by_50(); return;

; Use shovel.
@label=action_shovel
cC$B3F6,3;21 {if (room_index != room_50_BLOCKED_TUNNEL) return; /* Shovel only works in the blocked tunnel room. */
 C$B3F9,2;21
 C$B3FB,1;21 }
 C$B3FC,3;21 {if (roomdef_50_blocked_tunnel_boundary[0] == 255) return; /* Blockage is already cleared. */
 C$B3FF,2;21
 C$B401,1;21 }
; Release boundary.
 C$B402,2;21 {roomdef_50_blocked_tunnel_boundary[0] = 255;
 C$B404,3;21 }
; Remove blockage graphic.
 C$B407,1;21 {roomdef_50_blocked_tunnel_collapsed_tunnel = 0;
 C$B408,3;21 }
 C$B40B,3;21 setup_room();
 C$B40E,3;21 choose_game_window_attributes();
 C$B411,3;21 plot_interior_tiles();
 C$B414,3;21 increase_morale_by_10_score_by_50(); return; // exit via

; Use wiresnips.
@label=action_wiresnips
cC$B417,3;21 HL = &walls[12] + 3;
 C$B41A,3;21 DE = &hero_map_position.x;
 C$B41D,2;21 B = 4; // iterations
*C$B41F,1;21 do <% ...
 C$B420,1;21 A = *DE;
 C$B421,1;21 {  if (A >= *HL) goto next;
 C$B422,2;21 }
 C$B424,1;21 HL--;
 C$B425,1;21 {  if (A < *HL) goto next;
 C$B426,2;21 }
 C$B428,1;21 DE--; // &hero_map_position.y;
 C$B429,1;21 A = *DE;
 C$B42A,1;21 HL--;
 C$B42B,1;21 {  if (A == *HL) goto set_to_4;
 C$B42C,2;21 }
 C$B42E,1;21 A--;
 C$B42F,1;21 {  if (A == *HL) goto set_to_6;
 C$B430,2;21 }
 C$B432,1;21 DE++; // reset to Y
*C$B433,1;21 next: ...
 C$B434,1;21 {  HL += 6; // array stride
 C$B435,5;21
 C$B43A,1;21 }
*C$B43B,2;21 %> while (--B);
 C$B43D,1;21 DE--; // &hero_map_position.y;
 C$B43E,1;21 {HL -= 3; // pointing to $B59E
 C$B43F,1;21
 C$B440,1;21 }
 C$B441,2;21 B = 3; // iterations
*C$B443,1;21 do <% ...
 C$B444,1;21 A = *DE;
 C$B445,1;21 {  if (A < *HL) goto next2;
 C$B446,2;21 }
 C$B448,1;21 HL++;
 C$B449,1;21 {  if (A >= *HL) goto next2;
 C$B44A,2;21 }
 C$B44C,1;21 DE++;
 C$B44D,1;21 A = *DE;
 C$B44E,1;21 HL++;
 C$B44F,1;21 {  if (A == *HL) goto set_to_5;
 C$B450,2;21 }
 C$B452,1;21 A--;
 C$B453,1;21 {  if (A == *HL) goto set_to_7;
 C$B454,2;21 }
 C$B456,1;21 DE--;
*C$B457,1;21 next2: ...
 C$B458,1;21 {  HL += 6; // array stride
 C$B459,5;21
 C$B45E,1;21 }
*C$B45F,2;21 %> while (--B);
 C$B461,1;21 {return;
*C$B462,2;21
 C$B464,2;21 }
*C$B466,2;21 {set_to_5: A = 5; goto action_wiresnips_tail; // crawl TR
 C$B468,2;21 }
*C$B46A,2;21 {set_to_6: A = 6; goto action_wiresnips_tail; // crawl BR
 C$B46C,2;21 }
*C$B46E,2;21 set_to_7: A = 7;                             // crawl BL
*C$B470,1;21 action_wiresnips_tail: ...
@nowarn
 C$B471,3;21 {$800E = A; // walk/crawl flag
 C$B474,1;21 }
 C$B475,1;21 {$800D = input_KICK;
 C$B476,2;21 }
 C$B478,3;21 {$8001 = vischar_FLAGS_CUTTING_WIRE;
 C$B47B,2;21 }
 C$B47D,2;21 {$8013 = 12; // set height
 C$B47F,3;21 }
 C$B482,3;21 {$8015 = sprite_prisoner;
 C$B485,3;21 }
 C$B488,3;21 {player_locked_out_until = game_counter + 96;
 C$B48B,2;21
 C$B48D,3;21 }
 C$B490,2;21 {queue_message(message_CUTTING_THE_WIRE);
 C$B492,3;21 }

; Use lockpick.
@label=action_lockpick
cC$B495,3;21 get_nearest_door();
 C$B498,1;21 if (!Z) return; /* No door nearby. */
 C$B499,3;21 ptr_to_door_being_lockpicked = HL;
 C$B49C,3;21 {player_locked_out_until = game_counter + 255;
 C$B49F,2;21
 C$B4A1,3;21 }
 C$B4A4,3;21 {($8001) = vischar_FLAGS_PICKING_LOCK;
 C$B4A7,2;21 }
 C$B4A9,2;21 {queue_message(message_PICKING_THE_LOCK);
 C$B4AB,3;21 }

; Use red key.
@label=action_red_key
cC$B4AE,2;21 A = room_22_REDKEY;
 C$B4B0,2;21 goto action_key;

; Use yellow key.
@label=action_yellow_key
cC$B4B2,2;21 A = room_13_CORRIDOR;
 C$B4B4,2;21 goto action_key;

; Use green key.
@label=action_green_key
cC$B4B6,2;21 A = room_14_TORCH;
; FALL THROUGH into action_key.

; Use a key.
;
; Used by the routines at #R$B4AE and #R$B4B2.
;
; I:A Room number to which the key applies.
@label=action_key
cC$B4B8,1
 C$B4B9,3;21 get_nearest_door();
 C$B4BC,1
 C$B4BD,1;21 if (!Z) return; /* No door nearby. */
 C$B4BE,1;21 {A = *HL & ~door_LOCKED; // mask off locked flag
 C$B4BF,2;21 }
 C$B4C1,1;21 if (A != B) <%
 C$B4C2,2;21 B = message_INCORRECT_KEY; %>
 C$B4C4,2;21 else <%
 C$B4C6,2;21 *HL &= ~door_LOCKED; /* Unlock. */
 C$B4C8,3;21 increase_morale_by_10_score_by_50();
 C$B4CB,2;21 B = message_IT_IS_OPEN; %>
*C$B4CD,3;21 queue_message(B); // exit via

; Return the door in range of the hero.
;
; Used by the routines at #R$B495 and #R$B4B8.
;
; O:HL Pointer to door in locked_doors.
; O:F  Returns NZ if door not found.
@label=get_nearest_door
cC$B4D0,3;21 {if (room_index == room_0_OUTDOORS) goto outdoors; else goto indoors;
 C$B4D3,3;21
 C$B4D6,3;21 }
; Bug: Needless jump.
; .
; Outdoors.
*C$B4D9,2;21 outdoors: B = 5; // 5 iterations
 C$B4DB,3;21 HL = &locked_doors[0];
*C$B4DE,1;21 {do <% A = *HL & ~door_LOCKED;
 C$B4DF,2;21 }
 C$B4E1,1
 C$B4E2,3;21 HL = get_door();
 C$B4E5,1
 C$B4E6,3;21 door_in_range();
 C$B4E9,1
 C$B4EA,2;21 if (!C) goto not_in_range;
 C$B4EC,1;21 {  HL += 4;
 C$B4ED,2;21
 C$B4EF,1;21 }
 C$B4F0,3;21 door_in_range();
 C$B4F3,2;21 if (!C) goto not_in_range;
 C$B4F5,1
 C$B4F6,1;21 HL++;
 C$B4F7,2;21 %> while (--B);
 C$B4F9,1;21 return;
*C$B4FA,1;21 not_in_range:
 C$B4FB,1;21 A = 0;
 C$B4FC,1;21 return;
; Indoors.
@nowarn
*C$B4FD,3;21 indoors: HL = &locked_doors[2];
 C$B500,2;21 B = 8; // 8 iterations // Bug: Ought to be 7 iterations.
*C$B502,1;21 {do <% C = *HL & ~door_LOCKED;
 C$B503,2;21
 C$B505,1;21 }
; Search interior doors for C.
 C$B506,3;21 DE = &interior_doors;
*C$B509,1;21 for (;;) <% A = *DE;
 C$B50A,2;21 {    if (A != door_NONE) <% // door_NONE => end of list
 C$B50C,2;21 }
 C$B50E,2;21 {      if ((A & ~door_REVERSE) == C) goto found;
 C$B510,1;21
 C$B511,2;21 }
 C$B513,1;21 {      DE++; %> %>
 C$B514,2;21 }
*C$B516,1;21 next: HL++;
 C$B517,2;21 %> while (--B);
 C$B519,2;21 A |= 1;
 C$B51B,1;21 return;
*C$B51C,1;21 found: A = *DE;
 C$B51D,1
 C$B51E,3;21 HL = get_door();
 C$B521,1;21 HL++;
 C$B522,1
; Range check pattern (-2..+3).
 C$B523,3;21 HL = &saved_pos_x; // note: 16-bit values holding 8-bit values
 C$B526,2;21 B = 2; // 2 iterations
*C$B528,1;21 {do <% if (*HL <= *DE - 3 || *HL > *DE + 3) goto exx_next;
 C$B529,8;21
 C$B531,2;21 }
 C$B533,1;21 {  HL += 2;
 C$B534,1;21 }
 C$B535,1;21 DE++;
 C$B536,2;21 %> while (--B);
 C$B538,1
 C$B539,1;21 A = 0; // ok
 C$B53A,1;21 return;
*C$B53B,1;21 exx_next:
 C$B53C,2;21 goto next;

; Wall boundaries.
@label=walls
bB$B53E,6;36 0x6A, 0x6E, 0x52, 0x62, 0, 11 ;  0: hut 1 (leftmost on main map)
 B$B544,6;36 0x5E, 0x62, 0x52, 0x62, 0, 11 ;  1: hut 2
 B$B54A,6;36 0x52, 0x56, 0x52, 0x62, 0, 11 ;  2: hut 3 (rightmost on main map)
 B$B550,6;36 0x3E, 0x5A, 0x6A, 0x80, 0, 48 ;  3: main building
 B$B556,6;36 0x34, 0x80, 0x72, 0x80, 0, 48 ;  4: main building
 B$B55C,6;36 0x7E, 0x98, 0x5E, 0x80, 0, 48 ;  5: main building
 B$B562,6;36 0x82, 0x98, 0x5A, 0x80, 0, 48 ;  6: main building
 B$B568,6;36 0x86, 0x8C, 0x46, 0x80, 0, 10 ;  7: west wall
 B$B56E,6;36 0x82, 0x86, 0x46, 0x4A, 0, 18 ;  8: west turret wall
 B$B574,6;36 0x6E, 0x82, 0x46, 0x47, 0, 10 ;  9: south wall
 B$B57A,6;36 0x6D, 0x6F, 0x45, 0x49, 0, 18 ; 10: gate wall left
 B$B580,6;36 0x67, 0x69, 0x45, 0x49, 0, 18 ; 11: gate wall right
 B$B586,6;36 0x46, 0x46, 0x46, 0x6A, 0, 8  ; 12: fence inner (vertical)
 B$B58C,6;36 0x3E, 0x3E, 0x3E, 0x6A, 0, 8  ; 13: fence outer (vertical)
 B$B592,6;36 0x4E, 0x4E, 0x2E, 0x3E, 0, 8  ; 14: fence outer exercise (vertical)
 B$B598,6;36 0x68, 0x68, 0x2E, 0x45, 0, 8  ; 15: fence outer exercise (vertical)
 B$B59E,6;36 0x3E, 0x68, 0x3E, 0x3E, 0, 8  ; 16: fence inner exercise (horizontal)
 B$B5A4,6;36 0x4E, 0x68, 0x2E, 0x2E, 0, 8  ; 17: fence outer exercise (horizontal)
 B$B5AA,6;36 0x46, 0x67, 0x46, 0x46, 0, 8  ; 18: fence inner (horizontal)
 B$B5B0,6;36 0x68, 0x6A, 0x38, 0x3A, 0, 8  ; 19: tower outside exercise yard
 B$B5B6,6;36 0x4E, 0x50, 0x2E, 0x30, 0, 8  ; 20: tower inside exercise yard
 B$B5BC,6;36 0x46, 0x48, 0x46, 0x48, 0, 8  ; 21: tower at corner of main yard
 B$B5C2,6;36 0x46, 0x48, 0x5E, 0x60, 0, 8  ; 22: tower at north east of main yard
 B$B5C8,6;36 0x69, 0x6D, 0x46, 0x49, 0, 8  ; 23: gate wall middle

; Animate all visible characters.
;
; Used by the routines at #R$6939 and #R$9D7B.
@label=animate
cC$B5CE,2;23 iterate over all eight vischars
 C$B5D0,4;23 set IY to first vischar
*C$B5D4,3;23 get vischar.flags
 C$B5D7,2;23 are flags set to vischar_FLAGS_EMPTY_SLOT?
 C$B5D9,3;23 if so - continue to next iteration
 C$B5DC,1;23 stack counter
 C$B5DD,4;23 set flag vischar_FLAGS_NO_COLLIDE
 C$B5E1,4;23 test vischar.input & input_KICK
 C$B5E5,3;23 if set goto 'kicked'
 C$B5E8,3;23 get vischar.anim in HL
 C$B5EB,3;23
 C$B5EE,3;23 ?anim index vischar.animindex
 C$B5F1,1;23 test vischar_ANIMINDEX_BIT7  up/down flag ?
 C$B5F2,3;23
 C$B5F5,2;23 mask off vischar_ANIMINDEX_BIT7
 C$B5F7,3;23 if result is zero goto 'end_bit'
 C$B5FA,1;23 { anim = HL + (A + 1) * 4 - 1
 C$B5FB,6;23
 C$B601,1;23 }
 C$B602,1;23 A = *HL; // a spriteindex_t
 C$B603,1;23 bank A
 C$B604,1;23 HL++
*C$B605,1;23 decrement:
 C$B606,3;23 L = IY[0x0F]; // X axis
 C$B609,3;23 H = IY[0x10];
 C$B60C,1;23 A = *DE; // sampled DE=$CF9A,$CF9E,$CFBE,$CFC2,$CFB2,$CFB6,$CFA6,$CFAA (character_related_data)
 C$B60D,1;23 C = A;
 C$B60E,2;23 A &= 0x80;
 C$B610,2;23 {    if (A) A = 0xFF;
 C$B612,2;23 }
*C$B614,1;23 B = A;
 C$B615,2;23 HL -= BC;
 C$B617,3;23 saved_pos_x = HL;
 C$B61A,1;23 DE++;
 C$B61B,3;23 L = IY[0x11]; // Y axis
 C$B61E,3;23 H = IY[0x12];
 C$B621,1;23 A = *DE;
 C$B622,1;23 C = A;
 C$B623,2;23 A &= 0x80;
 C$B625,2;23 {    if (A) A = 0xFF;
 C$B627,2;23 }
*C$B629,1;23 B = A;
 C$B62A,2;23 HL -= BC;
 C$B62C,3;23 saved_pos_y = HL;
 C$B62F,1;23 DE++;
 C$B630,3;23 L = IY[0x13]; // height
 C$B633,3;23 H = IY[0x14];
 C$B636,1;23 A = *DE;
 C$B637,1;23 C = A;
 C$B638,2;23 A &= 0x80;
 C$B63A,2;23 {    if (A) A = 0xFF;
 C$B63C,2;23 }
*C$B63E,1;23 B = A;
 C$B63F,2;23 HL -= BC;
 C$B641,3;23 saved_height = HL;
 C$B644,3;23 touch();
 C$B647,3;23 if (!Z) goto pop_next;
 C$B64A,3;23 IY[0x0C]--;
 C$B64D,2;23 %>
*C$B64F,1;23 {  else <% if (A == *HL) goto end_bit;
 C$B650,3;23 }
 C$B653,1;23 {    HL += (A + 1) * 4;
 C$B654,5;23
 C$B659,1;23 }
*C$B65A,1;23 increment:
 C$B65B,1;23 A = *DE;
 C$B65C,1;23 L = A;
 C$B65D,2;23 A &= 0x80;
 C$B65F,2;23 {    if (A) A = 0xFF;
 C$B661,2;23 }
*C$B663,1;23 H = A;
 C$B664,3;23 C = IY[0x0F]; // X axis
 C$B667,3;23 B = IY[0x10];
 C$B66A,1;23 HL += BC;
 C$B66B,3;23 saved_pos_x = HL;
 C$B66E,1;23 DE++;
 C$B66F,1;23 A = *DE;
 C$B670,1;23 L = A;
 C$B671,2;23 A &= 0x80;
 C$B673,2;23 {    if (A) A = 0xFF;
 C$B675,2;23 }
*C$B677,1;23 H = A;
 C$B678,3;23 C = IY[0x11]; // Y axis
 C$B67B,3;23 B = IY[0x12];
 C$B67E,1;23 HL += BC;
 C$B67F,3;23 saved_pos_y = HL;
 C$B682,1;23 DE++;
 C$B683,1;23 A = *DE;
 C$B684,1;23 L = A;
 C$B685,2;23 A &= 0x80;
 C$B687,2;23 {    if (A) A = 0xFF;
 C$B689,2;23 }
*C$B68B,1;23 H = A;
 C$B68C,3;23 C = IY[0x13]; // height
 C$B68F,3;23 B = IY[0x14];
 C$B692,1;23 HL += BC;
 C$B693,3;23 saved_height = HL;
 C$B696,1;23 DE++;
 C$B697,1;23 A = *DE; // sprite_index
 C$B698,1
 C$B699,3;23 touch();
 C$B69C,3;23 if (!Z) goto pop_next;
 C$B69F,3;23 IY[0x0C]++; %>
*C$B6A2,2;23 {  HL = IY;
 C$B6A4,1;23 }
 C$B6A5,3;23 calc_vischar_iso_pos_from_state();
*C$B6A8,1;23 pop_next:
 C$B6A9,3;23 {  if (IY[1] != vischar_FLAGS_EMPTY_SLOT) IY[1] &= ~vischar_FLAGS_NO_COLLIDE; // $8001
 C$B6AC,4;23
 C$B6B0,4;23 }
*C$B6B4,3;23 next: DE = 32; // stride
 C$B6B7,2;23 IY += DE;
 C$B6B9,1;23 {%> while (--B);
 C$B6BA,3;23 }
 C$B6BD,1;23 return;
@label=kicked
*C$B6BE,4;23 reset input_KICK flag
@label=end_bit
*C$B6C2,3;23 get vischar.direction
 C$B6C5,1;23 {multiply it by 9
 C$B6C6,3;23
 C$B6C9,1;23 }
 C$B6CA,3;23 add vischar.input to it
 C$B6CD,3;23
 C$B6D0,3;23 add it to animindices
 C$B6D3,1;23
 C$B6D4,1;23 fetch the (table entry)
 C$B6D5,1;23
 C$B6D6,3;23 HL = vischar.animbase
 C$B6D9,3;23
 C$B6DC,1;23 double A (and in doing so discard the top bit!)
 C$B6DD,1;23
 C$B6DE,1;23 (D is still zero from above)
 C$B6DF,1;23 { vischar.anim = *HL
 C$B6E0,5;23
 C$B6E5,3;23 }
 C$B6E8,2;23 {if ((C & (1<<7)) == 0) <%
 C$B6EA,2;23 }
 C$B6EC,4;23 vischar.animindex = 0
 C$B6F0,1;23 {  DE += 2;
 C$B6F1,1;23 }
 C$B6F2,1;23 { vischar.direction = *DE;
 C$B6F3,3;23 }
 C$B6F6,1;23 {  DE += 2; // point to groups of four
 C$B6F7,1;23 }
 C$B6F8,1
 C$B6F9,3;23 goto increment
; else
*C$B6FC,1;23 A = *DE; // count of four-byte groups
 C$B6FD,1;23 C = A;
 C$B6FE,2;23 {  vischar.animindex = A | vischar_ANIMINDEX_BIT7;
 C$B700,3;23 }
 C$B703,1;23 {  vischar.direction = *++DE;
 C$B704,1;23
 C$B705,3;23 }
 C$B708,1;23 {  DE += 3; // point to groups of four
 C$B709,1;23
 C$B70A,1;23 }
 C$B70B,2
 C$B70D,1;23 {  HL += C * 4 - 1;
 C$B70E,6;23
 C$B714,1;23 }
 C$B715,1;23 A = *HL;
 C$B716,2
 C$B718,3;23 goto decrement

; Reset position.
;
; Used by the routines at #R$68F4, #R$697D, #R$A491, #R$B2FC and #R$C4E0.
;
; I:HL Pointer to visible character.
@label=calc_vischar_iso_pos_from_vischar
cC$B71B,1
; Save a copy of the vischar's position + offset.
 C$B71C,2;21 {memcpy(&saved_pos_x, HL + 0x0F, 6);
 C$B71E,8;21
 C$B726,2;21 }
 C$B728,1
; FALL THROUGH into calc_vischar_iso_pos_from_state.

; Calculate screen position for vischars from saved_pos.
;
; Used by the routine at #R$B5CE.
; .
; Similar to drop_item_tail_interior.
;
; I:HL Pointer to visible character.
@label=calc_vischar_iso_pos_from_state
cC$B729,1
 C$B72A,2;21 {HL += 0x18; // vischar->scrx/y
 C$B72C,1;21
 C$B72D,1;21 }
 C$B72E,3;21 {DE = saved_pos_y + 0x0200;
 C$B731,3;21
 C$B734,1;21 }
 C$B735,5
 C$B73A,2;21 {DE = (DE - saved_pos_x) * 2;
 C$B73C,1;21 }
 C$B73D,1
 C$B73E,1;21 {*HL++ = E;
 C$B73F,1;21 }
 C$B740,1;21 {*HL++ = D;
 C$B741,1;21 }
 C$B742,1
 C$B743,3;21 {DE = 0x0800 - saved_pos_x - saved_height - saved_pos_y;
 C$B746,13;21
 C$B753,2;21 }
 C$B755,1
 C$B756,1;21 {*HL++ = E;
 C$B757,1;21 }
 C$B758,1;21 *HL = D;
 C$B759,1;21 return;

; Reset the game.
;
; Used by the routines at #R$9DE5, #R$A51C and #R$F163.
;
; .
;
; Cause discovery of all items.
@label=reset_game
cC$B75A,3;21 B = item__LIMIT; C = 0;
*C$B75D,1;21 do <%
 C$B75E,3;21 item_discovered(C); // pass C as C
 C$B761,1
 C$B762,1;21 C++;
 C$B763,2;21 %> while (--B);
; Reset message queue.
 C$B765,3;21 {message_queue_pointer = message_queue + 2;
 C$B768,3;21 }
 C$B76B,3;21 reset_map_and_characters();
 C$B76E,1;21 {$8001 = 0; // vischars[0].flags = 0
 C$B76F,3;21 }
; Reset score digits, hero_in_breakfast, red_flag, automatic_player_counter, in_solitary, morale_exhausted.
 C$B772,3;21 HL = &score_digits[0];
 C$B775,2;21 B = 10; // iterations
*C$B777,1;21 {do <% *HL++ = 0;
 C$B778,1;21 }
 C$B779,2;21 %> while (--B); // could do a memset
; Reset morale.
 C$B77B,2;21 morale = morale_MAX;
 C$B77D,3;21 plot_score();
; Reset and redraw items.
 C$B780,3;21 {items_held = item_NONE | (item_NONE << 8);
 C$B783,3;21 }
 C$B786,3;21 draw_all_items();
; Reset the hero's sprite.
 C$B789,3;21 {$8015 = sprite_prisoner;
 C$B78C,3;21 }
 C$B78F,2;21 {room_index = room_2_HUT2LEFT;
 C$B791,3;21 }
; Put the hero to bed.
 C$B794,3;21 hero_sleeps();
 C$B797,3;21 enter_room();
 C$B79A,1;21 return;

; Resets all visible characters, clock, day_or_night flag, general flags,
; collapsed tunnel objects, locks the gates, resets all beds, clears the mess
; halls and resets characters.
;
; Used by the routines at #R$B75A and #R$CB98.
@label=reset_map_and_characters
cC$B79B,2;24 B = 7; // iterations
@nowarn
 C$B79D,3;24 HL = $8020; // iterate over non-player characters
*C$B7A0,1;24 {do <%
 C$B7A1,1;24 }
 C$B7A2,3;24 {  reset_visible_character();
 C$B7A5,1;24 }
 C$B7A6,1;24 {  HL += 32;
 C$B7A7,3;24
 C$B7AA,1;24 }
 C$B7AB,2;24 %> while (--B);
 C$B7AD,2;24 {clock = 7;
 C$B7AF,3;24 }
 C$B7B2,1;24 {day_or_night = 0;
 C$B7B3,3;24 }
 C$B7B6,3;24 ($8001) = 0; // flags
 C$B7B9,2;24 {roomdef_50_blocked_tunnel_collapsed_tunnel = interiorobject_COLLAPSED_TUNNEL_SW_NE;
 C$B7BB,3;24 }
 C$B7BE,2;24 {blockage = 0x34; /* Reset boundary. */
@nowarn
 C$B7C0,3;24 }
; Lock the gates.
 C$B7C3,3;24 HL = &locked_doors[0];
 C$B7C6,2;24 B = 9; // 9 iterations
*C$B7C8,2;24 {do <% *HL++ |= door_LOCKED;
 C$B7CA,1;24 }
 C$B7CB,2;24 %> while (--B);
; Reset all beds.
 C$B7CD,2;24 B = 6; // iterations
 C$B7CF,2;24 {HL = &beds[0];
 C$B7D1,3;24 }
*C$B7D4,1;24 {do <% E = *HL++;
 C$B7D5,1;24 }
 C$B7D6,1;24 {  D = *HL++;
 C$B7D7,1;24 }
 C$B7D8,1;24 *DE = interiorobject_OCCUPIED_BED;
 C$B7D9,2;24 %> while (--B);
; Clear the mess halls.
 C$B7DB,2;24 {roomdef_23_breakfast.bench_A = interiorobject_EMPTY_BENCH;
 C$B7DD,3;24 }
 C$B7E0,3;24 roomdef_23_breakfast.bench_B = interiorobject_EMPTY_BENCH;
 C$B7E3,3;24 roomdef_23_breakfast.bench_C = interiorobject_EMPTY_BENCH;
 C$B7E6,3;24 roomdef_25_breakfast.bench_D = interiorobject_EMPTY_BENCH;
 C$B7E9,3;24 roomdef_25_breakfast.bench_E = interiorobject_EMPTY_BENCH;
 C$B7EC,3;24 roomdef_25_breakfast.bench_F = interiorobject_EMPTY_BENCH;
 C$B7EF,3;24 roomdef_25_breakfast.bench_G = interiorobject_EMPTY_BENCH;
; Reset characters 12..15 (guards) and 20..25 (prisoners).
 C$B7F2,3;24 DE = &character_structs[12].room;
 C$B7F5,2;24 C = 10; // iterations
@nowarn
 C$B7F7,3;24 HL = &character_reset_data[0];
*C$B7FA,2;24 {do <% memcpy(DE, HL, 3); DE += 3; HL += 3;
*C$B7FC,1;24
 C$B7FD,5;24
 C$B802,1;24 }
 C$B803,2;24 {  *DE++ = 18; /* Bug/Odd: This is reset to 18 but the initial data is 24. */
 C$B805,1;24 }
 C$B806,2;24 {  *DE++ = 0x00;
 C$B808,1;24 }
 C$B809,1;24 {  DE += 2;
 C$B80A,1;24
 C$B80B,1;24 }
 C$B80C,1;24 {  if (C == 7) DE = &character_structs[20].room;
 C$B80D,4;24
 C$B811,3;24 }
*C$B814,1;24 {%> while (--C);
 C$B815,3;24 }
 C$B818,1;24 return;
; 10 x 3-byte structs
; .
; struct { byte room; byte x; byte y; }; // partial of character_struct
@label=character_reset_data
 B$B819,3;24 room_3_HUT2RIGHT, 40,60 // for character 12
 B$B81C,3;24 room_3_HUT2RIGHT, 36,48 // for character 13
 B$B81F,3;24 room_5_HUT3RIGHT, 40,60 // for character 14
 B$B822,3;24 room_5_HUT3RIGHT, 36,34 // for character 15
 B$B825,3;24 room_NONE,        52,60 // for character 20
 B$B828,3;24 room_NONE,        52,44 // for character 21
 B$B82B,3;24 room_NONE,        52,28 // for character 22
 B$B82E,3;24 room_NONE,        52,60 // for character 23
 B$B831,3;24 room_NONE,        52,44 // for character 24
 B$B834,3;24 room_NONE,        52,28 // for character 25

; render_mask_buffer stuff.
@label=clip_x0
gB$B837,1
@label=clip_y0
 B$B838,1
@label=clip_height
 B$B839,1
@label=clip_width
 B$B83A,1

; Check the mask buffer to see if the hero is hiding behind something.
;
; Used by the routine at #R$B866.
;
; I:IY Pointer to visible character.
@label=searchlight_mask_test
cC$B83B,2;21 {HL = IY;
 C$B83D,1;21 }
 C$B83E,1;21 {if (L) return; /* Skip non-hero characters. */
 C$B83F,1;21
 C$B840,1;21 }
 C$B841,3;21 HL = $8100 + $31; // mask_buffer + 0x31
; Bug: Does a fused load of BC, but doesn't use C after. Probably a leftover
; stride constant.
 C$B844,3;21 BC = 0x0804; // 8 iterations
 C$B847,1;21 {do <% if (*HL != 0) goto still_in_searchlight;
*C$B848,1;21
 C$B849,2;21 }
 C$B84B,1;21 {  HL += 4; // stride is 4?
 C$B84C,2;21
 C$B84E,1;21 }
 C$B84F,2;21 %> while (--B);
; Otherwise the hero has escaped the searchlight, so decrement the counter.
 C$B851,3;21 HL = &searchlight_state;
 C$B854,1;21 (*HL)--;
 C$B855,2;21 {if (searchlight_STATE_SEARCHING != *HL) return;
 C$B857,1;21
 C$B858,1;21 }
 C$B859,3;21 choose_game_window_attributes();
 C$B85C,3;21 set_game_window_attributes();
 C$B85F,1;21 return;
@label=still_in_searchlight
*C$B860,3;21 {searchlight_state = searchlight_STATE_CAUGHT;
 C$B863,2;21 }
 C$B865,1;21 return;

; Plot vischars and items in order.
;
; Used by the routines at #R$6939 and #R$9D7B.
;
; .
;
@label=plot_sprites
; This can return a vischar OR an itemstruct, but not both.
cC$B866,3;21 locate_vischar_or_itemstruct();
 C$B869,1;21 if (!Z) return;
 C$B86A,2;21 {if ((A & (1<<6)) == 0) <% // mysteryflagconst874 'item found' flag
 C$B86C,2;21 }
 C$B86E,3;21 setup_vischar_plotting();
 C$B871,2;21 if (!Z) goto plot_sprites;
 C$B873,3;21 render_mask_buffer();
 C$B876,3;21 {  if (searchlight_state != searchlight_STATE_SEARCHING)
 C$B879,2;21 searchlight_mask_test();
 C$B87B,3;21 }
 C$B87E,3;21 A = IY[0x1E];
 C$B881,2;21 {  if (A != 3) <%
 C$B883,2;21 }
 C$B885,3;21 masked_sprite_plotter_24_wide_vischar();
 C$B888,2;21 goto plot_sprites; %>
*C$B88A,3;21 if (Z) masked_sprite_plotter_16_wide_vischar(); // odd to test for Z since it's always set
 C$B88D,2;21 goto plot_sprites; %>
*C$B88F,3;21 else <% setup_item_plotting();
 C$B892,2;21 if (!Z) goto plot_sprites;
 C$B894,3;21 render_mask_buffer();
 C$B897,3;21 masked_sprite_plotter_16_wide_item();
 C$B89A,2;21 goto plot_sprites; %>

; Locates a vischar or item to plot.
;
; Used by the routine at #R$B866.
;
; O:IY vischar or itemstruct to plot.
@label=locate_vischar_or_itemstruct
cC$B89C,3;22 BC = 0; // prev-x
 C$B89F,1;22 {DE = 0; // prev-y
 C$B8A0,1;22 }
 C$B8A1,2;22 A = 0xFF; // 'nothing found' marker 0xFF
 C$B8A3,2
 C$B8A5,3;22 DE = 0;
 C$B8A8,3;22 B = 8; C = 32; // iterations, stride
 C$B8AB,3;22 HL = $8007; // vischar byte7
*C$B8AE,2;22 {do <% if ((*HL & vischar_BYTE7_LOCATABLE) == 0) goto next;
 C$B8B0,2;22 }
 C$B8B2,2;22
 C$B8B4,2;22 {  HL += 8; // $8007 + 8 = $800F = mi.pos.x
 C$B8B6,1;22
 C$B8B7,1;22 }
 C$B8B8,1;22 {  C = *HL++;
 C$B8B9,1;22 }
 C$B8BA,1;22 B = *HL;
 C$B8BB,1;22 {  BC += 4;
 C$B8BC,2;22
 C$B8BE,1;22 }
 C$B8BF,3
 C$B8C2,2;22
 C$B8C4,1
 C$B8C5,2;22 JR C,pop_next
 C$B8C7,1;22 HL++;
 C$B8C8,1;22 {  C = *HL++;
 C$B8C9,1;22 }
 C$B8CA,1;22 B = *HL;
 C$B8CB,1;22 {  BC += 4;
 C$B8CC,2;22
 C$B8CE,1;22 }
 C$B8CF,3
 C$B8D2,2;22
 C$B8D4,1
 C$B8D5,2;22 JR C,pop_next
 C$B8D7,1;22 HL++;
 C$B8D8,2
 C$B8DA,2;22 {  A = 8 - B; /* Item index. */
 C$B8DC,1;22 }
 C$B8DD,1;22 // unpaired
 C$B8DE,1;22 {  E = *HL++;
 C$B8DF,1;22 }
 C$B8E0,1;22 D = *HL;
 C$B8E1,3
 C$B8E4,1;22 {  L -= 2;
 C$B8E5,1;22 }
 C$B8E6,1;22 {  D = *HL--;
 C$B8E7,1;22 }
 C$B8E8,1;22 {  E = *HL--;
 C$B8E9,1;22 }
 C$B8EA,1;22 {  B = *HL--;
 C$B8EB,1;22 }
 C$B8EC,1;22 C = *HL;
 C$B8ED,1;22 {  HL -= 15;
 C$B8EE,2;22
 C$B8F0,1;22 }
 C$B8F1,1;22 {  IY = HL;
 C$B8F2,2;22 }
 C$B8F4,1
*C$B8F5,1;22 pop_next:
 C$B8F6,1
*C$B8F7,1;22 {  next: HL += C;
 C$B8F8,1;22
 C$B8F9,1;22 }
 C$B8FA,2;22 %> while (--B);
 C$B8FC,3;22 get_greatest_itemstruct();
 C$B8FF,1;22 // extract return value
; If A' top bit remains set from initialisation, then no vischar was found.
; (It's not affected by get_greatest_itemstruct which passes it through).
 C$B900,2;22 {if (A & (1<<7)) return;
 C$B902,1;22 }
 C$B903,2;22 {HL = IY;
 C$B905,1;22 }
 C$B906,2;22 {if ((A & (1<<6)) == 0) <% // mysteryflagconst874 'item found' flag?
 C$B908,2;22 }
 C$B90A,4;22 IY[7] &= ~vischar_BYTE7_LOCATABLE;
 C$B90E,1;22 return; %>
*C$B90F,1;22 {else <% HL[1] &= ~itemstruct_ROOM_FLAG_NEARBY_6; // looks wrong: HL points to a vischar here
 C$B910,2;22 }
; This is odd. It tests the bit we've just cleared as if we're setting flags
; for return, but we can't be as we're followed by another instruction...
; unless DEC HL doesn't alter the Z flag... which is true, it doesn't.
 C$B912,2;22 {  BIT 6,HL[1]
 C$B914,1;22 }
 C$B915,1;22 return; %>

; Render the mask buffer.
;
; Used by the routine at #R$B866.
;
; .
;
; Clear the mask buffer.
@label=render_mask_buffer
@nowarn
cC$B916,3;21 {memset(mask_buffer, 0xFF, 0xA0);
 C$B919,2;21
@nowarn
 C$B91B,6;21
 C$B921,2;21 }
 C$B923,3;21 {if (room_index) <%
 C$B926,1;21
 C$B927,2;21 }
; Indoors.
 C$B929,3;21 HL = &interior_mask_data;
 C$B92C,1;21 A = *HL; // count byte
 C$B92D,1;21 {  if (A == 0) return; // no masks
 C$B92E,1;21 }
 C$B92F,1;21 B = A; // iterations
 C$B930,1;21 {  HL += 3; %> // skip count byte, then off by 2 bytes
 C$B931,2;21
 C$B933,2;21 }
; Outdoors.
@bfix-begin
; Bug? This count of 59 doesn't match NELEMS(exterior_mask_data); which is 58.
*C$B935,2;21 else <% B = 59; // 59 iterations
@bfix+else
*$B935 LD B,$3A      ; else <% B = NELEMS(exterior_mask_data); // 58 iterations
@bfix+end
 C$B937,3;21 HL = $EC03; // exterior_mask_data + 2 bytes %>
; Mask against all.
*C$B93A,1;21 do <%
 C$B93B,1
 C$B93C,3;21 {  A = iso_pos_x - 1;
 C$B93F,1;21 }
 C$B940,1;21 {  if (A >= HL[0] || A + 4 < HL[-1]) goto pop_next;
 C$B941,7;21
 C$B948,3;21 }
 C$B94B,1;21 {
 C$B94C,1;21
 C$B94D,1;21 }
 C$B94E,3;21 {  A = iso_pos_y - 1;
 C$B951,1;21 }
 C$B952,1;21 {  if (A >= HL[2] || A + 5 < HL[1]) goto pop_next;
 C$B953,7;21
 C$B95A,3;21 }
 C$B95D,1;21 {
 C$B95E,1;21 }
 C$B95F,3;21 {  if (tinypos_stash_x <= HL[3]) goto pop_next;
 C$B962,7;21
 C$B969,1;21 }
 C$B96A,3;21 {  if (tinypos_stash_y < HL[4]) goto pop_next;
 C$B96D,4;21
 C$B971,1;21 }
 C$B972,3;21 A = tinypos_stash_height;
 C$B975,1;21 {  if (A) A--;
 C$B976,2;21
 C$B978,1;21 }
*C$B979,1;21 {  if (A >= HL[5]) goto pop_next;
 C$B97A,3;21 }
 C$B97D,1;21 {  HL -= 6;
 C$B97E,5;21
 C$B983,1;21 }
; Clipping.
*C$B984,3;21 A = iso_pos_x;
 C$B987,1;21 C = A;
 C$B988,1;21 {  if (A >= *HL) <%
 C$B989,3;21 }
 C$B98C,1;21 clip_x0 = A - *HL; // sampled HL=$81EC,$81F4,$EC12
 C$B98D,3;21
 C$B990,1;21 HL++;
 C$B991,1;21 {    A = *HL - C;
 C$B992,1;21 }
 C$B993,2;21 {    if (A >= 3) A = 3;
 C$B995,2;21
 C$B997,2;21 }
*C$B999,1;21 {    ($B83A) = ++A; // clip_width + 1 %>
 C$B99A,3;21 }
 C$B99D,2;21 else <%
*C$B99F,1;21 B = *HL;
 C$B9A0,1;21 {    clip_x0 = 0;
 C$B9A1,3;21 }
 C$B9A4,1;21 {    C = 4 - (B - C);
 C$B9A5,5;21
 C$B9AA,1;21 }
 C$B9AB,1;21 HL++;
 C$B9AC,1;21 {    A = (*HL - B) + 1;
 C$B9AD,1;21
 C$B9AE,1;21 }
 C$B9AF,1;21 {    if (A >= C) A = C;
 C$B9B0,2;21
 C$B9B2,1;21 }
*C$B9B3,3;21 ($B83A) = A; // clip_width + 1 %>
*C$B9B6,1;21 HL++;
 C$B9B7,3;21 A = iso_pos_y;
 C$B9BA,1;21 C = A;
 C$B9BB,1;21 {  if (A >= *HL) <%
 C$B9BC,3;21 }
 C$B9BF,1;21 A -= *HL;
 C$B9C0,3;21 clip_y0 = A;
 C$B9C3,1;21 {    A = *++HL - C;
 C$B9C4,1;21
 C$B9C5,1;21 }
 C$B9C6,2;21 {    if (A >= 4) A = 4;
 C$B9C8,2;21
 C$B9CA,2;21 }
*C$B9CC,1;21 A++;
 C$B9CD,3;21 {    ($B839) = A; %>
 C$B9D0,2;21 }
*C$B9D2,1;21 else <% B = *HL;
 C$B9D3,1;21 {    clip_y0 = 0;
 C$B9D4,3;21 }
 C$B9D7,1;21 {    C = 5 - (B - C);
 C$B9D8,5;21
 C$B9DD,1;21 }
 C$B9DE,1;21 {    A = (*++HL - B) + 1;
 C$B9DF,2;21
 C$B9E1,1;21 }
 C$B9E2,1;21 {    if (A >= C) A = C;
 C$B9E3,2;21
 C$B9E5,1;21 }
*C$B9E6,3;21 ($B839) = A; %>
*C$B9E9,1;21 HL--;
 C$B9EA,3;21 BC = 0;
 C$B9ED,3;21 {  if (clip_y0 == 0) C = -iso_pos_y + *HL;
 C$B9F0,9;21
 C$B9F9,1;21 }
*C$B9FA,1;21 {  HL -= 2;
 C$B9FB,1;21 }
 C$B9FC,3;21 {  if (clip_x0 == 0) B = -iso_pos_x + *HL;
 C$B9FF,9;21
 C$BA08,1;21 }
*C$BA09,1;21 HL--;
 C$BA0A,1;21 A = *HL;
 C$BA0B,1
 C$BA0C,1;21 {  Adash = C * 32 + B;
 C$BA0D,5;21
 C$BA12,1;21 }
@nowarn
 C$BA13,3;21 {  HL = mask_buffer + Adash;
 C$BA16,1;21
 C$BA17,1;21 }
 C$BA18,3;21 ($81A0) = HL; // mask buffer pointer
 C$BA1B,1
 C$BA1C,1;21 {  DE = mask_pointers[A];
 C$BA1D,9;21
 C$BA26,1;21 }
 C$BA27,3;21 L = clip_height; H = clip_width;
 C$BA2A,1;21 {  ($BA70) = L; // self modify
 C$BA2B,3;21 }
 C$BA2E,1;21 {  ($BA72) = H; // self modify
 C$BA2F,3;21 }
 C$BA32,1;21 {  ($BA90) = *DE - H; // self modify // *DE is the mask's width
 C$BA33,1;21
 C$BA34,3;21 }
 C$BA37,2;21 {  ($BABA) = 32 - H; // self modify
 C$BA39,1;21
 C$BA3A,3;21 }
 C$BA3D,1
 C$BA3E,1;21 {  E = *DE;
 C$BA3F,1;21 }
 C$BA40,3;21 A = clip_y0;
 C$BA43,3;21 HL = multiply(); D = 0;
 C$BA46,3;21 {  E = clip_x0;
 C$BA49,1;21 }
 C$BA4A,1;21 HL += DE;
 C$BA4B,1
 C$BA4C,1;21 HL++; // iterations
;
; Skip the initial clipped mask bytes.
;
*C$BA4D,1;21 do <% A = *DE; // DE -> $E560 upwards (in exterior_mask_data)
 C$BA4E,1;21 {    if (A >= 128) <%
 C$BA4F,3;21 }  // jump if sign bit is set
 C$BA52,2;21 A &= 0x7F;
 C$BA54,1;21 DE++;
 C$BA55,1;21 {      HL -= A;
 C$BA56,2;21 }
 C$BA58,2;21 if (HL < 0) goto $BA69;
 C$BA5A,1;21 DE++; // doesn't affect flags
 C$BA5B,2;21 if (HL != 0) goto $BA4D;
 C$BA5D,1;21 A = 0;
 C$BA5E,2;21 goto $BA6C; %>
*C$BA60,1;21 DE++;
 C$BA61,1;21 {  %> while (--HL);
 C$BA62,2;21
 C$BA64,3;21 }
 C$BA67,2;21 goto $BA6C;
*C$BA69,1;21 {  A = -L;
 C$BA6A,2;21 }
*C$BA6C,3;21 HL = ($81A0); // mask buffer pointer
 C$BA6F,2;21 C = 1; // self modified
*C$BA71,2;21 do <% B = 1; // self modified
*C$BA73,1;21 do <%
 C$BA74,1;21 Adash = *DE;
 C$BA75,1;21 Adash &= Adash;
 C$BA76,3;21 if (!P) <%
 C$BA79,2;21 Adash &= 0x7F;
 C$BA7B,1;21 // bank the counter
 C$BA7C,1;21 DE++;
 C$BA7D,1;21 A = *DE; %>
*C$BA7E,1;21 A &= A;
 C$BA7F,3;21 if (!Z) mask_against_tile();
 C$BA82,1;21 L++;
 C$BA83,1;21 // unpaired?
 C$BA84,1;21 {      if (A != 0 && --A != 0) DE--;
 C$BA85,5;21
 C$BA8A,1;21 }
*C$BA8B,1;21 DE++;
 C$BA8C,2;21 %> while (--B);
 C$BA8E,1
 C$BA8F,2;21 B = 1; // self modified
 C$BA91,1;21 bank while we test B
 C$BA92,1;21 {    if (B) <%
 C$BA93,1;21
 C$BA94,3;21 }
 C$BA97,1;21 unbank
 C$BA98,1;21 {      if (A) goto $BAA3;
 C$BA99,2;21 }
*C$BA9B,1;21 do <% A = *DE;
 C$BA9C,1;21 {        if (A >= 128) <%
 C$BA9D,3;21 }
 C$BAA0,2;21 A &= 0x7F;
 C$BAA2,1;21 DE++;
*C$BAA3,1;21 {        B -= A;
 C$BAA4,2;21
 C$BAA6,1;21 }
 C$BAA7,2;21 if (B < 0) goto $BAB6;
 C$BAA9,1;21 DE++; // doesn't affect flags
 C$BAAA,2;21 if (B != 0) goto $BA9B;
 C$BAAC,1;21 // why not just jump instr earlier? // bank
 C$BAAD,2;21 goto $BAB9; %>
*C$BAAF,1;21 DE++;
 C$BAB0,2;21 %> while (--B);
 C$BAB2,1;21 A = 0;
 C$BAB3,1;21 // why not just jump instr earlier? // bank
 C$BAB4,2;21 goto $BAB9;
*C$BAB6,2;21 A = -A;
 C$BAB8,1;21 // bank %>
*C$BAB9,2;21 {    HL += 32; // self modified
 C$BABB,1;21
 C$BABC,1;21 }
 C$BABD,1;21 // unbank
 C$BABE,1
 C$BABF,1;21 {  %> while (--C);
 C$BAC0,3;21 }
*C$BAC3,1;21 pop_next:
 C$BAC4,1
 C$BAC5,3;21 {  HL += 8;
 C$BAC8,1;21 }
 C$BAC9,1;21 {%> while (--B);
 C$BACA,3;21 }
@rfix-begin
; Bug: RET is missing here. We fall through into multiply.
@rfix+else
       RET           ; Return
@rfix+end

; Multiply the two input values, A and E, returning a widened result in HL.
;
; Used by the routine at #R$B916.
;
; I:A Left hand value.
; I:E Right hand value.
; O:D Zero.
; O:HL Multiplied result.
@label=multiply
cC$BACD,2;21 B = 8; // iterations
 C$BACF,3;21 HL = 0;
 C$BAD2,1;21 D = 0;
*C$BAD3,1;21 do <% HL += HL;
 C$BAD4,1;21 RLA  // carry = (A >> 7); A <<= 1; /* shift out of high end */
 C$BAD5,3;21 {  if (carry) HL += DE; /* shift into low end */
 C$BAD8,1;21 }
*C$BAD9,2;21 %> while (--B);
 C$BADB,1;21 return;

; AND a tile in the mask buffer against the specified mask tile.
;
; Used by the routine at #R$B916.
;
; I:A Mask tile index.
; I:HL Pointer to a tile to be masked.
@label=mask_against_tile
cC$BADC,1;21 DEdash = HL
 C$BADD,1
 C$BADE,1;21 {HLdash = &mask_tiles[A];
 C$BADF,8;21
 C$BAE7,1;21 }
 C$BAE8,1
 C$BAE9,2;21 Bdash = 8; // 8 iterations
*C$BAEB,1;21 {do <% *DEdash &= *HLdash++;
 C$BAEC,2;21
 C$BAEE,1;21 }
 C$BAEF,1;21 {  DEdash += 4; /* mask buffer rowbytes */
 C$BAF0,2;21
 C$BAF2,1;21 }
 C$BAF3,2;21 %> while (--Bdash);
 C$BAF5,1
 C$BAF6,1;21 return;

; Clipping vischars to the game window.
;
; Used by the routines at #R$BB98 and #R$E420.
;
; O:A 0 => visible, 0xFF => invisible.
; O:BC Clipped width.
; O:DE Clipped height.
; O:IY Pointer to visible character.
;
; Width part.
@label=vischar_visible
cC$BAF7,3;22 HL = &iso_pos_x;
 C$BAFA,3;22 {A = map_position[0] + 24;
 C$BAFD,2;22 }
 C$BAFF,1;22 A -= *HL;
 C$BB00,3;22 {if (A > 0) <%
 C$BB03,3;22 }
 C$BB06,3;22 CP IY[30]  // if (A ?? IY[30])
 C$BB09,3;22 if (carry) <%
 C$BB0C,2;22 {    BC = A; %>
 C$BB0E,1;22 }
 C$BB0F,2;22 else <%
*C$BB11,1;22 {    A = *HL + IY[30];
 C$BB12,3;22 }
 C$BB15,3;22 {    A -= map_position[0];
 C$BB18,1;22 }
 C$BB19,3;22 {    if (A <= 0) goto exit;
 C$BB1C,3;22 }
 C$BB1F,3;22 CP IY[30]
 C$BB22,3;22 if (carry) <%
 C$BB25,1;22 C = A;
 C$BB26,2;22 {      B = -A + IY[30]; %>
 C$BB28,3;22
 C$BB2B,1;22 }
 C$BB2C,2;22 else <%
*C$BB2E,2;22 {      BC = IY[30]; %> %>
 C$BB30,3;22 }
; Height part.
*C$BB33,3;22 {  HL = ((map_position >> 8) + 17) * 8;
 C$BB36,7;22
 C$BB3D,1;22 }
 C$BB3E,3;22 E = IY[26];
 C$BB41,3;22 D = IY[27];
 C$BB44,1;22 A &= A;
 C$BB45,2;22 HL -= DE;
 C$BB47,3;22 {  if (result <= 0) goto exit;
 C$BB4A,3;22 }
 C$BB4D,1;22 {  if (H) goto exit;
 C$BB4E,1;22
 C$BB4F,3;22 }
 C$BB52,1;22 A = L;
 C$BB53,3;22 CP IY[31]
 C$BB56,3;22 if (carry) <%
 C$BB59,1;22 {    DE = A; %>
 C$BB5A,2;22 }
 C$BB5C,2;22 else <%
*C$BB5E,3;22 {    HL = IY[31] + DE;
 C$BB61,2;22
 C$BB63,1;22 }
 C$BB64,1;22 {    DE = map_position >> 8 * 8;
 C$BB65,9;22
 C$BB6E,1;22 }
 C$BB6F,1;22 A &= A; // likely: clear carry
 C$BB70,2;22 HL -= DE;
 C$BB72,3;22 {    if (result <= 0) goto exit;
 C$BB75,3;22 }
 C$BB78,1;22 {    if (H) goto exit;
 C$BB79,1;22
 C$BB7A,3;22 }
 C$BB7D,1;22 A = L;
 C$BB7E,3;22 CP IY[31]
 C$BB81,3;22 if (carry) <%
 C$BB84,1;22 E = A;
 C$BB85,2;22 {      D = -A + IY[31]; %>
 C$BB87,3;22
 C$BB8A,1;22 }
 C$BB8B,2;22 else <%
*C$BB8D,2;22 {      DE = IY[31]; %> %>
 C$BB8F,3;22 }
*C$BB92,1;22 A = 0; // return Z (vischar is visible)
 C$BB93,1;22 return; %>
*C$BB94,2;22 exit: A = 0xFF;
 C$BB96,1;22 A &= A; // return NZ (vischar is not visible)
 C$BB97,1;22 return;

; Paint any tiles occupied by visible characters with tiles from tile_buf.
;
; Used by the routine at #R$9D7B.
@label=restore_tiles
cC$BB98,2;21 B = 8; // iterations
 C$BB9A,4;21 IY = $8000;
*C$BB9E,1;21 do <%
 C$BB9F,3;21 {  if (IY[1] == vischar_FLAGS_EMPTY_SLOT) goto next;
 C$BBA2,2;21
 C$BBA4,3;21 }
 C$BBA7,3;21 {  iso_pos_y = (IY[26] >> 3) | (IY[27] << 5); // divide by 8
 C$BBAA,12;21
 C$BBB6,3;21 }
 C$BBB9,3;21 {  iso_pos_x = (IY[24] >> 3) | (IY[25] << 5); // divide by 8
 C$BBBC,12;21
 C$BBC8,3;21 }
 C$BBCB,3;21 vischar_visible();
 C$BBCE,2;21 {  if (A == 0xFF) goto next; // vischar not visible
 C$BBD0,3;21 }
 C$BBD3,1;21 {  A = ((E >> 3) & 31) + 2;
 C$BBD4,5;21
 C$BBD9,2;21 }
 C$BBDB,1
;
 C$BBDC,3;21 {  A += iso_pos_y - map_position_y;
 C$BBDF,4;21
 C$BBE3,1;21 }
;
 C$BBE4,2;21 if (A >= 0) <%
 C$BBE6,2;21 A -= 17;
 C$BBE8,2;21 {    if (A > 0) <%
 C$BBEA,2;21 }
 C$BBEC,1;21 E = A;
 C$BBED,1
 C$BBEE,1;21 A -= E;
 C$BBEF,3;21 if (carry) goto next;
 C$BBF2,2;21 if (!Z) goto $BBF8;
 C$BBF4,3;21 goto next; %> %>
*C$BBF7,1
;
*C$BBF8,2;21 {  if (A > 5) A = 5;
 C$BBFA,6;21
 C$BC00,2;21 }
;
*C$BC02,3;21 ($BC5F) = A; // self modify outer loop counter
 C$BC05,1;21 A = C;
 C$BC06,3;21 ($BC61) = A; // self modify inner loop counter
 C$BC09,3;21 ($BC89) = A; // self modify
 C$BC0C,2;21 {  A = 24 - C;
 C$BC0E,1;21 }
 C$BC0F,3;21 ($BC8E) = A; // self modify
 C$BC12,2;21 A += $A8;
 C$BC14,3;21 ($BC95) = A; // self modify
;
; Work out x,y offsets into the tile buffer.
 C$BC17,3;21 HL = &map_position;
 C$BC1A,1;21 A = B;
 C$BC1B,1;21 A &= A;
 C$BC1C,2;21 A = 0; // interleaved
 C$BC1E,2;21 if (Z) <%
 C$BC20,3;21 A = iso_pos_x;
 C$BC23,1;21 A -= *HL; %>
*C$BC24,1;21 B = A;
;
 C$BC25,1;21 A = D;
 C$BC26,1;21 A &= A;
 C$BC27,2;21 A = 0; // interleaved
 C$BC29,2;21 if (Z) <%
 C$BC2B,1;21 HL++;
 C$BC2C,3;21 A = iso_pos_y;
 C$BC2F,1;21 A -= *HL; %>
*C$BC30,1;21 C = A;
;
; Calculate the offset into screen buffer.
; C * 192 == C * 24 * 8
 C$BC31,1;21 {  DE = C << 7;
 C$BC32,5;21
 C$BC37,1;21 }
 C$BC38,2;21 {  HL = C << 6;
 C$BC3A,1;21
 C$BC3B,1;21 }
 C$BC3C,1;21 {  HL += DE + B + $F290; // screen buffer start address
 C$BC3D,7;21
 C$BC44,1;21 }
;
 C$BC45,1;21 swap it into DE. HL about to be overwritten.
;
; Copy BC (x,y coord) into HL'
 C$BC46,2
 C$BC48,1;21 POP HLdash
 C$BC49,1
;
 C$BC4A,1;21 A = B;
 C$BC4B,1;21 {  HL = C * 24 + A + $F0F8; // visible tiles array
 C$BC4C,16;21
 C$BC5C,1;21 }
 C$BC5D,1
 C$BC5E,2;21 C = 5; // iterations // self modified $BC5F
*C$BC60,2;21 do <% B = 4; // iterations // self modified $BC61
*C$BC62,1;21 do <%
 C$BC63,1;21 A = *DE;
 C$BC64,1
 C$BC65,1;21 POP DEdash // visible tiles array pointer
 C$BC66,1;21 PUSH HLdash // save x,y
 C$BC67,3;21 select_tile_set(); // call using banked registers
 C$BC6A,1;21 {      HLdash = A * 8 + BCdash;
 C$BC6B,5;21
 C$BC70,1;21 }
 C$BC71,3;21 Bdash, Cdash = 8, 24; // iterations, stride
*C$BC74,1;21 {      do <% *DEdash = *HLdash++;
 C$BC75,1;21 }
 C$BC76,1;21 {        DEdash += Cdash;
 C$BC77,4;21
*C$BC7B,1;21
 C$BC7C,1;21 }
 C$BC7D,2;21 %> while (--Bdash);
 C$BC7F,1;21 POP HLdash
 C$BC80,1;21 Hdash++;
 C$BC81,1
 C$BC82,1;21 DE++;
 C$BC83,1;21 HL++;
 C$BC84,2;21 %> while (--B);
 C$BC86,1
 C$BC87,1;21 A = Hdash;
 C$BC88,2;21 A -= 0; // self modified $BC89
 C$BC8A,1;21 Hdash = A;
 C$BC8B,1;21 Ldash++;
 C$BC8C,1
 C$BC8D,2;21 A = 20; // self modified $BC8E
 C$BC8F,1;21 A += E;
 C$BC90,2;21 {    if (carry) D++;
 C$BC92,1;21 }
*C$BC93,1;21 E = A;
 C$BC94,2;21 A = $BC; // self modified $BC95
 C$BC96,1;21 A += L;
 C$BC97,2;21 {    if (carry) H++;
 C$BC99,1;21 }
*C$BC9A,1;21 L = A;
 C$BC9B,1;21 {  %> while (--C);
 C$BC9C,3;21 }
*C$BC9F,1;21 next:
 C$BCA0,3;21 {  IY += 32; // stride
 C$BCA3,2;21
 C$BCA5,1;21 }
 C$BCA6,3;21 %> while (--B);
 C$BCA9,1;21 return;

; Turn a map ref into a tile set pointer.
;
; Used by the routine at #R$BB98.
;
; I:H X shift.
; I:L Y shift.
; O:A  Preserved.
; O:BC Pointer to tile set.
@label=select_tile_set
cC$BCAA,1
 C$BCAB,3;21 {if (room_index) <%
 C$BCAE,1;21
 C$BCAF,2;21 }
 C$BCB1,3;21 BC = &interior_tiles[0];
 C$BCB4,1
 C$BCB5,1;21 return; %>
; Convert map position to an index into 7x5 supertile refs array.
*C$BCB6,3;21 {else <% Adash = (((map_position >> 8) & 3) + L) >> 2;
 C$BCB9,4;21
 C$BCBD,1;21 }
 C$BCBE,2;21 {  L = (Adash & 0x3F) * 7; // vertical
 C$BCC0,5;21
 C$BCC5,1;21 }
 C$BCC6,3;21 {  Adash = (((map_position & 0xFF) & 3) + H) >> 2;
 C$BCC9,4;21
 C$BCCD,1;21 }
 C$BCCE,2;21 {  Adash = (Adash & 0x3F) + L; // horizontal
 C$BCD0,1;21 }
 C$BCD1,3;21 {  Adash = $FF58[Adash]; // (7x5) supertile refs
 C$BCD4,2;21
 C$BCD6,1;21 }
 C$BCD7,3;21 BC = &exterior_tiles[0];
 C$BCDA,2;21 {  if (Adash >= 45) <%
 C$BCDC,2;21 }
 C$BCDE,3;21 BC = &exterior_tiles[145];
 C$BCE1,2;21 {    if (Adash >= 139 && Adash < 204) <%
 C$BCE3,4;21
 C$BCE7,2;21 }
 C$BCE9,3;21 BC = &exterior_tiles[145 + 220]; %> %>
*C$BCEC,1
 C$BCED,1;21 return; %>

; Map super-tile refs. 54x34. Each byte represents a 32x32 tile.
;
; The map, with blanks and grass replaced to show the outline more clearly:
;                                                                         5F 33 3C 58
;                                                                   5F 33 34 2E 3D 45 3C 58
;                               55 5E 31                         33 34 2B 37 2D 3F 28 48 42 5B 58
;                               82 3E 30 2E 57             33 34 2E 37 2A 2F 2C 41 26 47 43 53 42 3C 57
;                         75 76 81 5E 31 33 3C 5E 31 33 34 2B 35 2D 36 29 .. .. .. .. 49 44 54 43 3D 45 3C 58
;                   75 76 7C 7F 80 3E 30 39 3D 3E 30 2E 35 2A 2F 38 .. .. .. .. .. .. .. .. 41 44 46 27 48 42 5B 58
; 75 76 7A 79 75 76 7C 7F 7E 3A 5D 40 31 3A 3F 40 31 2D 2F 29 .. .. .. .. .. .. .. .. .. .. .. .. 41 26 47 43 53 42 3C 58
; 6A 74 77 78 7B 7F 7E 3A 2F 2C 49 3B 32 2C 41 3B 32 38 .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 49 44 54 43 3D 52 59 53
; 63 64 66 6F 7D 3A 2F 38 .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 06 07 .. .. .. .. .. .. .. .. 41 44 46 51 5D 58 5A 53
; 65 62 6C 6D 36 2C .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 02 03 04 08 1A .. .. .. .. .. .. .. .. .. 41 44 5C 5B 57 58 5A 53
; 63 64 6B 6E 71 .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. 02 03 04 05 09 1C 1B .. .. .. .. .. .. .. .. .. .. .. 59 53 45 3C 57 58 5A
; 61 62 5A 73 72 70 71 .. .. .. .. .. .. .. .. .. .. .. .. .. 02 03 14 05 0A 17 1E 1D .. .. .. .. 06 07 .. .. .. .. .. .. 55 58 5A 53 45 3C 57
; 49 3B 68    5A 73 72 70 71 .. .. 75 76 7A 79 .. .. .. 00 01 04 05 0A 21 22 16 1F 19 .. .. 02 03 04 08 1A .. .. .. .. .. 4B 45 3C 58 5A 53 45 45
; .. .. 41 56 68    5A 73 72 70 71 6A 74 84 85 7A 79 .. 0D 0C 0B 17 20 16 15 18 .. .. 02 03 04 05 09 1C 1B .. .. .. .. .. 4A 50 4C 52 5B 58 5A
; .. .. .. .. 49 56 68 69 5A 73 72 63 86 88 74 77 78 .. 0E 0F 12 16 15 18 .. .. 02 03 14 05 0A 17 1E 1D .. .. .. .. 06 07 49 44 4D 51 4C 52 3C 58
; .. .. .. .. .. .. 49 67 68 69 5A 65 87 83 64 66 6F .. 10 11 13 18 .. .. 00 01 04 05 0A 21 22 16 1F 19 .. .. 02 03 04 08 1A .. 41 44 4E 51 4C 45 3C 58
; .. .. .. .. .. .. .. .. 41 67 68 59 CC CD 62 8A 6D .. .. .. .. .. .. .. 0D 0C 0B 17 20 16 15 18 .. .. 02 03 04 05 09 1C 1B .. .. .. 49 44 4E 28 4C 52 5B 58
; .. .. .. .. .. .. .. .. .. .. 41 89 CE CF D2 D5 6F .. .. .. .. .. .. .. 0E 0F 12 16 15 18 .. .. 02 03 14 05 0A 17 1E 1D .. .. .. B9 BA .. 49 26 C8 C9 4C 45 3C 58
; .. .. .. .. .. .. .. B9 BA B1 B1 49 D0 D1 D3 D6 D8 9B 9C .. .. .. .. .. 10 11 13 18 .. .. 00 01 04 05 0A 21 22 16 1F 19 .. .. BB BC BD BE 9D 97 CA CB 4D 28 4C 45
; .. .. .. .. .. .. BB BC BD BE AF B2 B7 93 D4 D7 D9 8E 90 9B 9C .. .. .. .. .. .. .. .. .. 0D 0C 0B 17 20 16 15 18 .. .. .. .. .. C5 C0 97 96 93 95 94 41 26 C8 C9
; .. .. .. .. .. B1 B1 C5 C0 97 96 B3 B5 B6 '' '' 8C 8D 8B 8E 90 9B 9C .. .. .. .. .. .. .. 0E 0F 12 16 15 18 .. .. .. .. .. 9C 9D C6 C2 93 95 94 '' 99 98 97 CA CB
; .. .. .. B1 B1 B0 AF C6 C2 93 95 B4 8B 8E 90 8F '' '' 8C 8D 8B 8E A8 AA 9C .. .. .. .. .. 10 11 13 18 .. .. .. .. .. 9C 9D 97 96 C7 C4 94 '' 99 98 97 96 93 95 94
; .. .. B1 B0 AF 97 96 C7 C4 94 '' B8 8C 8D 8B 8E 90 8F '' '' 8C 8D A7 A6 90 9B 9C .. .. .. .. .. .. .. .. .. .. 9C 9D 97 96 93 95 94 '' 99 98 97 96 93 95 94 .. ..
; .. .. B0 B2 B7 93 95 94 '' '' '' '' '' '' 8C 8D 8B 8E A8 A9 '' '' A5 A4 8B 8E 90 9B 9C .. .. B9 BA .. .. 9C 9D 97 96 93 95 94 B8 99 98 97 96 93 95 94 .. .. .. ..
; .. .. B0 B3 B5 B6 '' '' '' '' '' '' '' '' '' '' 8C 8D A7 A6 90 8F '' '' 8C 8D 8B 8E 90 9B BB BC BD BE 9D 97 96 93 95 94 '' 99 98 97 96 93 95 94 .. .. .. .. .. ..
; .. .. B1 B4 8B 8E 90 8F '' '' '' '' '' '' '' '' '' '' A5 A4 8B 8E 90 8F '' '' 8C 8D 8B 8E 90 BF C0 97 96 93 95 94 '' 99 98 97 96 93 95 94 .. .. .. .. .. .. .. ..
; .. .. .. .. 8C 8D 8B 8E 90 8F '' '' '' '' '' '' '' '' '' '' 8C 8D AB AC 90 8F '' '' 8C 8D 8B C1 C2 93 95 94 '' 99 98 97 96 93 95 94 .. .. .. .. .. .. .. .. .. ..
; .. .. .. .. .. .. 8C 8D 8B 8E 90 8F '' '' '' B9 BA '' '' 99 98 97 AD AE 8B 8E 90 8F '' '' 8C C3 C4 94 '' 99 98 97 96 93 95 94 .. .. .. .. .. .. .. .. .. .. .. ..
; .. .. .. .. .. .. .. .. 8C 8D 8B 8E 90 8F BB BC BD BE 98 97 96 93 95 94 8C 8D 8B 8E 90 8F '' '' '' 99 98 97 96 93 95 94 .. .. .. .. .. .. .. .. .. .. .. .. .. ..
; .. .. .. .. .. .. .. .. .. .. 8C 8D 8B 8E 90 BF C0 97 96 93 95 94 .. .. .. .. 8C 8D 8B 8E 90 A2 A3 97 96 93 95 94 .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
; .. .. .. .. .. .. .. .. .. .. .. .. 8C 8D 8B C1 C2 93 95 94 .. .. .. .. .. .. .. .. 8C 8D 8B A0 A1 93 95 94 .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
; .. .. .. .. .. .. .. .. .. .. .. .. .. .. 8C C3 C4 94 .. .. .. .. .. .. .. .. .. .. .. .. 8C 9F 9E 94 .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
; .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
; .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
@label=map_tiles
bB$BCEE,54*34

; Pointer to bytes to output as pseudo-random data.
;
; Initially set to $9000. Wraps around after $90FF.
@label=prng_pointer
gW$C41A,2

; Spawn characters.
;
; Used by the routines at #R$6939 and #R$9D7B.
;
; .
;
; Form a clamped map position in DE.
@label=spawn_characters
cC$C41C,3;21 HL = map_position;
 C$C41F,1;21 {E = (L < 8) ? 0 : L - 8;
 C$C420,5;21
*C$C425,1;21 }
 C$C426,1;21 {D = (H < 8) ? 0 : H - 8;
 C$C427,5;21
*C$C42C,1;21 }
; Walk all character structs.
 C$C42D,3;21 HL = &character_structs[0];
 C$C430,2;21 B = character_26_STOVE_1; // the 26 'real' characters
*C$C432,2;21 {do <% if (*HL & characterstruct_FLAG_DISABLED) goto skip;
 C$C434,2;21 }
; Is the character in this room?
 C$C436,1;21 (stash HL)
 C$C437,1;21 HL++; // $7613
 C$C438,3;21 A = room_index;
 C$C43B,1;21 {  if (A != *HL) goto unstash_skip; // not in the visible room
 C$C43C,2;21 }
 C$C43E,1;21 {  if (A != 0) goto indoors;
 C$C43F,2;21 }
; Outdoors.
 C$C441,1;21 HL++; // $7614
; Screen Y calculation.
; .
; A is zero here, and represents 0x200.
 C$C442,1;21 A -= *HL; // charstr->pos.x
 C$C443,1;21 HL++; // $7615
 C$C444,1;21 A -= *HL; // charstr->pos.y
 C$C445,1;21 HL++; // $7616
 C$C446,1;21 A -= *HL; // charstr->pos.height
 C$C447,1;21 C = A;
 C$C448,1;21 A = D;
 C$C449,1;21 {  if (C <= A) goto unstash_skip; // check
 C$C44A,2;21 }
 C$C44C,2;21 A += 32;
 C$C44E,2;21 {  if (A > 0xFF) A = 0xFF;
 C$C450,2;21 }
*C$C452,1;21 {  if (C > A) goto unstash_skip; // check
 C$C453,2;21 }
; Screen X calculation.
 C$C455,1;21 HL--; // $7615
 C$C456,2;21 A = 64;
 C$C458,1;21 A += *HL;
 C$C459,1;21 HL--; // $7614
 C$C45A,1;21 A -= *HL;
 C$C45B,1;21 A *= 2; // A == 128
 C$C45C,1;21 C = A;
 C$C45D,1;21 A = E;
 C$C45E,1;21 {  if (C <= A) goto unstash_skip; // check
 C$C45F,2;21 }
 C$C461,2;21 A += 40;
 C$C463,2;21 {  if (A > 0xFF) A = 0xFF;
 C$C465,2;21 }
*C$C467,1;21 {  if (C > A) goto unstash_skip; // check
 C$C468,2;21 }
*C$C46A,1;21 indoors: (unstash HL)
 C$C46B,1;21 {  (stash HL, DE, BC)
 C$C46C,1;21
 C$C46D,1;21 }
 C$C46E,3;21 spawn_character();
 C$C471,1;21 {  (unstash BC, DE)
 C$C472,1;21 }
*C$C473,1;21 unstash_skip: (unstash HL)
*C$C474,1;21 {skip: HL += 7; // stride
 C$C475,5;21
 C$C47A,1;21 }
*C$C47B,2;21 %> while (--B);
 C$C47D,1;21 return;

; Run through all visible characters, resetting them if they're off-screen.
;
; Used by the routine at #R$9D7B.
@label=purge_invisible_characters
cC$C47E,3;21 HL = &map_position;
 C$C481,1;21 {E = MAX(L - 9, 0);
 C$C482,5;21
*C$C487,1;21 }
 C$C488,1;21 {D = MAX(H - 9, 0);
 C$C489,5;21
*C$C48E,1;21 }
 C$C48F,2;21 B = 7; // 7 iterations
@nowarn
 C$C491,3;21 HL = $8020; // iterate over non-player characters
*C$C494,1;21 do <% A = *HL;
 C$C495,2;21 {  if (A == character_NONE) goto next;
 C$C497,3;21 }
 C$C49A,1
 C$C49B,2;21 {  HL += 28;
 C$C49D,1;21
 C$C49E,1;21 }
 C$C49F,3;21 {  if (room_index != *HL) goto reset; /* this character is not in the current room */
 C$C4A2,1;21
 C$C4A3,2;21 }
 C$C4A5,1;21 {  C = *--HL;
 C$C4A6,1;21 }
 C$C4A7,1;21 {  A = *--HL;
 C$C4A8,1;21 }
 C$C4A9,3;21 divide_by_8_with_rounding(C,A);
 C$C4AC,1;21 C = A;
 C$C4AD,1;21 {  if (C <= D || C > MIN(D + 34, 255)) goto reset;
 C$C4AE,9;21
*C$C4B7,1;21
 C$C4B8,2;21 }
 C$C4BA,1;21 {  C = *--HL;
 C$C4BB,1;21 }
 C$C4BC,1;21 {  A = *--HL;
 C$C4BD,1;21 }
 C$C4BE,3;21 divide_by_8(C,A);
 C$C4C1,1;21 C = A;
 C$C4C2,1;21 {  if (C <= E || C > MIN(E + 42, 255)) goto reset;
 C$C4C3,1;21
 C$C4C4,2;21 }
 C$C4C6,2;21 {  goto pop_next;
 C$C4C8,4;21
*C$C4CC,1;21
 C$C4CD,2;21 }
*C$C4CF,1;21 reset:
 C$C4D0,3
 C$C4D3,3;21 reset_visible_character();
 C$C4D6,2
*C$C4D8,1;21 pop_next:
*C$C4D9,2;21 {  next: HL += 32;
 C$C4DB,1;21
 C$C4DC,1;21 }
 C$C4DD,2;21 %> while (--B);
 C$C4DF,1;21 return;

; Adds characters to the visible character list.
;
; Used by the routine at #R$C41C.
;
; I:HL Pointer to character to spawn.
@label=spawn_character
cC$C4E0,2;22 {if (*HL & characterstruct_FLAG_DISABLED) return; /* character disabled */
 C$C4E2,1;22 }
 C$C4E3,1
; Find an empty slot in the visible character list.
@nowarn
 C$C4E4,3;22 HL = $8020; // iterate over non-player characters
 C$C4E7,5
 C$C4EC,2;22 B = 7; // 7 iterations
*C$C4EE,1;22 {do <% if (*HL == vischar_CHARACTER_EMPTY_SLOT) goto found_empty_slot;
 C$C4EF,2;22 }
 C$C4F1,1;22 HL += 32; // stride
 C$C4F2,2;22 %> while (--B);
 C$C4F4,1
 C$C4F5,1;22 return;
; Found an empty slot.
*C$C4F6,1;22 found_empty_slot: // restore DE (-> character struct)
 C$C4F7,1;22 // save HL (-> empty vischar slot)
 C$C4F8,2;22 // restore IY (-> empty vischar slot)
 C$C4FA,1;22 // save HL (-> empty vischar slot)
 C$C4FB,1;22 // save DE (-> character struct)
 C$C4FC,1;22 DE++;
; Scale coords dependent on which room the character is in.
 C$C4FD,3;22 HL = &saved_pos_x;
 C$C500,1;22 {A = *DE++;
 C$C501,1;22 }
 C$C502,1;22 A &= A;
 C$C503,2;22 if (A == 0) <%
 C$C505,2;22 A = 3; // 3 iterations
*C$C507,1;22 do <%
 C$C508,1;22 {    BC = *DE * 8;
 C$C509,3;22 }
 C$C50C,1;22 {    *HL++ = C;
 C$C50D,1;22 }
 C$C50E,1;22 {    *HL++ = B;
 C$C50F,1;22 }
 C$C510,1;22 DE++;
 C$C511,1
 C$C512,1;22 {  %> while (--A); %>
 C$C513,3;22 }
 C$C516,2;22 else <%
*C$C518,2;22 B = 3; // 3 iterations
*C$C51A,1;22 {do <% *HL++ = *DE++;
 C$C51B,2;22
 C$C51D,1;22 }
 C$C51E,2;22 {  *HL++ = 0;
 C$C520,1;22 }
 C$C521,2;22 %> while (--B); %>
*C$C523,3;22 collision();
 C$C526,3;22 if (Z) bounds_check();
 C$C529,1;22 // restore DE (-> character struct)
 C$C52A,1;22 // restore HL (-> empty vischar slot)
 C$C52B,1;22 RET NZ // if collision or bounds_check is nonzero, then return
 C$C52C,1;22 {A = *DE | characterstruct_FLAG_DISABLED; /* Disable character */
 C$C52D,2;22 }
 C$C52F,1;22 *DE = A;
 C$C530,2;22 A &= characterstruct_CHARACTER_MASK;
 C$C532,1;22 {*HL++ = A;
 C$C533,1;22 }
 C$C534,2;22 *HL = 0;
 C$C536,1;22 // save DE (-> character struct)
 C$C537,3;22 DE = &character_meta_data[0]; /* Commandant */
 C$C53A,1;22 {if (A) <%
 C$C53B,2;22 }
@nowarn
 C$C53D,3;22 DE = &character_meta_data[1]; /* Guard */
 C$C540,2;22 {  if (A >= 16) <%
 C$C542,2;22 }
 C$C544,3;22 DE = &character_meta_data[2]; /* Dog */
 C$C547,2;22 {    if (A >= 20) <%
 C$C549,2;22 }
 C$C54B,3;22 DE = &character_meta_data[3]; %> %> %> /* Prisoner */
*C$C54E,1
 C$C54F,2;22 {DE += 7;
 C$C551,1;22
 C$C552,1;22 }
 C$C553,2;22 *DE++ = *HL++;
 C$C555,2;22 *DE++ = *HL++;
 C$C557,2;22 {DE += 11;
 C$C559,1;22
 C$C55A,1;22 }
 C$C55B,2;22 *DE++ = *HL++;
 C$C55D,2;22 *DE++ = *HL++;
 C$C55F,1;22 {DE -= 8;
 C$C560,2;22
 C$C562,1;22 }
 C$C563,3;22 {memcpy(DE, &saved_pos_x, 6);
 C$C566,3;22
 C$C569,2;22 }
 C$C56B,1;22 // restore HL (-> character struct)
 C$C56C,1;22 {HL += 5; // charstr->route
 C$C56D,3;22
 C$C570,1;22 }
 C$C571,2;22 {DE += 7;
 C$C573,1;22
 C$C574,1;22 }
 C$C575,3;22 A = room_index;
 C$C578,1;22 *DE = A; // sampled DE=$803C (vischar->room)
 C$C579,1;22 {if (A) <%
 C$C57A,2;22 }
 C$C57C,3;22 {  play_speaker(sound_CHARACTER_ENTERS_2);
 C$C57F,3;22 }
 C$C582,3;22 {  play_speaker(sound_CHARACTER_ENTERS_1); %>
 C$C585,3;22 }
*C$C588,1;22 {DE -= 26; // vischar->route
 C$C589,2;22
 C$C58B,1;22 }
 C$C58C,2;22 *DE++ = *HL++; // copy route from charstr
 C$C58E,2;22 *DE++ = *HL++;
 C$C590,1;22 {HL -= 2;
 C$C591,1;22 }
; @label=again
*C$C592,1;22 {if (*HL == 0) <% // test charstr->route.index OR vischar->route.index (on 2nd pass)
 C$C593,1;22
 C$C594,2;22 }
 C$C596,2;22 {  DE += 3; %> // -> vischar->counter_and_flags
 C$C598,1;22
 C$C599,1;22 }
 C$C59A,2;22 else <%
*C$C59C,1;22 {  entered_move_characters = 0;
 C$C59D,3;22 }
 C$C5A0,1;22 // save vischar->pos
 C$C5A1,3;22 get_target(HL);
 C$C5A4,2;22 {  if (A == 255) <%
 C$C5A6,2;22 }
 C$C5A8,1;22 // restore vischar->pos
 C$C5A9,1;22 {    HL -= 2; // -> vischar->route
 C$C5AA,1;22 }
 C$C5AB,1;22 // save vischar->route
 C$C5AC,3;22 route_ended();
 C$C5AF,1;22 // HL = vischar->route
 C$C5B0,1;22 {    DE = HL + 2; // DE = vischar->pos
 C$C5B1,2;22
 C$C5B3,1;22 }
 C$C5B4,2;22 goto $C592; %>
*C$C5B6,2;22 {  if (A == 128) IY[1] |= vischar_FLAGS_TARGET_IS_DOOR; // $8021
 C$C5B8,2;22
 C$C5BA,4;22 }
*C$C5BE,1
 C$C5BF,3;22 {  memcpy(DE, HL, 3); %>
 C$C5C2,2;22 }
*C$C5C4,1;22 {*DE = 0; // zero vischar->counter_and_flags
 C$C5C5,1;22 }
 C$C5C6,1;22 {DE -= 7;
 C$C5C7,2;22
 C$C5C9,1;22 }
 C$C5CA,2
 C$C5CC,3;22 calc_vischar_iso_pos_from_vischar();
 C$C5CF,1
 C$C5D0,3;22 character_behaviour(); return; // exit via

; Reset a visible character (either a character or an object).
;
; Used by the routines at #R$68A2, #R$69C9, #R$B79B and #R$C47E.
;
; I:HL Pointer to visible character.
@label=reset_visible_character
cC$C5D3,1;21 A = *HL;
 C$C5D4,2;21 {if (A == character_NONE) return;
 C$C5D6,1;21 }
 C$C5D7,2;21 {if (A >= character_26_STOVE_1) <%
 C$C5D9,2;21
 C$C5DB,1;21 }
; A stove or crate character.
 C$C5DC,2;21 {  HL[0] = character_NONE;
 C$C5DE,1;21 }
 C$C5DF,2;21 HL[1] = 0xFF; // flags
 C$C5E1,2;21 {  HL[7] = 0; // more flags
 C$C5E3,2;21
 C$C5E5,2;21 }
 C$C5E7,2;21 {  HL += 0x0F; // vischar + 0x0F
 C$C5E9,1;21
 C$C5EA,1;21 }
; Save the old position.
 C$C5EB,3;21 DE = &movable_items[0]; // stove1
 C$C5EE,2;21 {  if (A != character_26_STOVE_1) <%
 C$C5F0,2;21 }
 C$C5F2,3;21 DE = &movable_items[2]; // stove2
 C$C5F5,2;21 {    if (A != character_27_STOVE_2) <%
 C$C5F7,2;21 }
 C$C5F9,3;21 DE = &movable_items[1]; %> %> // crate
; The DOS version of the game has a difference here. Instead of
; memcpy'ing the current vischar's position into the movable_items's
; position, it only copies the first two bytes. The code is setup for a
; copy of six bytes (cx is set to 3) but the 'movsw' ought to be a 'rep
; movsw' for it to work. It fixes the bug where stoves get left in place
; after a restarted game, but almost looks like an accident.
*C$C5FC,3;21 {  memcpy(DE, HL, 6);
 C$C5FF,2;21 }
 C$C601,1;21 return; %>
; A non-object character.
*C$C602,1;21 else <%
 C$C603,3;21 DE = get_character_struct(A);
 C$C606,2;21 *DE &= ~characterstruct_FLAG_DISABLED;
 C$C608,2;21 {
 C$C60A,1;21
 C$C60B,1;21 }
 C$C60C,1;21 A = HL[0x1C]; // room index
 C$C60D,1;21 {  *++DE = A; // characterstruct.room = room index;
 C$C60E,1;21
 C$C60F,1;21 }
 C$C610,1
 C$C611,1;21 {  HL[7] = 0; // more flags
 C$C612,3;21
 C$C615,2;21 }
 C$C617,2;21 {  HL += 0x0F; // vischar+0x0F
 C$C619,1;21 }
; Save the old position.
 C$C61A,1;21 {  DE++; // &characterstruct.x
 C$C61B,1;21 }
 C$C61C,1;21 {  if (A == 0) <%
 C$C61D,2;21 }
; Outdoors.
 C$C61F,3;21 pos_to_tinypos(HL,DE); %> // HL,DE updated
 C$C622,2;21 else <%
; Indoors.
*C$C624,2;21 B = 3;
*C$C626,1;21 {    do <% *DE++ = *HL;
 C$C627,1;21 }
 C$C628,1;21 {      HL += 2;
 C$C629,1;21
 C$C62A,1;21 }
 C$C62B,2;21 %> while (--B); %>
*C$C62D,1;21 {  HL -= 21; // reset HL to point to original vischar
 C$C62E,2;21
 C$C630,1;21 }
 C$C631,1;21 A = *HL; // HL points to vischar // sampled HL=$8040,$8020,$8080,$80A0
 C$C632,2;21 {  *HL++ = character_NONE;
 C$C634,1;21 }
 C$C635,2;21 {  *HL++ = vischar_FLAGS_EMPTY_SLOT;
 C$C637,1;21 }
; Guard dogs only.
 C$C638,2;21 {  if (A >= character_16_GUARD_DOG_1 && A <= character_19_GUARD_DOG_4) <%
 C$C63A,4;21
 C$C63E,2;21 }
 C$C640,2;21 {    *HL++ = 0xFF;
 C$C642,1;21 }
 C$C643,2;21 *HL = 0;
 C$C645,2;21 {    if (A >= character_18_GUARD_DOG_3) *HL = 24; /* Characters 18 and 19 */
 C$C647,2;21
 C$C649,2;21 }
*C$C64B,1;21 HL--; %>
*C$C64C,2;21 *DE++ = *HL++; // copy route into charstruct
 C$C64E,2;21 *DE++ = *HL++;
 C$C650,1;21 return; %>

; Gets a new location.
;
; Used by the routines at #R$A3BB, #R$C4E0, #R$C6A0 and #R$CB23.
;
; I:HL Pointer to characterstruct + 5. // sampled HL=$768E,$7695,$769C,$7617
; .    761E, 7625, 762C, 7633, 7656, 765D
; O:A  0/128/255
; O:HL Pointer to somewhere in word_783A.
@label=get_target
cC$C651,1;21 A = *HL;
 C$C652,2;21 {if (A == 0xFF) <%
 C$C654,2;21 }
 C$C656,1;21 {  A = *++HL & ~characterstruct_BYTE6_MASK_LO;
 C$C657,1;21
 C$C658,2;21 }
 C$C65A,1;21 *HL = A;
 C$C65B,3;21 random_nibble();
 C$C65E,2;21 A &= characterstruct_BYTE6_MASK_LO;
 C$C660,1;21 A += *HL;
 C$C661,1;21 {  *HL = A; %>
 C$C662,2;21 }
*C$C664,1;21 else <%
 C$C665,1;21 {  C = *++HL; // route.step
 C$C666,1;21 }
 C$C667,3;21 DE = get_route(A);
 C$C66A,2;21 H = 0;
 C$C66C,1;21 A = C;
 C$C66D,2;21 {  if (A == 0xFF) H--; // H = 0xFF
 C$C66F,2;21
 C$C671,1;21 }
*C$C672,1;21 L = A; // HL == -1, or A
 C$C673,1;21 HL += DE;
 C$C674,1
 C$C675,1;21 routebyte = routebytes[step];
 C$C676,2;21 if (routebyte == routebyte_END) ...
 C$C678,1;21 // interleaved
 C$C679,2;21 ... goto return_255; // route ends
 C$C67B,2;21 A &= ~door_REVERSE;
 C$C67D,2;21 {  if (A < 40) <%
 C$C67F,2;21 }
 C$C681,1;21 A = *DE;
 C$C682,2;21 {    if (*HL & route_REVERSED) A ^= door_LOCKED; // sampled HL=$762C,$8002,$7672,$7679,$7680,$76A3,$76AA,$76B1,$76B8,$76BF ... looks quite general // route index
 C$C684,2;21
 C$C686,2;21 }
*C$C688,3;21 HL = get_door();
 C$C68B,1;21 HL++;
 C$C68C,2;21 A = 0x80;
 C$C68E,1;21 return; %>
*C$C68F,1;21 {  A = *DE - 40; %>
 C$C690,2;21 }
; sampled A=$38,2D,02,06,1E,20,21,3C,23,2B,3A,0B,2D,04,03,1C,1B,21,3C,...
*C$C692,1;21 {HL = word_783A[A];
 C$C693,7;21
 C$C69A,1;21 }
*C$C69B,1;21 A = 0;
 C$C69C,1;21 return;
*C$C69D,2;21 return_255: A = 255;
 C$C69F,1;21 return;

; Move characters around.
;
; Used by the routine at #R$9D7B.
@label=move_characters
cC$C6A0,2;21 {entered_move_characters = 0xFF;
 C$C6A2,3;21 }
; Move to the next character, wrapping around after character 26.
 C$C6A5,3;21 {character = character_index + 1;
 C$C6A8,1;21 }
 C$C6A9,2;21 {if (character == character_26_STOVE_1)
 C$C6AB,2;21
 C$C6AD,1;21 character = character_0_COMMANDANT;}
*C$C6AE,3;21 character_index = character;
; Get its chararacter struct, exiting if it's not enabled.
 C$C6B1,3;21 HL = get_character_struct(character); // passing character in A
 C$C6B4,2;21 {if (*HL & characterstruct_FLAG_DISABLED)
 C$C6B6,1;21 return; /* Disabled character. */}
 C$C6B7,1
; Are any items to be found in the same room as the character?
 C$C6B8,1;21 {room = *++HL; // characterstruct room
 C$C6B9,1;21 }
 C$C6BA,1;21 {if (room != room_0_OUTDOORS) <%
 C$C6BB,2;21 }
; This discovers one item at a time.
 C$C6BD,3;21 is_item_discoverable_interior(room); // passing room in A, returning item in ?
 C$C6C0,2;21 {  if (Z) item_discovered(item); %> // passing item in C
 C$C6C2,3;21 }
*C$C6C5,1;21 HL = characterstruct
 C$C6C6,1;21 {HL += 2; // point at characterstruct pos
 C$C6C7,1;21 }
 C$C6C8,1
 C$C6C9,1;21 {HL += 3; // point at characterstruct target
 C$C6CA,1;21
 C$C6CB,1;21 }
; If standing still, return.
 C$C6CC,1;21 A = *HL; // charstr->route.index
 C$C6CD,1;21 {if (A == route_HALT) <%
 C$C6CE,2;21 }
 C$C6D0,1
 C$C6D1,1;21 return; %>
*C$C6D2,3;21 get_target(); // "move towards" ? // returning ? in A, ? in HL
 C$C6D5,2;21 {if (A == get_target_ROUTE_ENDS) <%
 C$C6D7,3;21 }
; When the route ends reverse the route.
 C$C6DA,3;21 character = character_index;
 C$C6DD,1;21 {  if (character != character_0_COMMANDANT) <%
 C$C6DE,2;21 }
; Not the commandant.
 C$C6E0,2;21 {    if (character >= character_12_GUARD_12)
 C$C6E2,2;21 goto character_12_or_higher;}
; Characters 1..11.
@label=character_1_to_11
*C$C6E4,1;21 {    *HL++ ^= (1 << 7); // HLlocation->x
 C$C6E5,3;21
 C$C6E8,1;21 }
; Pattern: [-2]+1
 C$C6E9,2;21 {    if (A & (1 << 7)) (*HL) -= 2;
 C$C6EB,3;21
 C$C6EE,1;21 }
*C$C6EF,1;21 (*HL)++; // i.e -1 or +1 // HLlocation->y
 C$C6F0,1
 C$C6F1,1;21 return; %>
; Commandant only.
@label=commandant
*C$C6F2,1;21 {  A = *HL & characterstruct_BYTE5_MASK; // sampled HL=$7617 (characterstruct + 5) // location
 C$C6F3,2;21 }
 C$C6F5,2;21 {  if (A != 36) goto character_1_to_11;
 C$C6F7,2;21 }
@label=character_12_or_higher
*C$C6F9,1;21
 C$C6FA,3;21 goto character_event; // exit via
;   Two unused bytes.
 B$C6FD,2;21 %>
*C$C6FF,2;21 {if (A == 0x80) <%
 C$C701,3;21 }
 C$C704,1;21 // DE points at characterstruct.pos - PUSH at $C6C8
 C$C705,1;21 {  room = DE[-1];
 C$C706,1;21
 C$C707,1;21 }
 C$C708,1
 C$C709,1;21 {  if (room == room_0_OUTDOORS) <%
 C$C70A,3;21 }
 C$C70D,1
; Divide the location at HL by 2 and store it to saved_pos.
 C$C70E,3;21 DE = &saved_pos_x;
 C$C711,2;21 B = 2; // 2 iters
*C$C713,1;21 {    do <% *DE++ = *HL++ >> 1;
 C$C714,4;21
 C$C718,1;21 }
 C$C719,2;21 %> while (--B);
 C$C71B,3;21 HL = &saved_pos_x;
 C$C71E,1;21 %>
; Establish a maximum for passing into change_by_delta.
*C$C71F,1;21 {  if (DE[-1] == room_0_OUTDOORS)
 C$C720,3;21
 C$C723,2;21 A = 2;
 C$C725,2;21
 C$C727,2;21 else A = 6;}
*C$C729,1
 C$C72A,2;21 B = 0;
 C$C72C,3;21 change_by_delta(A, B, HL, DE);
 C$C72F,1;21 DE++;
 C$C730,1;21 HL++;
 C$C731,3;21 change_by_delta(A, B, HL, DE);
 C$C734,1
 C$C735,1;21 {  if (B != 2) return; // managed to move
 C$C736,2;21
 C$C738,1;21 }
; So when we reach here a character is stuck.
; .
; Are we checking to see if a door is adjacent?
 C$C739,1;21 {  DE -= 2; // DE -> charstr->room
 C$C73A,1;21 }
 C$C73B,1;21 HL--; // HL -> doorpos
 C$C73C,1;21 {  *DE = (*HL & ~door_FLAGS_MASK_DIRECTION) >> 2; // extract room field
 C$C73D,4;21
 C$C741,1;21 }
; Stuff reading from doors[].
 C$C742,1;21 {  if ((*HL & door_FLAGS_MASK_DIRECTION) < 2) <% // sampled HL=$78FA,$794A,$78DA,$791E,$78E2,$790E,$796A,$790E,$791E,$7962,$791A
 C$C743,4;21
 C$C747,2;21 }
 C$C749,1;21 {    HL += 5; %> // next door's pos
 C$C74A,3;21
 C$C74D,1;21 }
 C$C74E,2;21 else <%
*C$C750,1;21 {    HL -= 3; %> // previous door's pos
 C$C751,1;21
 C$C752,1;21 }
*C$C753,1;21 {  room = *DE++;
 C$C754,1;21 }
 C$C755,1;21 {  if (room != room_0_OUTDOORS) <%
 C$C756,2;21 }
; Indoors. Copy the door's tinypos into the charstr's tinypos.
 C$C758,2;21 *DE++ = *HL++; // x
 C$C75A,2;21 *DE++ = *HL++; // y
 C$C75C,2;21 *DE++ = *HL++; // height
 C$C75E,1;21 DE--; %>
 C$C75F,2;21 else <%
; Outdoors. Copy the door's tinypos into the charstr's tinypos, dividing by two.
*C$C761,2;21 B = 3;
*C$C763,1;21 {    do <% *DE++ = *HL++ >> 1;
 C$C764,4;21
 C$C768,1;21 }
 C$C769,2;21 %> while (--B)
 C$C76B,1;21 DE--; %> %>
 C$C76C,2;21 else <%
*C$C76E,1
; Establish a maximum for passing into change_by_delta.
 C$C76F,1;21 {  room = DE[-1]; // DE -> charstr
 C$C770,1;21
 C$C771,1;21 }
 C$C772,1;21 {  if (room == room_0_OUTDOORS) A = 2; else A = 6;
 C$C773,4;21
 C$C777,2;21 }
*C$C779,1
 C$C77A,2;21 B = 0;
 C$C77C,3;21 change_by_delta(A, B, HL, DE);
 C$C77F,1;21 HL++;
 C$C780,1;21 DE++;
 C$C781,3;21 change_by_delta(A, B, HL, DE);
 C$C784,1;21 DE++;
 C$C785,1;21 {  if (B != 2) return; %> // managed to move
 C$C786,4;21
 C$C78A,1;21 }
; So when we reach here a character is stuck.
*C$C78B,1;21 DE++; // DE -> charstr->route
 C$C78C,1
 C$C78D,1;21 A = *HL; // sampled HL=$761E $7625 $768E $7695 $7656 $7695 $7680 // => character struct entry + 5 // route index
 C$C78E,2;21 {if (A == route_WANDER) return;
 C$C790,1;21 }
 C$C791,2;21 if ((A & route_REVERSED) != 0) ...
 C$C793,1;21 HL++;       // interleaved
; sampled HL = $7618, $762D, $7634, $7657, $766C, $76AB, $76B2, $76B9, $76C0, $76C7 => final byte of charstruct
 C$C794,2;21 ... goto exit;
 C$C796,1;21 (*HL)++; // route.step
 C$C797,1;21 return;
*C$C798,1;21 exit: (*HL)--; // route.step
 C$C799,1;21 return;

; Increments 'first' by ('first' - 'second').
;
; Used by the routine at #R$C6A0.
;
; I:A' A maximum value, usually 2 or 6.
; I:B Return code. Incremented if delta is zero.
; I:DE Pointer to bytes within character_structs. // 761b,761c, 7622,7623,
; .    7629,762a, 7630,7631, 7653,...
; I:HL Pointer to bytes within word_783A.         // 787a,787b, 787e,787f,
; .    78b2,78b3, 7884,7885, 7892,...
; O:B Incremented by one if no movement.
@label=change_by_delta
cC$C79A,1
 C$C79B,1;21 C = Adash; // ie. banked A // some maximum value
 C$C79C,1
 C$C79D,1;21 {A = *DE - *HL; // delta
 C$C79E,1;21 }
 C$C79F,2;21 if (A == 0) <%
 C$C7A1,1;21 B++;
 C$C7A2,1;21 return; %>
*C$C7A3,2;21 else if (A < 0) <% // delta -ve => second > first
 C$C7A5,2;21 A = -A; // absolute value
 C$C7A7,1;21 {  if (A >= C) A = C;
 C$C7A8,2;21
 C$C7AA,1;21 }
*C$C7AB,1;21 {  *DE += A; // move first towards second
 C$C7AC,2;21
 C$C7AE,1;21 }
 C$C7AF,1;21 return; %>
*C$C7B0,1;21 {else <% if (A >= C) A = C; // delta +ve => first > second
 C$C7B1,2;21
 C$C7B3,1;21 }
*C$C7B4,1;21 {  *DE -= A; // move first towards second
 C$C7B5,2;21
 C$C7B7,1;21 }
 C$C7B8,1;21 return; %>

; Get character struct.
;
; Used by the routines at #R$A38C, #R$C5D3 and #R$C6A0.
;
; I:A  Character index.
; O:HL Character struct.
@label=get_character_struct
cC$C7B9,1;21 {HL = &character_structs[A];
 C$C7BA,10;21
 C$C7C4,1;21 }
 C$C7C5,1;21 return;

; Character event.
;
; Used by the routines at #R$C6A0 and #R$CB2D.
; .
; Makes characters sit, sleep or other things TBD.
;
; I:HL Points to character_struct.unk2 or vischar.route.
@label=character_event
cC$C7C6,1;21 A = *HL;
 C$C7C7,2;21 {if (A >= character_7_GUARD_7  && A <= character_12_GUARD_12) goto character_sleeps;
 C$C7C9,4;21
 C$C7CD,3;21 }
*C$C7D0,2;21 {if (A >= character_18_GUARD_DOG_3 && A <= character_22_PRISONER_3) goto character_sits;
 C$C7D2,2;21
 C$C7D4,2;21 Bug: Should be $18 (sixth prisoner doesn't sit for breakfast)
 C$C7D6,3;21 }
*C$C7D9,1;21 // POPped by handlers
@nowarn
 C$C7DA,3;21 map = &character_to_event_handler_index_map[0];
 C$C7DD,2;21 B = NELEMS(character_to_event_handler_index_map); // 24 iterations
; Locate the character in the map.
*C$C7DF,1;21 {do <% if (A == map->character) goto call_action;
 C$C7E0,2;21 }
 C$C7E2,1;21 {  map += 2;
 C$C7E3,1;21 }
 C$C7E4,2;21 %> while (--B);
 C$C7E6,1
 C$C7E7,2;21 *HL = 0; // no action
 C$C7E9,1;21 return;
*C$C7EA,1;21 {call_action: goto character_event_handlers[*++HL];
 C$C7EB,5;21
@nowarn
 C$C7F0,8;21
 C$C7F8,1;21 }
; character_to_event_handler_index_map
; .
; Array of (character + flags, character event handler index) mappings.
@label=character_to_event_handler_index_map
 W$C7F9,2;21 character_6_GUARD_6       | 0b10100000, charevnt_0,
 W$C7FB,2;21 character_7_GUARD_7       | 0b10100000, charevnt_0,
 W$C7FD,2;21 character_8_GUARD_8       | 0b10100000, charevnt_1,
 W$C7FF,2;21 character_9_GUARD_9       | 0b10100000, charevnt_1,
 W$C801,2;21 character_5_GUARD_5       | 0b00000000, charevnt_0,
 W$C803,2;21 character_6_GUARD_6       | 0b00000000, charevnt_1,
 W$C805,2;21 character_5_GUARD_5       | 0b10000000, charevnt_3,  // checks byte_A13E case 1
 W$C807,2;21 character_6_GUARD_6       | 0b10000000, charevnt_3,  // checks byte_A13E case 1
 W$C809,2;21 character_14_GUARD_14     | 0b00000000, charevnt_2,
 W$C80B,2;21 character_15_GUARD_15     | 0b00000000, charevnt_2,
 W$C80D,2;21 character_14_GUARD_14     | 0b10000000, charevnt_0,
 W$C80F,2;21 character_15_GUARD_15     | 0b10000000, charevnt_1,
 W$C811,2;21 character_16_GUARD_DOG_1  | 0b00000000, charevnt_5,  // checks byte_A13E case 2
 W$C813,2;21 character_16_GUARD_DOG_2  | 0b00000000, charevnt_5,  // checks byte_A13E case 2
 W$C815,2;21 character_16_GUARD_DOG_1  | 0b10000000, charevnt_0,
 W$C817,2;21 character_16_GUARD_DOG_2  | 0b10000000, charevnt_1,
 W$C819,2;21 character_0_COMMANDANT    | 0b10100000, charevnt_0,
 W$C81B,2;21 character_1_GUARD_1       | 0b10100000, charevnt_1,
 W$C81D,2;21 character_10_GUARD_10     | 0b00100000, charevnt_7,
 W$C81F,2;21 character_12_GUARD_12     | 0b00100000, charevnt_8,  // hero sleeps
 W$C821,2;21 character_11_GUARD_11     | 0b00100000, charevnt_9,  // hero sits
 W$C823,2;21 character_4_GUARD_4       | 0b10100000, charevnt_6,  // go to 0x0315
 W$C825,2;21 character_4_GUARD_4       | 0b00100000, charevnt_10, // released from solitary
 W$C827,2;21 character_5_GUARD_5       | 0b00100000, charevnt_4,  // zero in_solitary
; character_event_handlers
; .
; Array of pointers to character event handlers.
@label=character_event_handlers
 W$C829,2;21 charevnt_handler *character_event_handlers[] = { &charevnt_wander_top,
 W$C82B,2;21 &charevnt_wander_left,
 W$C82D,2;21 &charevnt_wander_yard,
 W$C82F,2;21 &charevnt_bed,
 W$C831,2;21 &charevnt_solitary_ends,
 W$C833,2;21 &charevnt_breakfast,
 W$C835,2;21 &charevnt_commandant_to_yard,
 W$C837,2;21 &charevnt_exit_hut2,
 W$C839,2;21 &charevnt_hero_sleeps,
 W$C83B,2;21 &charevnt_hero_sits,
 W$C83D,2;21 &charevnt_hero_release, };
; charevnt_solitary_ends
@label=charevnt_solitary_ends
 C$C83F,1;21 {in_solitary = 0; // enable player control
 C$C840,3;21 }
 C$C843,2;21 goto charevnt_wander_top;
; charevnt_commandant_to_yard
@label=charevnt_commandant_to_yard
 C$C845,1;21 // (popped) sampled HL=$80C2 (x2),$8042  // route
 C$C846,2;21 {*HL++ = 0x03;
 C$C848,1;21 }
 C$C849,2;21 *HL   = 0x15;
 C$C84B,1;21 return;
; charevnt_hero_release
@label=charevnt_hero_release
 C$C84C,1
 C$C84D,2;21 {*HL++ = 0xA4;
 C$C84F,1;21 }
 C$C850,2;21 *HL   = 0x03;
 C$C852,1;21 {automatic_player_counter = 0; // force automatic control
 C$C853,3;21 }
 C$C856,3;21 {set_hero_route(0x0025); return;
 C$C859,3;21 }
; charevnt_wander_left
@label=charevnt_wander_left
 C$C85C,2;21 C = 0x10; // 0xFF10
 C$C85E,2;21 goto exit;
; charevnt_wander_yard
@label=charevnt_wander_yard
 C$C860,2;21 C = 0x38; // 0xFF38
 C$C862,2;21 goto exit;
; charevnt_wander_top
@label=charevnt_wander_top
*C$C864,2;21 C = 0x08; // 0xFF08 // sampled HL=$8022,$8042,$8002,$8062
*C$C866,1;21 exit:
 C$C867,2;21 {*HL++ = 0xFF;
 C$C869,1;21 }
 C$C86A,1;21 *HL   = C;
 C$C86B,1;21 return;
; charevnt_bed
@label=charevnt_bed
 C$C86C,1
 C$C86D,3;21 {if (entered_move_characters == 0) goto character_bed_vischar; else goto character_bed_state;
 C$C870,4;21
 C$C874,3;21 }
; charevnt_breakfast
@label=charevnt_breakfast
 C$C877,1
 C$C878,3;21 {if (entered_move_characters == 0) goto charevnt_breakfast_vischar; else goto charevnt_breakfast_state;
 C$C87B,4;21
 C$C87F,3;21 }
; charevnt_exit_hut2
@label=charevnt_exit_hut2
 C$C882,1
 C$C883,2;21 {*HL++ = 0x05;
 C$C885,1;21 }
 C$C886,2;21 *HL   = 0x00;
 C$C888,1;21 return;
; charevnt_hero_sits
@label=charevnt_hero_sits
 C$C889,1
 C$C88A,3;21 goto hero_sits;
; charevnt_hero_sleeps
@label=charevnt_hero_sleeps
 C$C88D,1
 C$C88E,3;21 goto hero_sleeps;

; A countdown until any food item is discovered.
;
; (<- automatics, target_reached)
@label=food_discovered_counter
gB$C891,1

; Make characters follow the hero if he's being suspicious.
;
; Used by the routine at #R$9D7B.
; .
; Also: Food item discovery.
; .
; Also: Automatic hero behaviour.
;
; .
;
; (I've still no idea what this flag means).
@label=automatics
cC$C892,1;21 {entered_move_characters = 0;
 C$C893,3;21 }
; If the bell is not ringing, hostiles pursue.
 C$C896,3;21 {if (bell == bell_RING_PERPETUAL) hostiles_pursue();
 C$C899,1;21
 C$C89A,3;21 }
; If food was dropped then count down until it is discovered.
 C$C89D,3;21 {if (food_discovered_counter != 0 && --food_discovered_counter == 0) <%
 C$C8A0,5;21
 C$C8A5,2;21 }
; De-poison the food.
@nowarn
 C$C8A7,3;21 {  item_structs[item_FOOD].item &= ~itemstruct_ITEM_FLAG_POISONED;
 C$C8AA,2;21 }
 C$C8AC,2;21 C = item_FOOD;
 C$C8AE,3;21 item_discovered(); %>
; Make supporting characters react.
@nowarn
*C$C8B1,4;21 IY = $8020; // iterate over non-player characters
 C$C8B5,2;21 B = 7; // iterations
*C$C8B7,1;21 do <%
 C$C8B8,3;21 {  if (IY[1] != empty slot) <% // flags
 C$C8BB,2;21
 C$C8BD,3;21 }
 C$C8C0,3;21 {    A = IY[0] & vischar_CHARACTER_MASK; // character index
 C$C8C3,2;21 }
 C$C8C5,2;21 {    if (A <= character_19_GUARD_DOG_4) <% // Hostile characters only.}
 C$C8C7,3;21
; Characters 0..19.
 C$C8CA,1
 C$C8CB,3;21 is_item_discoverable();
 C$C8CE,3;21 {      if (red_flag || automatic_player_counter > 0) guards_follow_suspicious_character();
 C$C8D1,7;21
*C$C8D8,3;21 }
 C$C8DB,1
; Guard dogs 1..4 (characters 16..19).
 C$C8DC,2;21 {      if (A >= character_16_GUARD_DOG_1) <%
 C$C8DE,3;21
 C$C8E1,3;21 }
; Is the food nearby?
 C$C8E4,2;21 {        if (item_structs[item_FOOD].room & itemstruct_ROOM_FLAG_NEARBY_7) IY[1] = vischar_FLAGS_DOG_FOOD; %> %>
 C$C8E6,9;21
 C$C8EF,2;21 }
*C$C8F1,3;21 character_behaviour(); %>
*C$C8F4,1
 C$C8F5,3;21 {  IY += 32; // stride
 C$C8F8,2;21 }
 C$C8FA,1;21 {%> while (--B);
 C$C8FB,3;21 }
; Inhibit hero automatic behaviour when the flag is red, or otherwise
; inhibited.
 C$C8FE,3;21 {if (!red_flag && (in_solitary || automatic_player_counter == 0)) <%}
 C$C901,1;21
; Bug: Pointless JP NZ (jumps to RET, RET NZ would do).
 C$C902,14;21
*C$C910,4;21 IY = $8000;
 C$C914,3;21 character_behaviour(); %>
*C$C917,1;21 return;

; Character behaviour stuff.
;
; Used by the routines at #R$C4E0 and #R$C892.
;
; I:IY Pointer to visible character.
@label=character_behaviour
cC$C918,3;22 A = IY[7]; // $8007 etc. // more flags
 C$C91B,1;22 B = A;
; If the bottom nibble is set then decrement it.
 C$C91C,2;22 A &= vischar_BYTE7_MASK_LO;
 C$C91E,2;22 if (A) <%
 C$C920,1;22 {  IY[7] = --B; // decrement but don't affect flags
 C$C921,3;22 }
 C$C924,1;22 return; %>
*C$C925,2;22 {HL = IY;
 C$C927,1;22 }
 C$C928,1;22 {A = *++HL; // incremented HL is $8021 $8041 $8061
 C$C929,1;22 }
 C$C92A,1;22 {if (A != 0) <%
 C$C92B,3;22 }
 C$C92E,2;22 {  if (A == vischar_FLAGS_PURSUE) <%
 C$C930,2;22 }
*C$C932,1
 C$C933,1
 C$C934,1;22 POP DEdash // ie. DEdash = HL
 C$C935,1;22 {    DEdash += 3;
 C$C936,1;22
 C$C937,1;22 }
 C$C938,3;22 HLdash = &hero_map_position.x;
 C$C93B,2;22 *DEdash++ = *HLdash++;
 C$C93D,2;22 *DEdash++ = *HLdash++;
 C$C93F,1
 C$C940,3;22 goto end_bit; %>
*C$C943,2;22 {  else if (A == vischar_FLAGS_HASSLE) <%
 C$C945,2;22 }
 C$C947,3;22 {    if (automatic_player_counter) goto $C932; // jump into case 1
 C$C94A,1;22
 C$C94B,2;22 }
 C$C94D,2;22 {    *HL++ = 0;
 C$C94F,1;22 }
 C$C950,3;22 get_target_assign_pos(); return; %> // exit via
*C$C953,2;22 {  else if (A == vischar_FLAGS_DOG_FOOD) <%}
 C$C955,2;22
 C$C957,2
 C$C959,3;22 {    if (item_structs[item_FOOD].room & itemstruct_ROOM_FLAG_NEARBY_7) <%
 C$C95C,2;22
 C$C95E,2;22 }
; Moves dog toward poisoned food?
 C$C960,1;22 HL++;
 C$C961,1;22 {      DE += 3;
 C$C962,2;22
 C$C964,1;22 }
 C$C965,2;22 *DE++ = *HL++;
 C$C967,2;22 *DE++ = *HL++;
 C$C969,1
 C$C96A,2;22 goto end_bit; %>
*C$C96C,1;22 else <% A = 0;
 C$C96D,1;22 *DE = A;
 C$C96E,1
 C$C96F,1;22 {      *++HL = 0xFF;
 C$C970,2;22 }
 C$C972,1;22 {      *++HL = 0;
 C$C973,2;22 }
 C$C975,1
 C$C976,3;22 get_target_assign_pos(); return; %> %> // exit via
*C$C979,2;22 {  else if (A == vischar_FLAGS_SAW_BRIBE) <%
 C$C97B,2;22 }
 C$C97D,1
 C$C97E,3;22 A = bribed_character;
 C$C981,2;22 {    if (A != character_NONE) <%
 C$C983,2;22 }
 C$C985,1
 C$C986,2;22 B = 7; // 7 iterations
@nowarn
 C$C988,3;22 HL = $8020; // iterate over non-player characters
*C$C98B,1;22 do <%
 C$C98C,1;22 {        if (*HL == A) goto found_bribed;
 C$C98D,2;22 }
 C$C98F,2;22 {        HL += 32;
 C$C991,1;22
 C$C992,1;22 }
 C$C993,2;22 %> while (--B); %>
*C$C995,1
; Bribed character was not visible.
 C$C996,2;22 {    *HL++ = 0;
 C$C998,1;22 }
 C$C999,3;22 get_target_assign_pos(); return; // exit via
; Found bribed character.
*C$C99C,2;22 {found_bribed: HL += 15;
 C$C99E,1;22
 C$C99F,1;22 }
 C$C9A0,2
 C$C9A2,1;22 {    DE += 3;
 C$C9A3,2;22
 C$C9A5,1;22 }
 C$C9A6,3;22 {    if (room_index) <%
 C$C9A9,1;22
 C$C9AA,3;22 }
; Outdoors.
 C$C9AD,3;22 pos_to_tinypos(HL,DE); %>
 C$C9B0,2;22 else <%
; Indoors.
*C$C9B2,2;22 *DE++ = *HL++;
 C$C9B4,1;22 HL++;
 C$C9B5,2;22 *DE++ = *HL++; %>
*C$C9B7,1
 C$C9B8,2;22 goto end_bit; %> %>
;
*C$C9BA,1;22 {A = HL[1]; // route index
 C$C9BB,1;22
 C$C9BC,1;22 }
 C$C9BD,1;22 {if (A == 0) goto character_behaviour_set_input;
 C$C9BE,2;22 }
*C$C9C0,1;22 end_bit: A = *HL; // HL is $8001
 C$C9C1,1
 C$C9C2,1;22 Cdash = A;
; Self modify vischar_move_x/y routines.
 C$C9C3,3;22 {if (room_index > room_0_OUTDOORS) <%
 C$C9C6,1;22
 C$C9C7,2;22 }
@nowarn
 C$C9C9,3;22 HLdash = &multiply_by_1; %>
 C$C9CC,2;22 else <%
*C$C9CE,2;22 {  if (Cdash & vischar_FLAGS_TARGET_IS_DOOR) <%
 C$C9D0,2;22 }
@nowarn
 C$C9D2,3;22 HLdash = &multiply_by_4; %>
 C$C9D5,2;22 else <%
@nowarn
*C$C9D7,3;22 HLdash = &multiply_by_8; %> %>
*C$C9DA,3;22 ($CA13) = HLdash; // self-modify vischar_move_x:$CA13
 C$C9DD,3;22 ($CA4B) = HLdash; // self-modify vischar_move_y:$CA4B
 C$C9E0,1
 C$C9E1,4;22 {if (IY[7] & vischar_BYTE7_Y_DOMINANT) goto character_behaviour_impeded; // hit a wall etc.
 C$C9E5,2;22 }
 C$C9E7,1;22 {HL += 3;
 C$C9E8,1;22
 C$C9E9,1;22 }
 C$C9EA,3;22 vischar_move_x();
 C$C9ED,2;22 if (Z) <%
 C$C9EF,3;22 vischar_move_y();
 C$C9F2,3;22 if (Z) goto target_reached; %> // exit via // character couldn't move?
; This entry point is used by the routine at #R$CA81.
*C$C9F5,3;22 {character_behaviour_set_input: if (A != IY[13]) IY[13] = A | input_KICK; // sampled IY=$8040,$8020,$8000
 C$C9F8,3;22
 C$C9FB,3;22 }
 C$C9FE,1;22 return;
*C$C9FF,2;22 {character_behaviour_impeded: L += 4;
 C$CA01,1;22
 C$CA02,1;22 }
 C$CA03,3;22 vischar_move_y();
 C$CA06,2;22 {if (Z) vischar_move_x();
 C$CA08,3;22 }
 C$CA0B,2;22 if (!Z) goto character_behaviour_set_input; // likely: couldn't move, so .. do something
 C$CA0D,1;22 HL--;
 C$CA0E,3;22 target_reached(); return; // exit via

; Move character on the X axis.
;
; Used by the routine at #R$C918.
;
; I:HL Pointer to visible character block + 4.
; I:IY Pointer to visible character block.
; O:A  8/4/0 .. meaning ?
; O:HL Pointer to visible character block + 5. (Ready to pass into vischar_move_y)
@label=vischar_move_x
cC$CA11,1;22 A = *HL; // sampled HL=$8004,$8044,$8064,$8084  vischar->pos.x
 C$CA12,3;22 BC = multiply_by_8(A); // self modified by #R$C9DA
 C$CA15,1;22 {HL += 11; // position on X axis ($800F etc.)
 C$CA16,2;22
 C$CA18,1;22 }
; Read vischar->mi.pos.x
 C$CA19,1;22 {E = *HL++;
 C$CA1A,1;22 }
 C$CA1B,1;22 D = *HL;
 C$CA1C,1
 C$CA1D,2;22 DE -= BC;  // delta
 C$CA1F,2;22 if (DE) <%
 C$CA21,3;22 if (DE > 0) <%
; Positive delta
 C$CA24,1;22 {    if (D != 0   || E >= 3)  <% A = 8; return; %> %>
 C$CA25,1;22 else <% // -ve
 C$CA26,7;22
*C$CA2D,2;22
 C$CA2F,1;22 }
; Negative delta
*C$CA30,1;22 {    if (D != 255 || E < 254) <% A = 4; return; %> %>
 C$CA31,2;22 %>
 C$CA33,8;22
*C$CA3B,2;22
 C$CA3D,1;22 }
;
*C$CA3E,1
 C$CA3F,1;22 {HL -= 11;
 C$CA40,2;22
 C$CA42,1;22 }
 C$CA43,4;22 IY[7] |= vischar_BYTE7_Y_DOMINANT;
 C$CA47,1;22 A = 0;
 C$CA48,1;22 return;

; Move character on the Y axis.
;
; Used by the routine at #R$C918.
; .
; Nearly identical to vischar_move_x above.
;
; I:HL Pointer to visible character block + 5.
; I:IY Pointer to visible character block.
; O:A  5/7/0 .. meaning ?
; O:HL Pointer to visible character block + 4. (Ready to pass into vischar_move_x)
@label=vischar_move_y
cC$CA49,1;22 A = *HL; // sampled HL=$8025,$8065,$8005
 C$CA4A,3;22 multiply_by_8(); // self modified by #R$C918
 C$CA4D,1;22 {HL += 12; // position on Y axis ($8011 etc.)
 C$CA4E,2;22
 C$CA50,1;22 }
 C$CA51,1;22 {E = *HL++;
 C$CA52,1;22 }
 C$CA53,1;22 D = *HL;
 C$CA54,1
 C$CA55,2;22 DE -= BC;
 C$CA57,2;22 if (DE) <%
 C$CA59,3;22 if (DE > 0) <% // +ve
 C$CA5C,1;22 {    if (D != 0   || E >= 3)  <% A = 5; return; %> %>
 C$CA5D,1;22 else <% // -ve
 C$CA5E,7;22
*C$CA65,2;22
 C$CA67,1;22 }
*C$CA68,1;22 {    if (D != 255 || E < 254) <% A = 7; return; %> %>
 C$CA69,2;22 %>
 C$CA6B,8;22
*C$CA73,2;22
 C$CA75,1;22 }
*C$CA76,1
 C$CA77,1;22 {HL -= 14;
 C$CA78,2;22
 C$CA7A,1;22 }
 C$CA7B,4;22 IY[7] &= ~vischar_BYTE7_Y_DOMINANT;
 C$CA7F,1;22 A = 0;
 C$CA80,1;22 return;

; Called when a character reaches its target.
;
; Used by the routine at #R$C918.
;
; I:IY Pointer to $8000, $8020, $8040, $8060, $8080
; I:HL Pointer to $8004, $8024, $8044, $8064, $8084
@label=target_reached
cC$CA81,3;21 A = IY[1];
 C$CA84,1;21 C = A;
 C$CA85,2;21 A &= vischar_FLAGS_MASK;
 C$CA87,2;21 if (A) <%
 C$CA89,2;21 {  if (A == vischar_FLAGS_PURSUE) <%
 C$CA8B,2;21 }
 C$CA8D,3;21 {    if (IY[0] == bribed_character) <% accept_bribe(); return; %> // exit via
 C$CA90,3;21
 C$CA93,3;21 }
 C$CA96,3;21 else <% solitary(); return; %> %> // failed to bribe? // exit via
*C$CA99,2;21 {  else if (A == vischar_FLAGS_HASSLE || A == vischar_FLAGS_SAW_BRIBE) <% return; %>
 C$CA9B,3;21
 C$CA9E,1;21 }
 C$CA9F,1
; Decide how long until food is discovered.
@nowarn
 C$CAA0,3;21 {  if ((item_structs[item_FOOD].item & itemstruct_ITEM_FLAG_POISONED) == 0) A = 32; else A = 255;
 C$CAA3,6;21
 C$CAA9,2;21 }
*C$CAAB,3;21 food_discovered_counter = A;
 C$CAAE,1
 C$CAAF,1;21 {  HL -= 2;
 C$CAB0,1;21 }
 C$CAB1,1;21 {  *HL = 0;
 C$CAB2,1;21 }
 C$CAB3,3;21 goto character_behaviour_set_input; %> // exit via
*C$CAB6,2;21 {if (C & vischar_FLAGS_TARGET_IS_DOOR) <%
 C$CAB8,2;21 }
; Results in character entering.
 C$CABA,1;21 {  C = *--HL; // 80a3, 8083, 8063, 8003 // route.step
 C$CABB,1;21 }
 C$CABC,1;21 {  A = *--HL;
 C$CABD,1;21 }
 C$CABE,1
 C$CABF,3;21 DE = get_route(A);
 C$CAC2,1
 C$CAC3,1;21 {  DE += C;
 C$CAC4,4;21
 C$CAC8,1;21 }
*C$CAC9,1;21 A = *DE;
 C$CACA,2;21 {  if (*HL & route_REVERSED) A ^= door_REVERSE;
 C$CACC,2;21
 C$CACE,2;21 }
*C$CAD0,1
 C$CAD1,1;21 {  A = *HL++; // $8002, ...
 C$CAD2,1;21 }
; Pattern: [-2]+1
 C$CAD3,2;21 {  if (A & route_REVERSED) (*HL) -= 2; // $8003, ... // route.step
 C$CAD5,3;21
 C$CAD8,1;21 }
*C$CAD9,1;21 (*HL)++; // route.step
 C$CADA,1
 C$CADB,3;21 HL = get_door();
 C$CADE,1;21 {  IY[0x1C] = (*HL >> 2) & 0x3F; // IY=$8000 => $801C (room index) // HL=$790E,$7962,$795E => door position thingy // 0x3F is doors[0] room mask shifted right 2
 C$CADF,4;21
 C$CAE3,3;21 }
; TOP_LEFT or TOP_RIGHT => next door pos
; .
; BOTTOM_RIGHT or BOTTOM_LEFT => current door pos
 C$CAE6,1;21 {  A = *HL & door_FLAGS_MASK_DIRECTION; // door position thingy, lowest two bits -- index?
 C$CAE7,2;21 }
 C$CAE9,2;21 {  if (A < 2) HL += 5; else HL -= 3;
 C$CAEB,10;21
*C$CAF5,1;21
 C$CAF6,1;21
 C$CAF7,1;21 }
*C$CAF8,1
 C$CAF9,2;21 {  HL = IY;
 C$CAFB,1;21 }
 C$CAFC,1;21 {  if (L == 0) <%
 C$CAFD,1;21
 C$CAFE,3;21 }
; Hero's vischar only.
 C$CB01,1;21 HL++; // $8000 -> $8001
 C$CB02,2;21 {    *HL++ &= ~vischar_FLAGS_TARGET_IS_DOOR;
 C$CB04,1;21 }
 C$CB05,3;21 get_target_assign_pos(); %>
*C$CB08,1
 C$CB09,3;21 transition();
 C$CB0C,3;21 {  play_speaker(sound_CHARACTER_ENTERS_1);
 C$CB0F,3;21 }
 C$CB12,1;21 return; %>
*C$CB13,1;21 {HL -= 2;
 C$CB14,1;21 }
 C$CB15,1;21 A = *HL; // $8002 etc. // route
 C$CB16,2;21 {if (A != 0xFF) <%
 C$CB18,2;21 }
 C$CB1A,1;21 HL++;
 C$CB1B,2;21 {  if (A & route_REVERSED) <%
 C$CB1D,2;21 }
 C$CB1F,1;21 {    (*HL) -= 2; %> // $8003 etc.
 C$CB20,1;21 }
*C$CB21,1;21 else <% (*HL)++;
 C$CB22,1;21 HL--; %> %>
; FALL THROUGH to get_target_assign_pos.

; (unknown) get_target_assign_pos
;
; Used by the routines at #R$A3BB, #R$B107, #R$C918, #R$CA81 and #R$CB2D.
;
; I:A  Character index?
; I:HL ?
@label=get_target_assign_pos
cC$CB23,1
 C$CB24,3;21 get_target();
 C$CB27,2;21 {if (A == 0xFF) <%
 C$CB29,3;21 }
 C$CB2C,1
; FALL THROUGH into route_ended.

; Called when a character has run out of route.
;
; Used by the routine at #R$C4E0.
;
; .
;
; If not the hero's vischar ...
@label=route_ended
cC$CB2D,1;21 {  if (L != 0x02) <%
 C$CB2E,2;21
 C$CB30,3;21 }
 C$CB33,3;21 {    if (IY[0] & vischar_CHARACTER_MASK == 0) <%
 C$CB36,2;21
 C$CB38,2;21 }
 C$CB3A,1;21 {      A = *HL & ~route_REVERSED;
 C$CB3B,2;21 }
 C$CB3D,2;21 {      if (A == 36) goto $CB46; // character index
 C$CB3F,2;21 }
 C$CB41,1;21 A = 0; %> // forces next if statement to be taken
*C$CB42,2;21 {    if (A <= character_11_GUARD_11) goto $CB50; %>
 C$CB44,2;21 }
; We arrive here if:
; - vischar is the hero, or
; - character is character_0_COMMANDANT and (route.index & 0x7F) == 36, or
; - character is >= character_12_GUARD_12
*C$CB46,1
 C$CB47,3;21 character_event();
 C$CB4A,1
 C$CB4B,1;21 A = *HL;
 C$CB4C,1;21 {  if (A == 0) return;
 C$CB4D,1;21 }
 C$CB4E,2;21 get_target_assign_pos(); return; // exit via
; We arrive here if:
; - vischar is not the hero, and
;   - character is character_0_COMMANDANT and (route.index & 0x7F) != 36, or
;   - character is character_1_GUARD_1 .. character_11_GUARD_11
*C$CB50,1;21 {  *HL++ = *HL ^ 0x80;
 C$CB51,3;21
 C$CB54,1;21 }
; Pattern: [-2]+1
 C$CB55,2;21 {  if (A & (1<<7)) <%
 C$CB57,2;21 }
 C$CB59,1;21 {    (*HL) -= 2; %>
 C$CB5A,1;21 }
*C$CB5B,1;21 (*HL)++
 C$CB5C,1;21 HL--;
 C$CB5D,1;21 A = 0;
 C$CB5E,1;21 return; %> // strictly the terminating brace is after the following unreferenced bytes
;
 B$CB5F,2;21 Unreferenced bytes.

; (unknown) handle_target
;
; Used by the routine at #R$CB23.
@label=handle_target
cC$CB61,2;22 {if (A == 128) <%
 C$CB63,3;22 }
 C$CB66,4;22 IY[1] |= vischar_FLAGS_TARGET_IS_DOOR; %>
*C$CB6A,1
 C$CB6B,1;22 {memcpy(DE + 2, HL, 2);
 C$CB6C,4;22
 C$CB70,2;22 }
 C$CB72,2;22 A = 128;
 C$CB74,1;22 return;

; Widen A to BC (multiply by 1).
@label=multiply_by_1
cC$CB75,1;21 {BC = A; return;
 C$CB76,2;21
 C$CB78,1;21 }

; Return a route.
;
; Used by the routines at #R$C651 and #R$CA81.
;
; I:A  Index.
; O:DE Pointer to route data.
; O:HL $7738 + A*2 + 1
@label=get_route
cC$CB79,1;21 {DE = routes[A];
 C$CB7A,9;21
 C$CB83,1;21 }
 C$CB84,1;21 return;

; Pseudo-random number generator.
;
; This returns the bottom nibbles of the bytes from $9000..$90FF in sequence,
; acting as a cheap pseudo-random number generator.
; .
; Used by the routine at #R$C651.
;
; O:A  Pseudo-random number from 0..15.
; O:HL Preserved.
@label=random_nibble
cC$CB85,1;21 Preserve #REGhl
 C$CB86,3;21 Point at the prng_pointer (initialised on load to $9000)
 C$CB89,1;21 Increment its bottom byte, wrapping at $90FF
 C$CB8A,1;21 Fetch a byte from the pointer
 C$CB8B,2;21 Mask off the bottom nibble
 C$CB8D,3;21 Save the incremented prng_pointer
 C$CB90,1;21 Restore #REGhl
 C$CB91,1;21 Return

; Unreferenced bytes.
uB$CB92,6

; The hero has been sent to solitary.
;
; Used by the routines at #R$A51C, #R$AFDF, #R$CA81 and #R$EFCB.
;
; .
;
; Silence bell.
@label=solitary
cC$CB98,2;23 {bell = bell_STOP;
 C$CB9A,3;23 }
; Seize hero's held items.
 C$CB9D,3;23 HL = &items_held[0];
 C$CBA0,1;23 C = *HL;
 C$CBA1,1;23 *HL = item_NONE;
 C$CBA2,3;23 item_discovered();
 C$CBA5,3;23 HL = &items_held[1];
 C$CBA8,1;23 C = *HL;
 C$CBA9,2;23 *HL = item_NONE;
 C$CBAB,3;23 item_discovered();
 C$CBAE,3;23 draw_all_items();
; Discover all items.
 C$CBB1,2;23 B = 16; // all items
 C$CBB3,3;23 HL = &item_structs[0].room;
*C$CBB6,1;23 do <%
 C$CBB7,1
; Is the item outdoors?
 C$CBB8,1;23 {  A = *HL & itemstruct_ROOM_MASK;
 C$CBB9,2;23 }
 C$CBBB,2;23 if (A == room_0_OUTDOORS) <%
 C$CBBD,1;23 {    A = *--HL;
 C$CBBE,1;23 }
 C$CBBF,1;23 {    HL += 2;
 C$CBC0,1;23 }
 C$CBC1,2
 C$CBC3,1;23 A = 0;
*C$CBC4,1;23 do <%
 C$CBC5,1
; If the item is within the camp bounds then it will be discovered.
 C$CBC6,3;23 within_camp_bounds();
 C$CBC9,2;23 if (Z) goto $CBD5;
 C$CBCB,2
 C$CBCD,1;23 {    %> while (++A != 3);
 C$CBCE,2;23
 C$CBD0,3;23 }
 C$CBD3,2;23 goto next;
*C$CBD5,1
 C$CBD6,2
 C$CBD8,1;23 C = A;
 C$CBD9,3;23 item_discovered(); %>
*C$CBDC,1;23 next:
 C$CBDD,1
 C$CBDE,3;23 {  HL += 7; // stride
 C$CBE1,1;23 }
 C$CBE2,2;23 %> while (--B);
; Move the hero to solitary.
 C$CBE4,2;23 {$801C = room_24_SOLITARY;
 C$CBE6,3;23 }
 C$CBE9,2;23 {current_door = 20;
 C$CBEB,3;23 }
 C$CBEE,2;23 {decrease_morale(35);
 C$CBF0,3;23 }
 C$CBF3,3;23 reset_map_and_characters();
 C$CBF6,3;23 {memcpy(&character_structs[0].secondbyte, &solitary_hero_reset_data, 6);
 C$CBF9,6;23
 C$CBFF,2;23 }
 C$CC01,2;23 {queue_message(message_YOU_ARE_IN_SOLITARY);
 C$CC03,3;23 }
 C$CC06,2;23 {queue_message(message_WAIT_FOR_RELEASE);
 C$CC08,3;23 }
 C$CC0B,2;23 {queue_message(message_ANOTHER_DAY_DAWNS);
 C$CC0D,3;23 }
 C$CC10,2;23 {in_solitary = 0xFF; // inhibit user input
 C$CC12,3;23 }
 C$CC15,1;23 {automatic_player_counter = 0; // immediately take automatic control of hero
 C$CC16,3;23 }
 C$CC19,3;23 {$8015 = sprite_prisoner;
 C$CC1C,3;23 }
 C$CC1F,3;23 HL = &solitary_pos;
 C$CC22,4;23 IY = $8000;
 C$CC26,4;23 IY[0x0E] = direction_BOTTOM_LEFT; // character faces bottom left
 C$CC2A,1;23 {($8002) = 0; // route.index = route_HALT
 C$CC2B,3;23 }
 C$CC2E,3;23 transition(); return; // exit via

; Partial character struct.
;
; (<- solitary)
@label=solitary_hero_reset_data
bB$CC31,1;24 room = room_0_OUTDOORS
 B$CC32,3;24 pos = 0x74, 0x64, 0x03
 B$CC35,2;24 route = 0x24, 0x00

; Guards follow suspicious character.
;
; Used by the routine at #R$C892.
;
; I:IY Pointer to visible character.
@label=guards_follow_suspicious_character
cC$CC37,2;23 {HL = IY;
 C$CC39,1;23 }
 C$CC3A,1;23 A = *HL;
; Wearing the uniform stops anyone but the commandant from following the hero.
 C$CC3B,1;23 {if (A != character_0_COMMANDANT && *$8015 == sprite_guard) return;
 C$CC3C,9;23
 C$CC45,1;23 }
; Which is the case here?
; .
; - Don't follow mad people, or
; .
; - Don't follow the hero when bribe has been used
*C$CC46,1;23 {if (HL[1] == vischar_FLAGS_SAW_BRIBE) return; // $8041 etc. // 'gone mad' flag
 C$CC47,3;23
 C$CC4A,1;23 }
 C$CC4B,1
 C$CC4C,1;23 {HL += 15;
 C$CC4D,2;23
 C$CC4F,1;23 }
 C$CC50,3;23 DE = &tinypos_stash_x;
 C$CC53,3;23 {if (room_index == room_0_OUTDOORS) <%
 C$CC56,1;23
 C$CC57,3;23 }
 C$CC5A,3;23 pos_to_tinypos(HL,DE);
 C$CC5D,3;23 HL = &hero_map_position.x;
 C$CC60,3;23 DE = &tinypos_stash_x;
 C$CC63,3;23 A = IY[0x0E]; // ?
 C$CC66,1;23 carry = A & 1; A >>= 1;
 C$CC67,1;23 C = A;
 C$CC68,2;23 if (!carry) <% /* TL or BR */
; Range check.
 C$CC6A,1;23 HL++;
 C$CC6B,1;23 DE++;
 C$CC6C,1;23 {    A = *DE - 1;
 C$CC6D,1;23 }
 C$CC6E,1;23 {    if (A >= *HL || A + 2 < *HL) return; // *DE - 1 .. *DE + 1
 C$CC6F,4;23
 C$CC73,1;23 }
 C$CC74,1;23 HL--;
 C$CC75,1;23 DE--;
 C$CC76,1;23 A = *DE;
 C$CC77,1;23 CP *HL  // TRICKY!
 C$CC78,2;23 {    BIT 0,C // if ((C & (1<<0)) == 0) carry = !carry; /* TL (can't be TR) */
 C$CC7A,2;23
 C$CC7C,1;23 }
*C$CC7D,1;23 RET C   // This is odd: CCF then RET C? // will need to fall into 'else' clause
 C$CC7E,2;23 %>
; Range check.
*C$CC80,1;23 {  else <% A = *DE - 1;
 C$CC81,1;23 }
 C$CC82,1;23 {    if (A >= *HL || A + 2 < *HL) return; // *DE - 1 .. *DE + 1
 C$CC83,4;23
 C$CC87,1;23 }
 C$CC88,1;23 HL++;
 C$CC89,1;23 DE++;
 C$CC8A,1;23 A = *DE;
 C$CC8B,1;23 CP *HL  // TRICKY!
 C$CC8C,2;23 {    BIT 0,C // if ((C & (1<<0)) == 0) carry = !carry; /* TL or TR */
 C$CC8E,2;23
 C$CC90,1;23 }
*C$CC91,1;23 RET C %> %>
*C$CC92,3;23 {if (!red_flag) <%
 C$CC95,1;23
 C$CC96,2;23 }
 C$CC98,3;23 A = IY[0x13]; // sampled IY=$8020 // saw this breakpoint hit when outdoors
 C$CC9B,2;23 {  if (A < 32) // height
 C$CC9D,1;23 }
 C$CC9E,4;23 IY[1] = vischar_FLAGS_HASSLE;
 C$CCA2,1;23 return; %>
*C$CCA3,1;23 {bell = bell_RING_PERPETUAL;
 C$CCA4,3;23 }
 C$CCA7,3;23 hostiles_pursue();
 C$CCAA,1;23 return;

; Guards pursue prisoners.
;
; Used by the routines at #R$C892, #R$CC37, #R$CCCD and #R$EF9A.
; .
; For all visible, hostile characters, at height < 32, set the bribed/pursue
; flag.
; .
; Research: If I nop this out then guards don't spot the items I drop.
@label=hostiles_pursue
@nowarn
cC$CCAB,3;21 {HL = $8020; // iterate over non-player characters
 C$CCAE,3;21 }
 C$CCB1,2;21 B = 7; // iterations
*C$CCB3,1;21 do <%
; HL[0x13] is the character's height, testing this excludes the guards in the
; towers.
 C$CCB4,1;21 {  if (HL[0] <= character_19_GUARD_DOG_4 && HL[0x13] < 32) HL[1] = vischar_FLAGS_PURSUE;
 C$CCB5,19;21
*C$CCC8,1;21 }
 C$CCC9,1;21 HL += 32; // stride
 C$CCCA,2;21 %> while (--B);
 C$CCCC,1;21 return;

; Is item discoverable?
;
; Used by the routine at #R$C892.
; .
; Searches item_structs for items dropped nearby. If items are found the
; hostiles are made to pursue the hero.
; .
; Green key and food items are ignored.
@label=is_item_discoverable
cC$CCCD,3;21 A = room_index;
 C$CCD0,1;21 {if (A != room_0_OUTDOORS) <%
 C$CCD1,2;21 }
; Interior.
 C$CCD3,3;21 is_item_discoverable_interior(A);
 C$CCD6,1;21 {  if (Z) hostiles_pursue(); /* Item found */
 C$CCD7,3;21 }
 C$CCDA,1;21 return; %>
; Exterior.
*C$CCDB,3;21 else <% HL = &item_structs[0].room;
 C$CCDE,3
 C$CCE1,2;21 B = 16; // iterations == n.itemstructs
*C$CCE3,2;21 {  do <% if (HL[0] & itemstruct_ROOM_FLAG_NEARBY_7) goto nearby;
 C$CCE5,2;21 }
*C$CCE7,1;21 next: HL += 7; // stride
 C$CCE8,2;21 %> while (--B);
 C$CCEA,1;21 return; %>
; Suspected bug: HL is decremented, but not re-incremented before 'goto next'.
; So it must be reading a byte early when iteration is resumed. Consequences? I
; think it'll screw up when multiple items are in range.
*C$CCEB,1;21 nearby: HL--;
 C$CCEC,1;21 {A = *HL & itemstruct_ITEM_MASK; // sampled HL=$772A (&item_structs[item_PURSE].item)
 C$CCED,2;21 }
@rfix+begin
       INC HL        ; potentially a bug fix but needs thinking about
@rfix+end
; The green key and food items are ignored.
 C$CCEF,2;21 {if (A == item_GREEN_KEY || A == item_FOOD) goto next;
 C$CCF1,4;21
 C$CCF5,2;21 }
 C$CCF7,3;21 hostiles_pursue();
 C$CCFA,1;21 return;

; Is an item discoverable indoors?
;
; Used by the routines at #R$C6A0 and #R$CCCD.
; .
; A discoverable item is one moved away from its default room, and one that
; isn't the red cross parcel.
;
; I:A     Room ref.
; O:Flags Z => found, NZ => not found.
; O:C     Item (if found).
@label=is_item_discoverable_interior
cC$CCFB,1;21 C = A; // room ref
 C$CCFC,3;21 HL = &item_structs[0].room; // pointer to room ref
 C$CCFF,2;21 B = 16; // item__LIMIT
*C$CD01,1;21 {do <% A = *HL & itemstruct_ROOM_MASK;
 C$CD02,2;21 }
; Is the item in the specified room?
 C$CD04,1;21 {  if (A == C) <% // yes
 C$CD05,2;21 }
 C$CD07,1
; Has the item been moved to a different room?
; .
; Bug? Note that room_and_flags doesn't get its flags masked off. Does it need
; & 0x3F ? (DOS version has it)
 C$CD08,1;21 {    A = default_item_locations[HL[-1] & itemstruct_ITEM_MASK].room_and_flags; // HL[-1] = itemstruct.item
 C$CD09,13;21
 C$CD16,1;21 }
 C$CD17,1;21 {    if (A != C) goto not_in_default_room;
 C$CD18,2;21 }
 C$CD1A,1;21 - %>
*C$CD1B,3;21 {  next: HL += 7; // stride
 C$CD1E,1;21 }
 C$CD1F,2;21 %> while (--B);
 C$CD21,1;21 return; // return with NZ set (not found)
*C$CD22,1;21 not_in_default_room:
 C$CD23,1;21 {A = HL[-1] & itemstruct_ITEM_MASK; // itemstruct.item
 C$CD24,1;21
 C$CD25,2;21 }
; Ignore red cross parcel.
 C$CD27,2;21 {if (A == item_RED_CROSS_PARCEL) <%
 C$CD29,2;21 }
 C$CD2B,1
 C$CD2C,2;21 goto next; %>
*C$CD2E,1;21 C = A;
 C$CD2F,1;21 A = 0; // set Z (found)
 C$CD30,1;21 return;

; Item discovered.
;
; Used by the routines at #R$B75A, #R$C6A0, #R$C892 and #R$CB98.
;
; I:C Item.
@label=item_discovered
cC$CD31,1;21 A = C;
 C$CD32,2;21 {if (A == item_NONE) return;
 C$CD34,1;21 }
 C$CD35,2;21 A &= itemstruct_ITEM_MASK;
 C$CD37,1
 C$CD38,2;21 {queue_message(message_ITEM_DISCOVERED);
 C$CD3A,3;21 }
 C$CD3D,2;21 {decrease_morale(5);
 C$CD3F,3;21 }
 C$CD42,1
 C$CD43,1;21 {HL = &default_item_locations[A];
 C$CD44,7;21
 C$CD4B,1;21 }
 C$CD4C,1;21 A = HL->room_and_flags;
 C$CD4D,1;21 bank ptr
 C$CD4E,1;21 bank A
; Bug: C is not masked, so could go out of range.
 C$CD4F,1;21 Adash = C;
 C$CD50,3;21 HL = item_to_itemstruct(Adash);
 C$CD53,2;21 *HL &= ~itemstruct_ITEM_FLAG_HELD;
 C$CD55,1
 C$CD56,1;21 DE++;
 C$CD57,3;21 {memcpy(DE, HL, 3); DE += 3; HL += 3; // reset location?
 C$CD5A,2;21 }
 C$CD5C,2
 C$CD5E,1;21 {if (A == room_0_OUTDOORS) <%
 C$CD5F,2;21 }
 C$CD61,1;21 *HL = A; // A is already zero
 C$CD62,3;21 goto calc_exterior_item_iso_pos;
*C$CD65,2;21 else <% *HL = 5;
 C$CD67,3;21 goto calc_interior_item_iso_pos;

; Default item locations.
;
; Array of 16 three-byte structures.
; .
; struct default_item_location { byte room_and_flags; byte x; byte y; };
; .
; #define ITEM_ROOM(room_no, flags) ((room_no & 0x3F) | (flags << 6))
@label=default_item_locations
; do the next flags mean that the wiresnips are always or /never/ found?
bB$CD6A,3;24 item_WIRESNIPS        { ITEM_ROOM(room_NONE, 3),       ... }
 B$CD6D,3;24 item_SHOVEL           { ITEM_ROOM(room_9, 0),          ... }
 B$CD70,3;24 item_LOCKPICK         { ITEM_ROOM(room_10, 0),         ... }
 B$CD73,3;24 item_PAPERS           { ITEM_ROOM(room_11, 0),         ... }
 B$CD76,3;24 item_TORCH            { ITEM_ROOM(room_14, 0),         ... }
 B$CD79,3;24 item_BRIBE            { ITEM_ROOM(room_NONE, 0),       ... }
 B$CD7C,3;24 item_UNIFORM          { ITEM_ROOM(room_15, 0),         ... }
 B$CD7F,3;24 item_FOOD             { ITEM_ROOM(room_19, 0),         ... }
 B$CD82,3;24 item_POISON           { ITEM_ROOM(room_1, 0),          ... }
 B$CD85,3;24 item_RED_KEY          { ITEM_ROOM(room_22, 0),         ... }
 B$CD88,3;24 item_YELLOW_KEY       { ITEM_ROOM(room_11, 0),         ... }
 B$CD8B,3;24 item_GREEN_KEY        { ITEM_ROOM(room_0_OUTDOORS, 0), ... }
 B$CD8E,3;24 item_RED_CROSS_PARCEL { ITEM_ROOM(room_NONE, 0),       ... }
 B$CD91,3;24 item_RADIO            { ITEM_ROOM(room_18, 0),         ... }
 B$CD94,3;24 item_PURSE            { ITEM_ROOM(room_NONE, 0),       ... }
 B$CD97,3;24 item_COMPASS          { ITEM_ROOM(room_NONE, 0),       ... }

; Data for the four classes of characters.
; (<- spawn_character)
@label=character_meta_data_commandant
wW$CD9A,2;18 &animations[0]
 W$CD9C,2;18 sprite_commandant
@label=character_meta_data_guard
 W$CD9E,2;18 &animations[0]
 W$CDA0,2;18 sprite_guard
@label=character_meta_data_dog
 W$CDA2,2;18 &animations[0]
 W$CDA4,2;18 sprite_dog
@label=character_meta_data_prisoner
 W$CDA6,2;18 &animations[0]
 W$CDA8,2;18 sprite_prisoner

; Indices into animations.
;
; none, up, down, left, up+left, down+left, right, up+right, down+right, fire
; .
; Groups of nine. (<- animate)
@label=animindices
bB$CDAA,9;48 TL
 B$CDB3,9;48 TR
 B$CDBC,9;48 BR
 B$CDC5,9;48 BL
 B$CDCE,9;48 TL + crawl
 B$CDD7,9;48 TR + crawl
 B$CDE0,9;48 BR + crawl
 B$CDE9,9;48 BL + crawl

; Animation states.
;
; Array, 24 long, of pointers to data.
@label=animations
wW$CDF2,2;18 anim_walk_tl
 W$CDF4,2;18 anim_walk_tr
 W$CDF6,2;18 anim_walk_br
 W$CDF8,2;18 anim_walk_bl
 W$CDFA,2;18 anim_turn_tl
 W$CDFC,2;18 anim_turn_tr
 W$CDFE,2;18 anim_turn_br
 W$CE00,2;18 anim_turn_bl
 W$CE02,2;18 anim_wait_tl
 W$CE04,2;18 anim_wait_tr
 W$CE06,2;18 anim_wait_br
 W$CE08,2;18 anim_wait_bl
 W$CE0A,2;18 anim_crawl_tl
 W$CE0C,2;18 anim_crawl_tr
 W$CE0E,2;18 anim_crawl_br
 W$CE10,2;18 anim_crawl_bl
 W$CE12,2;18 anim_crawlturn_tl
 W$CE14,2;18 anim_crawlturn_tr
 W$CE16,2;18 anim_crawlturn_br
 W$CE18,2;18 anim_crawlturn_bl
 W$CE1A,2;18 anim_crawlwait_tl
 W$CE1C,2;18 anim_crawlwait_tr
 W$CE1E,2;18 anim_crawlwait_br
 W$CE20,2;18 anim_crawlwait_bl

; Sprites: objects which can move.
;
; This include STOVE, CRATE, PRISONER, CRAWL, DOG, GUARD and COMMANDANT.
; .
; Structure: (b) width in bytes + 1, (b) height in rows, (w) data ptr, (w) mask
; ptr
; .
; 'tl' => character faces top left of the screen
; .
; 'br' => character faces bottom right of the screen
@label=sprites
@label=sprite_stove
bB$CE22,6;36 { 3, 22, &bitmap_stove, &mask_stove } // (16x22,$DB46,$DB72)
@label=sprite_crate
 B$CE28,6;36 { 4, 24, &bitmap_crate, &mask_crate } // (24x24,$DAB6,$DAFE)
;
@label=sprite_prisoner
; Glitch: All of the prisoner sprites are one row too high.
 B$CE2E,6;36 { 3, 27, &bitmap_prisoner_facing_top_left_1, &mask_various_facing_top_left_1 } // (16x27,$D28C,$D545)
 B$CE34,6;36 { 3, 28, &bitmap_prisoner_facing_top_left_2, &mask_various_facing_top_left_2 } // (16x28,$D256,$D505)
 B$CE3A,6;36 { 3, 28, &bitmap_prisoner_facing_top_left_3, &mask_various_facing_top_left_3 } // (16x28,$D220,$D4C5)
 B$CE40,6;36 { 3, 28, &bitmap_prisoner_facing_top_left_4, &mask_various_facing_top_left_4 } // (16x28,$D1EA,$D485)
 B$CE46,6;36 { 3, 27, &bitmap_prisoner_facing_bottom_right_1, &mask_various_facing_bottom_right_1 } // (16x27,$D2C0,$D585)
 B$CE4C,6;36 { 3, 29, &bitmap_prisoner_facing_bottom_right_2, &mask_various_facing_bottom_right_2 } // (16x29,$D2F4,$D5C5)
 B$CE52,6;36 { 3, 28, &bitmap_prisoner_facing_bottom_right_3, &mask_various_facing_bottom_right_3 } // (16x28,$D32C,$D605)
 B$CE58,6;36 { 3, 28, &bitmap_prisoner_facing_bottom_right_4, &mask_various_facing_bottom_right_4 } // (16x28,$D362,$D63D)
;
 B$CE5E,6;36 { 4, 16, &bitmap_crawl_facing_bottom_left_1, &mask_crawl_facing_bottom_left } // (24x16,$D3C5,$D677)
 B$CE64,6;36 { 4, 15, &bitmap_crawl_facing_bottom_left_2, &mask_crawl_facing_bottom_left } // (24x15,$D398,$D677)
 B$CE6A,6;36 { 4, 16, &bitmap_crawl_facing_top_left_1, &mask_crawl_facing_top_left } // (24x16,$D3F5,$D455)
 B$CE70,6;36 { 4, 16, &bitmap_crawl_facing_top_left_2, &mask_crawl_facing_top_left } // (24x16,$D425,$D455)
;
@label=sprite_dog
 B$CE76,6;36 { 4, 16, &bitmap_dog_facing_top_left_1, &mask_dog_facing_top_left } // (24x16,$D867,$D921)
 B$CE7C,6;36 { 4, 16, &bitmap_dog_facing_top_left_2, &mask_dog_facing_top_left } // (24x16,$D897,$D921)
 B$CE82,6;36 { 4, 15, &bitmap_dog_facing_top_left_3, &mask_dog_facing_top_left } // (24x15,$D8C7,$D921)
 B$CE88,6;36 { 4, 15, &bitmap_dog_facing_top_left_4, &mask_dog_facing_top_left } // (24x15,$D8F4,$D921)
 B$CE8E,6;36 { 4, 14, &bitmap_dog_facing_bottom_right_1, &mask_dog_facing_bottom_right } // (24x14,$D951,$D9F9)
 B$CE94,6;36 { 4, 15, &bitmap_dog_facing_bottom_right_2, &mask_dog_facing_bottom_right } // (24x15,$D97B,$D9F9)
; Glitch: The height of following sprite is two rows too high.
 B$CE9A,6;36 { 4, 15, &bitmap_dog_facing_bottom_right_3, &mask_dog_facing_bottom_right } // (24x15,$D9A8,$D9F9)
 B$CEA0,6;36 { 4, 14, &bitmap_dog_facing_bottom_right_4, &mask_dog_facing_bottom_right } // (24x14,$D9CF,$D9F9)
;
@label=sprite_guard
 B$CEA6,6;36 { 3, 27, &bitmap_guard_facing_top_left_1, &mask_various_facing_top_left_1 } // (16x27,$D74D,$D545)
 B$CEAC,6;36 { 3, 29, &bitmap_guard_facing_top_left_2, &mask_various_facing_top_left_2 } // (16x29,$D713,$D505)
 B$CEB2,6;36 { 3, 27, &bitmap_guard_facing_top_left_3, &mask_various_facing_top_left_3 } // (16x27,$D6DD,$D4C5)
 B$CEB8,6;36 { 3, 27, &bitmap_guard_facing_top_left_4, &mask_various_facing_top_left_4 } // (16x27,$D6A7,$D485)
 B$CEBE,6;36 { 3, 29, &bitmap_guard_facing_bottom_right_1, &mask_various_facing_bottom_right_1 } // (16x29,$D783,$D585)
 B$CEC4,6;36 { 3, 29, &bitmap_guard_facing_bottom_right_2, &mask_various_facing_bottom_right_2 } // (16x29,$D7BD,$D5C5)
 B$CECA,6;36 { 3, 28, &bitmap_guard_facing_bottom_right_3, &mask_various_facing_bottom_right_3 } // (16x28,$D7F7,$D605)
 B$CED0,6;36 { 3, 28, &bitmap_guard_facing_bottom_right_4, &mask_various_facing_bottom_right_4 } // (16x28,$D82F,$D63D)
;
@label=sprite_commandant
 B$CED6,6;36 { 3, 28, &bitmap_commandant_facing_top_left_1, &mask_various_facing_top_left_1 } // (16x28,$D0D6,$D545)
 B$CEDC,6;36 { 3, 30, &bitmap_commandant_facing_top_left_2, &mask_various_facing_top_left_2 } // (16x30,$D09A,$D505)
 B$CEE2,6;36 { 3, 29, &bitmap_commandant_facing_top_left_3, &mask_various_facing_top_left_3 } // (16x29,$D060,$D4C5)
 B$CEE8,6;36 { 3, 29, &bitmap_commandant_facing_top_left_4, &mask_various_facing_top_left_4 } // (16x29,$D026,$D485)
 B$CEEE,6;36 { 3, 27, &bitmap_commandant_facing_bottom_right_1, &mask_various_facing_bottom_right_1 } // (16x27,$D10E,$D585)
 B$CEF4,6;36 { 3, 28, &bitmap_commandant_facing_bottom_right_2, &mask_various_facing_bottom_right_2 } // (16x28,$D144,$D5C5)
 B$CEFA,6;36 { 3, 27, &bitmap_commandant_facing_bottom_right_3, &mask_various_facing_bottom_right_3 } // (16x27,$D17C,$D605)
 B$CF00,6;36 { 3, 28, &bitmap_commandant_facing_bottom_right_4, &mask_various_facing_bottom_right_4 } // (16x28,$D1B2,$D63D)

; Animations.
;
; Read by routine around $B64F (animate)
@label=anim_crawlwait_tl
bB$CF06,8
@label=anim_crawlwait_tr
 B$CF0E,8
@label=anim_crawlwait_br
 B$CF16,8
@label=anim_crawlwait_bl
 B$CF1E,8
;
@label=anim_walk_tl
 B$CF26,20
@label=anim_walk_tr
 B$CF3A,20
@label=anim_walk_br
 B$CF4E,20
@label=anim_walk_bl
 B$CF62,20
;
@label=anim_wait_tl
 B$CF76,8
@label=anim_wait_tr
 B$CF7E,8
@label=anim_wait_br
 B$CF86,8
@label=anim_wait_bl
 B$CF8E,8
;
@label=anim_turn_tl
 B$CF96,12
@label=anim_turn_tr
 B$CFA2,12
@label=anim_turn_br
 B$CFAE,12
@label=anim_turn_bl
 B$CFBA,12
;
@label=anim_crawl_tl
 B$CFC6,12
@label=anim_crawl_tr
 B$CFD2,12
@label=anim_crawl_br
 B$CFDE,12
@label=anim_crawl_bl
 B$CFEA,12
;
@label=anim_crawlturn_tl
 B$CFF6,12
@label=anim_crawlturn_tr
 B$D002,12
@label=anim_crawlturn_br
 B$D00E,12
@label=anim_crawlturn_bl
 B$D01A,12

; Sprite bitmaps and masks.
;
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D026-$D05F-1-16{0,0,64,116}(bitmap-commandant-facing-top-left-1)
; }
; TABLE#
@label=bitmap_commandant_facing_top_left_4
bB$D026,8;44 {bitmap: COMMANDANT FACING TOP LEFT 4
 B$D02E,8*6
 B$D05E,2;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D060-$D099-1-16{0,0,64,116}(bitmap-commandant-facing-top-left-2)
; }
; TABLE#
@label=bitmap_commandant_facing_top_left_3
 B$D060,8;44 {bitmap: COMMANDANT FACING TOP LEFT 3
 B$D068,8*6
 B$D098,2;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D09A-$D0D5-1-16{0,0,64,120}(bitmap-commandant-facing-top-left-3)
; }
; TABLE#
@label=bitmap_commandant_facing_top_left_2
 B$D09A,8;44 {bitmap: COMMANDANT FACING TOP LEFT 2
 B$D0A2,8*6
 B$D0D2,4;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D0D6-$D10E-1-16{0,0,64,112}(bitmap-commandant-facing-top-left-4)
; }
; TABLE#
@label=bitmap_commandant_facing_top_left_1
 B$D0D6,8;44 {bitmap: COMMANDANT FACING TOP LEFT 1
 B$D0DE,8*5
 B$D106,8;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D10E-$D143-1-16{0,0,64,108}(bitmap-commandant-facing-bottom-right-1)
; }
; TABLE#
@label=bitmap_commandant_facing_bottom_right_1
 B$D10E,8;44 {bitmap: COMMANDANT FACING BOTTOM RIGHT 1
 B$D116,8*5
 B$D13E,6;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D144-$D17B-1-16{0,0,64,112}(bitmap-commandant-facing-bottom-right-2)
; }
; TABLE#
@label=bitmap_commandant_facing_bottom_right_2
 B$D144,8;44 {bitmap: COMMANDANT FACING BOTTOM RIGHT 2
 B$D14C,8*5
 B$D174,8;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D17C-$D1B1-1-16{0,0,64,108}(bitmap-commandant-facing-bottom-right-3)
; }
; TABLE#
@label=bitmap_commandant_facing_bottom_right_3
 B$D17C,8;44 {bitmap: COMMANDANT FACING BOTTOM RIGHT 3
 B$D184,8*5
 B$D1AC,6;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D1B2-$D1E9-1-16{0,0,64,112}(bitmap-commandant-facing-bottom-right-4)
; }
; TABLE#
@label=bitmap_commandant_facing_bottom_right_4
 B$D1B2,8;44 {bitmap: COMMANDANT FACING BOTTOM RIGHT 4
 B$D1BA,8*5
 B$D1E2,8;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D1EA-$D21F-1-16{0,0,64,108}(bitmap-prisoner-facing-top-left-1)
; }
; TABLE#
@label=bitmap_prisoner_facing_top_left_4
 B$D1EA,8;44 {bitmap: PRISONER FACING TOP LEFT 4
 B$D1F2,8*5
 B$D21A,6;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D220-$D255-1-16{0,0,64,108}(bitmap-prisoner-facing-top-left-2)
; }
; TABLE#
@label=bitmap_prisoner_facing_top_left_3
 B$D220,8;44 {bitmap: PRISONER FACING TOP LEFT 3
 B$D228,8*5
 B$D250,6;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D256-$D28B-1-16{0,0,64,108}(bitmap-prisoner-facing-top-left-3)
; }
; TABLE#
@label=bitmap_prisoner_facing_top_left_2
 B$D256,8;44 {bitmap: PRISONER FACING TOP LEFT 2
 B$D25E,8*5
 B$D286,6;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D28C-$D2BF-1-16{0,0,64,104}(bitmap-prisoner-facing-top-left-4)
; }
; TABLE#
@label=bitmap_prisoner_facing_top_left_1
 B$D28C,8;44 {bitmap: PRISONER FACING TOP LEFT 1
 B$D294,8*5
 B$D2BC,4;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D2C0-$D2F3-1-16{0,0,64,104}(bitmap-prisoner-facing-bottom-right-1)
; }
; TABLE#
@label=bitmap_prisoner_facing_bottom_right_1
 B$D2C0,8;44 {bitmap: PRISONER FACING BOTTOM RIGHT 1
 B$D2C8,8*5
 B$D2F0,4;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D2F4-$D32B-1-16{0,0,64,112}(bitmap-prisoner-facing-bottom-right-2)
; }
; TABLE#
@label=bitmap_prisoner_facing_bottom_right_2
 B$D2F4,8;44 {bitmap: PRISONER FACING BOTTOM RIGHT 2
 B$D2FC,8*5
 B$D324,8;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D32C-$D361-1-16{0,0,64,108}(bitmap-prisoner-facing-bottom-right-3)
; }
; TABLE#
@label=bitmap_prisoner_facing_bottom_right_3
 B$D32C,8;44 {bitmap: PRISONER FACING BOTTOM RIGHT 3
 B$D334,8*5
 B$D35C,6;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D362-$D397-1-16{0,0,64,108}(bitmap-prisoner-facing-bottom-right-4)
; }
; TABLE#
@label=bitmap_prisoner_facing_bottom_right_4
 B$D362,8;44 {bitmap: PRISONER FACING BOTTOM RIGHT 4
 B$D36A,8*5
 B$D392,6;44 }
; #UDGTABLE
; {
; #UDGARRAY3,7,4,3;$D398-$D3C4-1-24{0,0,96,60}(bitmap-crawl-facing-bottom-right-1)
; }
; TABLE#
@label=bitmap_crawl_facing_bottom_left_2
 B$D398,8;44 {bitmap: CRAWL FACING BOTTOM RIGHT 2
 B$D3A0,8*4
 B$D3C0,5;44 }
; #UDGTABLE
; {
; #UDGARRAY3,7,4,3;$D3C5-$D3F4-1-24{0,0,96,64}(bitmap-crawl-facing-bottom-right-2)
; }
; TABLE#
@label=bitmap_crawl_facing_bottom_left_1
 B$D3C5,8;44 {bitmap: CRAWL FACING BOTTOM RIGHT 1
 B$D3CD,8*4
 B$D3ED,8;44 }
; #UDGTABLE
; {
; #UDGARRAY3,7,4,3;$D3F5-$D424-1-24{0,0,96,64}(bitmap-crawl-facing-top-left-1)
; }
; TABLE#
@label=bitmap_crawl_facing_top_left_1
 B$D3F5,8;44 {bitmap: CRAWL FACING TOP LEFT 1
 B$D3FD,8*4
 B$D41D,8;44 }
; #UDGTABLE
; {
; #UDGARRAY3,7,4,3;$D425-$D454-1-24{0,0,96,64}(bitmap-crawl-facing-top-left-2)
; }
; TABLE#
@label=bitmap_crawl_facing_top_left_2
 B$D425,8;44 {bitmap: CRAWL FACING TOP LEFT 2
 B$D42D,8*4
 B$D44D,8;44 }
; #UDGTABLE
; { #UDGARRAY3,7,4,3;$D455-$D484-1-24{0,0,96,64}(mask-crawl-facing-top-left) }
; TABLE#
@label=mask_crawl_facing_top_left
 B$D455,8;44 {mask: CRAWL FACING TOP LEFT (shared)
 B$D45D,8*4
 B$D47D,8;44 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$D485-$D4C4-1-16(mask-various-facing-top-left-1) }
; TABLE#
@label=mask_various_facing_top_left_4
 B$D485,8;44 {mask: VARIOUS FACING TOP LEFT 4
 B$D48D,8*6
 B$D4BD,8;44 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$D4C5-$D504-1-16(mask-various-facing-top-left-2) }
; TABLE#
@label=mask_various_facing_top_left_3
 B$D4C5,8;44 {mask: VARIOUS FACING TOP LEFT 3
 B$D4CD,8*6
 B$D4FD,8;44 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$D505-$D544-1-16(mask-various-facing-top-left-3) }
; TABLE#
@label=mask_various_facing_top_left_2
 B$D505,8;44 {mask: VARIOUS FACING TOP LEFT 2
 B$D50D,8*6
 B$D53D,8;44 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$D545-$D584-1-16(mask-various-facing-top-left-4) }
; TABLE#
@label=mask_various_facing_top_left_1
 B$D545,8;44 {mask: VARIOUS FACING TOP LEFT 1
 B$D54D,8*6
 B$D57D,8;44 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$D585-$D5C4-1-16(mask-various-facing-bottom-right-1) }
; TABLE#
@label=mask_various_facing_bottom_right_1
 B$D585,8;44 {mask: VARIOUS FACING BOTTOM RIGHT 1
 B$D58D,8*6
 B$D5BD,8;44 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$D5C5-$D604-1-16(mask-various-facing-bottom-right-2) }
; TABLE#
@label=mask_various_facing_bottom_right_2
 B$D5C5,8;44 {mask: VARIOUS FACING BOTTOM RIGHT 2
 B$D5CD,8*6
 B$D5FD,8;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D605-$D63C-1-16{0,0,64,112}(mask-various-facing-bottom-right-3)
; }
; TABLE#
@label=mask_various_facing_bottom_right_3
 B$D605,8;44 {mask: VARIOUS FACING BOTTOM RIGHT 3
 B$D60D,8*5
 B$D635,8;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D63D-$D676-1-16{0,0,64,116}(mask-various-facing-bottom-right-4)
; }
; TABLE#
@label=mask_various_facing_bottom_right_4
 B$D63D,8;44 {mask: VARIOUS FACING BOTTOM RIGHT 4
 B$D645,8*6
 B$D675,2;44 }
; #UDGTABLE
; { #UDGARRAY3,7,4,3;$D677-$D6A6-1-24(mask-crawl-facing-bottom-left) }
; TABLE#
@label=mask_crawl_facing_bottom_left
 B$D677,8;44 {mask: CRAWL FACING BOTTOM RIGHT (shared)
 B$D67F,8*4
 B$D69F,8;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D6A7-$D6DC-1-16{0,0,64,108}(bitmap-guard-facing-top-left-1)
; }
; TABLE#
@label=bitmap_guard_facing_top_left_4
 B$D6A7,8;44 {bitmap: GUARD FACING TOP LEFT 4
 B$D6AF,8*5
 B$D6D7,6;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D6DD-$D712-1-16{0,0,64,108}(bitmap-guard-facing-top-left-2)
; }
; TABLE#
@label=bitmap_guard_facing_top_left_3
 B$D6DD,8;44 {bitmap: GUARD FACING TOP LEFT 3
 B$D6E5,8*5
 B$D70D,6;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D713-$D74C-1-16{0,0,64,116}(bitmap-guard-facing-top-left-3)
; }
; TABLE#
@label=bitmap_guard_facing_top_left_2
 B$D713,8;44 {bitmap: GUARD FACING TOP LEFT 2
 B$D71B,8*6
 B$D74B,2;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D74D-$D782-1-16{0,0,64,108}(bitmap-guard-facing-top-left-4)
; }
; TABLE#
@label=bitmap_guard_facing_top_left_1
 B$D74D,8;44 {bitmap: GUARD FACING TOP LEFT 1
 B$D755,8*5
 B$D77D,6;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D783-$D7BC-1-16{0,0,64,116}(bitmap-guard-facing-bottom-right-1)
; }
; TABLE#
@label=bitmap_guard_facing_bottom_right_1
 B$D783,8;44 {bitmap: GUARD FACING BOTTOM RIGHT 1
 B$D78B,8*6
 B$D7BB,2;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D7BD-$D7F6-1-16{0,0,64,116}(bitmap-guard-facing-bottom-right-2)
; }
; TABLE#
@label=bitmap_guard_facing_bottom_right_2
 B$D7BD,8;44 {bitmap: GUARD FACING BOTTOM RIGHT 2
 B$D7C5,8*6
 B$D7F5,2;44 }
; #UDGTABLE
; {
; #UDGARRAY2,7,4,2;$D7F7-$D82E-1-16{0,0,64,112}(bitmap-guard-facing-bottom-right-3)
; }
; TABLE#
@label=bitmap_guard_facing_bottom_right_3
 B$D7F7,8;44 {bitmap: GUARD FACING BOTTOM RIGHT 3
 B$D7FF,8*5
 B$D827,8;44 }
; #UDGTABLE
; {
; #UDGARRAY1,7,4,2;$D82F-$D866-1-16{0,0,64,112}(bitmap-guard-facing-bottom-right-4)
; }
; TABLE#
@label=bitmap_guard_facing_bottom_right_4
 B$D82F,8;44 {bitmap: GUARD FACING BOTTOM RIGHT 4
 B$D837,8*5
 B$D85F,8;44 }
; #UDGTABLE
; { #UDGARRAY3,7,4,3;$D867-$D896-1-24{0,0,96,64}(bitmap-dog-facing-top-left-1)
; }
; TABLE#
@label=bitmap_dog_facing_top_left_1
 B$D867,8;44 {bitmap: DOG FACING TOP LEFT 1
 B$D86F,8*4
 B$D88F,8;44 }
; #UDGTABLE
; { #UDGARRAY3,7,4,3;$D897-$D8C6-1-24{0,0,96,64}(bitmap-dog-facing-top-left-2)
; }
; TABLE#
@label=bitmap_dog_facing_top_left_2
 B$D897,8;44 {bitmap: DOG FACING TOP LEFT 2
 B$D89F,8*4
 B$D8BF,8;44 }
; #UDGTABLE
; { #UDGARRAY3,7,4,3;$D8C7-$D8F3-1-24{0,0,96,60}(bitmap-dog-facing-top-left-3)
; }
; TABLE#
@label=bitmap_dog_facing_top_left_3
 B$D8C7,8;44 {bitmap: DOG FACING TOP LEFT 3
 B$D8CF,8*4
 B$D8EF,5;44 }
; #UDGTABLE
; { #UDGARRAY3,7,4,3;$D8F4-$D920-1-24{0,0,96,60}(bitmap-dog-facing-top-left-4)
; }
; TABLE#
@label=bitmap_dog_facing_top_left_4
 B$D8F4,8;44 {bitmap: DOG FACING TOP LEFT 4
 B$D8FC,8*4
 B$D91C,5;44 }
; #UDGTABLE
; { #UDGARRAY3,7,4,3;$D921-$D950-1-24(mask-dog-facing-top-left) }
; TABLE#
@label=mask_dog_facing_top_left
 B$D921,8;44 {mask: DOG FACING TOP LEFT (shared)
 B$D929,8*4
 B$D949,8;44 }
; #UDGTABLE
; {
; #UDGARRAY3,7,4,3;$D951-$D97A-1-24{0,0,96,56}(bitmap-dog-facing-bottom-right-1)
; }
; TABLE#
@label=bitmap_dog_facing_bottom_right_1
 B$D951,8;44 {bitmap: DOG FACING BOTTOM RIGHT 1
 B$D959,8*4
 B$D979,2;44 }
; #UDGTABLE
; {
; #UDGARRAY3,7,4,3;$D97B-$D9A7-1-24{0,0,96,60}(bitmap-dog-facing-bottom-right-2)
; }
; TABLE#
@label=bitmap_dog_facing_bottom_right_2
 B$D97B,8;44 {bitmap: DOG FACING BOTTOM RIGHT 2
 B$D983,8*4
 B$D9A3,5;44 }
; #UDGTABLE
; {
; #UDGARRAY3,7,4,3;$D9A8-$D9CE-1-24{0,0,96,60}(bitmap-dog-facing-bottom-right-3)
; }
; TABLE#
@label=bitmap_dog_facing_bottom_right_3
 B$D9A8,8;44 {bitmap: DOG FACING BOTTOM RIGHT 3
 B$D9B0,8*3
 B$D9C8,7;44 }
; #UDGTABLE
; {
; #UDGARRAY3,7,4,3;$D9CF-$D9F8-1-24{0,0,96,56}(bitmap-dog-facing-bottom-right-4)
; }
; TABLE#
@label=bitmap_dog_facing_bottom_right_4
 B$D9CF,8;44 {bitmap: DOG FACING BOTTOM RIGHT 4
 B$D9D7,8*4
 B$D9F7,2;44 }
; #UDGTABLE
; { #UDGARRAY3,7,4,3;$D9F9-$DA28-1-24(mask-dog-facing-bottom-right) }
; TABLE#
@label=mask_dog_facing_bottom_right
 B$D9F9,8;44 {mask: DOG FACING BOTTOM RIGHT (shared)
 B$DA01,8*4
 B$DA21,8;44 }
; #UDGTABLE
; { #UDGARRAY3,7,4,3;$DA29-$DA6A-1-24{0,0,96,96}(flag-up) }
; TABLE#
@label=bitmap_flag_up
 B$DA29,8;44 {bitmap: FLAG UP
 B$DA31,8*7
 B$DA69,2;44 }
; #UDGTABLE
; { #UDGARRAY3,7,4,3;$DA6B-$DAB5-1-24{0,0,96,96}(flag-down) }
; TABLE#
@label=bitmap_flag_down
 B$DA6B,8;44 {bitmap: FLAG DOWN
 B$DA73,8*8
 B$DAB3,3;44 }
; #UDGTABLE
; { #UDGARRAY3,7,4,3;$DAB6-$DAFD-1-24{0,0,96,96}(bitmap-crate) }
; TABLE#
@label=bitmap_crate
 B$DAB6,8;44 {bitmap: CRATE
 B$DABE,8*7
 B$DAF6,8;44 }
; #UDGTABLE
; { #UDGARRAY3,7,4,3;$DAFE-$DB45-1-24(mask-crate) }
; TABLE#
@label=mask_crate
 B$DAFE,8;44 {mask: CRATE
 B$DB06,8*7
 B$DB3E,8;44 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DB46-$DB71-1-16{0,0,64,88}(bitmap-stove) }
; TABLE#
@label=bitmap_stove
 B$DB46,8;44 {bitmap: STOVE
 B$DB4E,8*4
 B$DB6E,4;44 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DB72-$DB9D-1-16(mask-stove) }
; TABLE#
@label=mask_stove
 B$DB72,8;44 {mask: STOVE
 B$DB7A,8*4
 B$DB9A,4;44 }

; Mark nearby items.
;
; Used by the routines at #R$6939 and #R$9D7B.
; .
; Iterates over item structs, testing to see if each item is within range
; (-1..22, 0..15) of the map position.
; .
; This is similar to is_item_discoverable_interior in that it iterates over all
; item_structs.
@label=mark_nearby_items
cC$DB9E,3;21 A = room_index;
 C$DBA1,2;21 {if (A == room_NONE) A = 0;
 C$DBA3,2;21
 C$DBA5,1;21 }
*C$DBA6,1;21 C = A; // room ref
 C$DBA7,4;21 DE = map_position;
 C$DBAB,2;21 B = item__LIMIT;
 C$DBAD,3;21 HL = &item_structs[0].room;
*C$DBB0,1;21 do <%
 C$DBB1,1;21 {  if (HL[0] & itemstruct_ROOM_MASK == C) <% // compare room
 C$DBB2,3;21
 C$DBB5,2;21 }
 C$DBB7,1;21 {    if (HL[4] > E - 2 && HL[4] < E + 23) <% // itemstruct.screenpos.x
 C$DBB8,11;21
*C$DBC3,2;21
 C$DBC5,1;21
 C$DBC6,2;21 }
 C$DBC8,1;21 {      if (HL[5] > D - 1 && HL[5] < D + 16) <% // itemstruct.screenpos.y
 C$DBC9,7;21
*C$DBD0,2;21
 C$DBD2,1;21
 C$DBD3,2;21 }
 C$DBD5,1
 C$DBD6,2;21 {        *HL |= itemstruct_ROOM_FLAG_NEARBY_6 | itemstruct_ROOM_FLAG_NEARBY_7; // sampled HL=$772B &itemstruct_14.room
 C$DBD8,2;21 }
 C$DBDA,2;21 goto next; %> %> %>
; Reset.
*C$DBDC,1
 C$DBDD,2;21 {  *HL &= ~(itemstruct_ROOM_FLAG_NEARBY_6 | itemstruct_ROOM_FLAG_NEARBY_7);
 C$DBDF,2;21 }
*C$DBE1,2;21 {  next: HL += 7; // stride
 C$DBE3,4;21
 C$DBE7,1;21 }
*C$DBE8,2;21 %> while (--B);
 C$DBEA,1;21 return;

; Iterates over all item_structs looking for nearby items.
;
; Used by the routine at #R$B89C.
; .
; Returns the furthest/highest/nearest item?
; .
; Iterates over all items. Uses multiply_by_8.
;
; I:BC' samples = 0, $1A, $1C, $1E, $20, $22,
; I:DE' samples = 0, $22, $22, $22, $22, $22,
; O:IY Pointer to to item struct. (result?)
; O:A' result?
@label=get_greatest_itemstruct
cC$DBEB,3;21 B = item_LIMIT; // iterations
 C$DBEE,3;21 Outer_HL = &item_structs[0].room;
*C$DBF1,2;21 {do <% if ((*Outer_HL & (itemstruct_ROOM_FLAG_NEARBY_6 | itemstruct_ROOM_FLAG_NEARBY_7)) == (itemstruct_ROOM_FLAG_NEARBY_6 | itemstruct_ROOM_FLAG_NEARBY_7)) <%
 C$DBF3,4;21
 C$DBF7,2;21 }
 C$DBF9,1;21 HL = Outer_HL;
 C$DBFA,1
 C$DBFB,1;21 {  HLdash = *++HL * 8; // x position
 C$DBFC,1;21
 C$DBFD,3;21 }
 C$DC00,1;21
 C$DC01,1
 C$DC02,1;21
 C$DC03,1;21 A &= A; // Clear carry flag.
 C$DC04,2;21 HLdash -= BCdash; // itemstr->pos.x * 8 - x
 C$DC06,1
 C$DC07,2;21 {  if (HLdash > 0) <%
 C$DC09,2;21 }
 C$DC0B,1;21 HL++; // y position
 C$DC0C,1;21 {    HLdash = *HL * 8;
 C$DC0D,3;21 }
 C$DC10,2
 C$DC12,1;21 // not clearing carry?
 C$DC13,2;21 HLdash -= BCdash; // itemstr->pos.y * 8 - y
 C$DC15,1
 C$DC16,2;21 {    if (HLdash > 0) <%
 C$DC18,2;21 }
 C$DC1A,1;21 {      HLdash = HL;
 C$DC1B,1
 C$DC1C,1;21 }
; Get x,y for the next iteration.
 C$DC1D,1;21 {      DEdash = *HLdash-- * 8; // y position
 C$DC1E,5;21
 C$DC23,1;21 }
 C$DC24,1;21 {      BCdash = *HLdash-- * 8; // x position
 C$DC25,3;21 }
 C$DC28,1;21 {      HLdash--; // point to item
 C$DC29,1;21 }
 C$DC2A,1;21 {      IY = HLdash; // IY is not banked // sampled IY=$771C,7715 (pointing into item_structs)
 C$DC2B,2;21 }
 C$DC2D,1
 C$DC2E,1;21 - // fetch iter count
 C$DC2F,1
 C$DC30,2;21 {      A = (16 - B) | (1<<6); // item found flag
 C$DC32,1;21
 C$DC33,2;21 }
 C$DC35,1;21 %> %> // unpaired // returns the value in Adash
*C$DC36,1
 C$DC37,1
*C$DC38,1;21 {  %> Outer_HL += 7; // stride
 C$DC39,4;21
 C$DC3D,1;21 }
*C$DC3E,2;21 %> while (--B);
 C$DC40,1;21 return;

; Set up item plotting.
;
; Used by the routine at #R$B866.
;
; I:A  Item.
; I:IY Pointer to itemstruct. (samples = 0x771C, 0x76F9)
;
; 0x3F looks like it ought to be 0x1F (item__LIMIT - 1). Potential bug: The use
; of A later on does not re-clamp it to 0x1F.
@label=setup_item_plotting
cC$DC41,2;21 A &= 0x3F;
; Bug: This writes to saved_item but it's never subsequently read from.
 C$DC43,3;21 saved_item = A;
 C$DC46,2;21 {HL = IY + 2;
 C$DC48,2;21
 C$DC4A,1;21 }
 C$DC4B,3;21 DE = &tinypos_stash_x;
 C$DC4E,3;21 BC = 5;
 C$DC51,3
 C$DC54,1;21 *HL = B; // B == 0 due to LDIR /* Items are never drawn flipped. */
 C$DC55,3;21 {HL = &item_definitions[A];
 C$DC58,5;21
 C$DC5D,1;21 }
 C$DC5E,1;21 HL++; // &item_definitions[A].height
 C$DC5F,1;21 A = (HL);
 C$DC60,3;21 item_height = A;
 C$DC63,1;21 HL++;
 C$DC64,3;21 {memcpy(&bitmap_pointer, HL, 4); // copy bitmap and mask pointers
 C$DC67,3;21
 C$DC6A,2;21 }
 C$DC6C,3;21 item_visible();
 C$DC6F,1;21 if (!Z) return; /* invisible */
 C$DC70,1;21 // clipped width
 C$DC71,1;21 // clipped height
 C$DC72,1;21 A = E;
 C$DC73,3;21 ($E2C1 + 1) = A; // self modify masked_sprite_plotter_16_wide_left
 C$DC76,1;21 A = B;
 C$DC77,1;21 {if (A == 0) <%
 C$DC78,3;21 }
 C$DC7B,2;21 A = 0x77; // 0b01110111 /* opcode of 'LD (HL),A' */
 C$DC7D,1;21 {  Adash = C; %>
 C$DC7E,1;21 }
 C$DC7F,2;21 else <%
*C$DC81,1;21 A = 0; /* opcode of 'NOP' */
 C$DC82,1;21 {  Adash = 3 - C; %>
 C$DC83,2;21
 C$DC85,1;21 }
*C$DC86,1
 C$DC87,1;21 Cdash = Adash;
 C$DC88,1
 C$DC89,3;21 HLdash = &masked_sprite_plotter_16_enables[0];
 C$DC8C,2;21 Bdash = 3; // iterations
*C$DC8E,1;21 {do <% Edash = *HLdash++;
 C$DC8F,1;21 }
 C$DC90,1;21 Ddash = *HLdash;
 C$DC91,1;21 *DEdash = A;
 C$DC92,1;21 HLdash++;
 C$DC93,1;21 {  Edash = *HLdash++;
 C$DC94,1;21 }
 C$DC95,1;21 {  Ddash = *HLdash++;
 C$DC96,1;21 }
 C$DC97,1;21 *DEdash = A;
 C$DC98,1;21 {  if (--Cdash == 0) A ^= 0x77; /* Toggle between LD (HL),A and NOP. */
 C$DC99,2;21
 C$DC9B,2;21 }
*C$DC9D,2;21 %> while (--Bdash);
 C$DC9F,1
 C$DCA0,1;21 A = D;
 C$DCA1,1;21 A &= A;
 C$DCA2,3;21 DE = 0;
 C$DCA5,2;21 if (Z) <%
 C$DCA7,3;21 HL = $81BC; // &map_position + 1;
 C$DCAA,3;21 {  A = ($81B6) - *HL;
 C$DCAD,1;21 }
 C$DCAE,1;21 {  HL = A * 192;
 C$DCAF,11;21
 C$DCBA,1;21 }
 C$DCBB,1;21 %>
*C$DCBC,3;21 A = iso_pos_x;
 C$DCBF,3;21 HL = $81BB; // &map_position;
 C$DCC2,1;21 A -= *HL; // x
 C$DCC3,1;21 {HL = A;
 C$DCC4,2;21 }
 C$DCC6,2;21 {if (carry) H = 0xFF;
 C$DCC8,2;21 }
*C$DCCA,1;21 HL += DE;
 C$DCCB,3;21 DE = $F290; // screen buffer start address
 C$DCCE,1;21 HL += DE;
@nowarn
 C$DCCF,3;21 ($81A2) = HL;  // screen buffer pointer
@nowarn
 C$DCD2,3;21 HL = mask_buffer;
 C$DCD5,2
 C$DCD7,1;21 {L += D * 4;
 C$DCD8,3;21
 C$DCDB,1;21 }
 C$DCDC,3;21 ($81B0) = HL;
 C$DCDF,2
 C$DCE1,1;21 A = D;
 C$DCE2,1;21 {if (A) <%
 C$DCE3,2;21 }
; Bug: Generic multiply loop which only ever multiplies by two...
 C$DCE5,1;21 D = A;
 C$DCE6,1;21 A = 0;
 C$DCE7,2;21 E = 3; // unusual (or self modified and i've not spotted the setter)
 C$DCE9,1;21 E--;
*C$DCEA,1;21 {  do <% A += E; %> while (--D); %>
 C$DCEB,1;21
 C$DCEC,3;21 }
; D ends up as zero either way.
*C$DCEF,1;21 E = A;
 C$DCF0,3;21 {bitmap_pointer += DE;
 C$DCF3,1;21
 C$DCF4,3;21 }
 C$DCF7,3;21 {mask_pointer += DE;
 C$DCFA,1;21
 C$DCFB,3;21 }
 C$DCFE,2
 C$DD00,1;21 A = 0;
 C$DD01,1;21 return; /* visible */

; Clipping items to the game window.
;
; Used by the routine at #R$DC41.
; .
; Counterpart to vischar_visible.
;
; O:AF Z => visible !Z => invisible
; O:BC Clipped width.
; O:DE Clipped height.
;
; Width part.
@label=item_visible
cC$DD02,3;21 HL = &iso_pos_x;
 C$DD05,4;21 DE = map_position;
 C$DD09,1;21 {A = E + 24 - HL[0]; // xoff
 C$DD0A,2;21
 C$DD0C,1;21 }
 C$DD0D,2;21 {if (A <= 0) goto invisible;
 C$DD0F,2;21 }
 C$DD11,2;21 {if (A < 3) <%
 C$DD13,3;21 }
 C$DD16,2;21 {  BC = A; %>
 C$DD18,1;21 }
 C$DD19,2;21 else <%
*C$DD1B,1;21 {  A = HL[0] + 3 - E;
 C$DD1C,2;21
 C$DD1E,1;21 }
 C$DD1F,2;21 {  if (A <= 0) goto invisible;
 C$DD21,2;21 }
 C$DD23,2;21 {  if (A < 3) <%
 C$DD25,3;21 }
 C$DD28,1;21 C = A;
 C$DD29,2;21 {    B = 3 - C; %>
 C$DD2B,1;21
 C$DD2C,1;21 }
 C$DD2D,2;21 else <%
*C$DD2F,2;21 {    BC = 3; %> %>
 C$DD31,2;21 }
; Height part.
*C$DD33,1;21 {A = D + 17 - HL[1];
 C$DD34,3;21
 C$DD37,1;21 }
 C$DD38,2;21 {if (A <= 0) goto invisible;
 C$DD3A,2;21 }
 C$DD3C,2;21 {if (A < 2) <%
 C$DD3E,3;21 }
 C$DD41,2;21 {  DE = 8; %>
 C$DD43,2;21 }
 C$DD45,2;21 else <%
*C$DD47,1;21 {  A = HL[1] + 2 - D;
 C$DD48,2;21
 C$DD4A,1;21 }
 C$DD4B,2;21 {  if (A <= 0) goto invisible;
 C$DD4D,2;21 }
 C$DD4F,2;21 {  if (A < 2) <%
 C$DD51,3;21 }
 C$DD54,3;21 {    E = item_height - 8;
 C$DD57,2;21
 C$DD59,1;21 }
 C$DD5A,2;21 D = 8; %>
 C$DD5C,2;21 else <%
*C$DD5E,2;21 {    DE = item_height; %> %>
 C$DD60,3;21
 C$DD63,1;21 }
*C$DD64,1;21 visible: A = 0;
 C$DD65,1;21 return;
*C$DD66,2;21 invisible: A |= 1;
 C$DD68,1;21 return;

; Item attributes.
;
; 20 bytes, 4 of which are unknown, possibly unused.
; .
; 'Yellow/black' means yellow ink over black paper, for example.
@label=item_attributes
bB$DD69,1;21 item_attribute: WIRESNIPS - yellow/black
 B$DD6A,1;21 item_attribute: SHOVEL - cyan/black
 B$DD6B,1;21 item_attribute: LOCKPICK - cyan/black
 B$DD6C,1;21 item_attribute: PAPERS - white/black
 B$DD6D,1;21 item_attribute: TORCH - green/black
 B$DD6E,1;21 item_attribute: BRIBE - bright-red/black
 B$DD6F,1;21 item_attribute: UNIFORM - green/black
; Food turns purple/black when it's poisoned.
@label=item_attributes_food
 B$DD70,1;21 item_attribute: FOOD - white/black
 B$DD71,1;21 item_attribute: POISON - purple/black
 B$DD72,1;21 item_attribute: RED KEY - bright-red/black
 B$DD73,1;21 item_attribute: YELLOW KEY - yellow/black
 B$DD74,1;21 item_attribute: GREEN KEY - green/black
 B$DD75,1;21 item_attribute: PARCEL - cyan/black
 B$DD76,1;21 item_attribute: RADIO - white/black
 B$DD77,1;21 item_attribute: PURSE - white/black
 B$DD78,1;21 item_attribute: COMPASS - green/black
; The following are likely unused.
 B$DD79,1;21 item_attribute: yellow/black
 B$DD7A,1;21 item_attribute: cyan/black
 B$DD7B,1;21 item_attribute: bright-red/black
 B$DD7C,1;21 item_attribute: bright-red/black

; Item definitions.
;
; Array of "sprite" structures.
; .
; item_definition: WIRESNIPS
@label=item_definitions
bB$DD7D,1;21 width
 B$DD7E,1;21 height
 W$DD7F,2;21 bitmap pointer
 W$DD81,2;21 mask pointer
; item_definition: SHOVEL
 B$DD83,1;21 width
 B$DD84,1;21 height
 W$DD85,2;21 bitmap pointer
 W$DD87,2;21 mask pointer
; item_definition: LOCKPICK
 B$DD89,1;21 width
 B$DD8A,1;21 height
 W$DD8B,2;21 bitmap pointer
 W$DD8D,2;21 mask pointer
; item_definition: PAPERS
 B$DD8F,1;21 width
 B$DD90,1;21 height
 W$DD91,2;21 bitmap pointer
 W$DD93,2;21 mask pointer
; item_definition: TORCH
 B$DD95,1;21 width
 B$DD96,1;21 height
 W$DD97,2;21 bitmap pointer
 W$DD99,2;21 mask pointer
; item_definition: BRIBE
 B$DD9B,1;21 width
 B$DD9C,1;21 height
 W$DD9D,2;21 bitmap pointer
 W$DD9F,2;21 mask pointer
; item_definition: UNIFORM
 B$DDA1,1;21 width
 B$DDA2,1;21 height
 W$DDA3,2;21 bitmap pointer
 W$DDA5,2;21 mask pointer
; item_definition: FOOD
 B$DDA7,1;21 width
 B$DDA8,1;21 height
 W$DDA9,2;21 bitmap pointer
 W$DDAB,2;21 mask pointer
; item_definition: POISON
 B$DDAD,1;21 width
 B$DDAE,1;21 height
 W$DDAF,2;21 bitmap pointer
 W$DDB1,2;21 mask pointer
; item_definition: RED_KEY
 B$DDB3,1;21 width
 B$DDB4,1;21 height
 W$DDB5,2;21 bitmap pointer
 W$DDB7,2;21 mask pointer
; item_definition: YELLOW_KEY
 B$DDB9,1;21 width
 B$DDBA,1;21 height
 W$DDBB,2;21 bitmap pointer
 W$DDBD,2;21 mask pointer
; item_definition: GREEN_KEY
 B$DDBF,1;21 width
 B$DDC0,1;21 height
 W$DDC1,2;21 bitmap pointer
 W$DDC3,2;21 mask pointer
; item_definition: PARCEL
 B$DDC5,1;21 width
 B$DDC6,1;21 height
 W$DDC7,2;21 bitmap pointer
 W$DDC9,2;21 mask pointer
; item_definition: RADIO
 B$DDCB,1;21 width
 B$DDCC,1;21 height
 W$DDCD,2;21 bitmap pointer
 W$DDCF,2;21 mask pointer
; item_definition: PURSE
 B$DDD1,1;21 width
 B$DDD2,1;21 height
 W$DDD3,2;21 bitmap pointer
 W$DDD5,2;21 mask pointer
; item_definition: COMPASS
 B$DDD7,1;21 width
 B$DDD8,1;21 height
 W$DDD9,2;21 bitmap pointer
 W$DDDB,2;21 mask pointer

; Item bitmaps and masks.
;
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DDDD-$DDF6-1-16{0,0,64,52}(item-shovel) }
; TABLE#
@label=bitmap_shovel
bB$DDDD,2;21 {item_bitmap: SHOVEL (16x13)
 B$DDDF,2*11
 B$DDF5,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DDF7-$DE10-1-16{0,0,64,52}(item-key) }
; TABLE#
@label=bitmap_key
 B$DDF7,2;21 {item_bitmap: KEY (shared for all keys) (16x13)
 B$DDF9,2*11
 B$DE0F,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DE11-$DE30-1-16{0,0,64,64}(item-lockpick) }
; TABLE#
@label=bitmap_lockpick
 B$DE11,2;21 {item_bitmap: LOCKPICK (16x16)
 B$DE13,2*14
 B$DE2F,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DE31-$DE48-1-16{0,0,64,48}(item-compass) }
; TABLE#
@label=bitmap_compass
 B$DE31,2;21 {item_bitmap: COMPASS (16x12)
 B$DE33,2*10
 B$DE47,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DE49-$DE60-1-16{0,0,64,48}(item-purse) }
; TABLE#
@label=bitmap_purse
 B$DE49,2;21 {item_bitmap: PURSE (16x12)
 B$DE4B,2*10
 B$DE5F,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DE61-$DE7E-1-16{0,0,64,60}(item-papers) }
; TABLE#
@label=bitmap_papers
 B$DE61,2;21 {item_bitmap: PAPERS (16x15)
 B$DE63,2*13
 B$DE7D,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DE7F-$DE94-1-16{0,0,64,44}(item-wiresnips) }
; TABLE#
@label=bitmap_wiresnips
 B$DE7F,2;21 {item_bitmap: WIRESNIPS (16x11)
 B$DE81,2*9
 B$DE93,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DE95-$DEAE-1-16{0,0,64,52}(item-mask-shovelkey) }
; TABLE#
@label=mask_shovel_key
 B$DE95,2;21 {item_mask: SHOVEL or KEY (shared) (16x13)
 B$DE97,2*11
 B$DEAD,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DEAF-$DECE-1-16{0,0,64,64}(item-mask-lockpick) }
; TABLE#
@label=mask_lockpick
 B$DEAF,2;21 {item_mask: LOCKPICK (16x16)
 B$DEB1,2*14
 B$DECD,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DECF-$DEE6-1-16{0,0,64,48}(item-mask-compass) }
; TABLE#
@label=mask_compass
 B$DECF,2;21 {item_mask: COMPASS (16x12)
 B$DED1,2*10
 B$DEE5,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DEE7-$DEFE-1-16{0,0,64,48}(item-mask-purse) }
; TABLE#
@label=mask_purse
 B$DEE7,2;21 {item_mask: PURSE (16x12)
 B$DEE9,2*10
 B$DEFD,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DEFF-$DF1C-1-16{0,0,64,60}(item-mask-papers) }
; TABLE#
@label=mask_papers
 B$DEFF,2;21 {item_mask: PAPERS (16x15)
 B$DF01,2*13
 B$DF1B,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DF1D-$DF32-1-16{0,0,64,44}(item-mask-wiresnips) }
; TABLE#
@label=mask_wiresnips
 B$DF1D,2;21 {item_mask: WIRESNIPS (16x11)
 B$DF1F,2*9
 B$DF31,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DF33-$DF52-1-16{0,0,64,64}(item-food) }
; TABLE#
@label=bitmap_food
 B$DF33,2;21 {item_bitmap: FOOD (16x16)
 B$DF35,2*14
 B$DF51,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DF53-$DF72-1-16{0,0,64,64}(item-poison) }
; TABLE#
@label=bitmap_poison
 B$DF53,2;21 {item_bitmap: POISON (16x16)
 B$DF55,2*14
 B$DF71,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DF73-$DF8A-1-16{0,0,64,48}(item-torch) }
; TABLE#
@label=bitmap_torch
 B$DF73,2;21 {item_bitmap: TORCH (16x12)
 B$DF75,2*10
 B$DF89,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DF8B-$DFAA-1-16{0,0,64,64}(item-uniform) }
; TABLE#
@label=bitmap_uniform
 B$DF8B,2;21 {item_bitmap: UNIFORM (16x16)
 B$DF8D,2*14
 B$DFA9,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DFAB-$DFC4-1-16{0,0,64,52}(item-bribe) }
; TABLE#
@label=bitmap_bribe
 B$DFAB,2;21 {item_bitmap: BRIBE (16x13)
 B$DFAD,2*11
 B$DFC3,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DFC5-$DFE4-1-16{0,0,64,64}(item-radio) }
; TABLE#
@label=bitmap_radio
 B$DFC5,2;21 {item_bitmap: RADIO (16x16)
 B$DFC7,2*14
 B$DFE3,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$DFE5-$E004-1-16{0,0,64,64}(item-parcel) }
; TABLE#
@label=bitmap_parcel
 B$DFE5,2;21 {item_bitmap: PARCEL (16x16)
 B$DFE7,2*14
 B$E003,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$E005-$E01E-1-16{0,0,64,52}(item-mask-bribe) }
; TABLE#
@label=mask_bribe
 B$E005,2;21 {item_mask: BRIBE (16x13)
 B$E007,2*11
 B$E01D,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$E01F-$E03E-1-16{0,0,64,64}(item-mask-uniform) }
; TABLE#
@label=mask_uniform
 B$E01F,2;21 {item_mask: UNIFORM (16x16)
 B$E021,2*14
 B$E03D,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$E03F-$E05E-1-16{0,0,64,64}(item-mask-parcel) }
; TABLE#
@label=mask_parcel
 B$E03F,2;21 {item_mask: PARCEL (16x16)
 B$E041,2*14
 B$E05D,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$E05F-$E07E-1-16{0,0,64,64}(item-mask-poison) }
; TABLE#
@label=mask_poison
 B$E05F,2;21 {item_mask: POISON (16x16)
 B$E061,2*14
 B$E07D,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$E07F-$E096-1-16{0,0,64,48}(item-mask-torch) }
; TABLE#
@label=mask_torch
 B$E07F,2;21 {item_mask: TORCH (16x12)
 B$E081,2*10
 B$E095,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$E097-$E0B6-1-16{0,0,64,64}(item-mask-radio) }
; TABLE#
@label=mask_radio
 B$E097,2;21 {item_mask: RADIO (16x16)
 B$E099,2*14
 B$E0B5,2;21 }
; #UDGTABLE
; { #UDGARRAY2,7,4,2;$E0B7-$E0D6-1-16{0,0,64,64}(item-mask-food) }
; TABLE#
@label=mask_food
 B$E0B7,2;21 {item_mask: FOOD (16x16)
 B$E0B9,2*14
 B$E0D5,2;21 }

; Unreferenced bytes.
uB$E0D7,8,1

; Addresses of self-modified locations which are changed between NOPs and LD
; (HL),A.
;
; (<- setup_item_plotting, setup_vischar_plotting)
@label=masked_sprite_plotter_16_enables
wW$E0E0,2;21 masked_sprite_plotter_16_wide_case_1_enable0
 W$E0E2,2;21 masked_sprite_plotter_16_wide_case_2_enable1
 W$E0E4,2;21 masked_sprite_plotter_16_wide_case_1_enable2
 W$E0E6,2;21 masked_sprite_plotter_16_wide_case_2_enable3
 W$E0E8,2;21 masked_sprite_plotter_16_wide_case_1_enable4
 W$E0EA,2;21 masked_sprite_plotter_16_wide_case_2_enable5

; Addresses of self-modified locations which are changed between NOPs and LD
; (HL),A.
;
; (<- setup_vischar_plotting)
@label=masked_sprite_plotter_24_enables
wW$E0EC,2;21 masked_sprite_plotter_24_wide_enable0
 W$E0EE,2;21 masked_sprite_plotter_24_wide_enable1
 W$E0F0,2;21 masked_sprite_plotter_24_wide_enable2
 W$E0F2,2;21 masked_sprite_plotter_24_wide_enable3
 W$E0F4,2;21 masked_sprite_plotter_24_wide_enable4
 W$E0F6,2;21 masked_sprite_plotter_24_wide_enable5
 W$E0F8,2;21 masked_sprite_plotter_24_wide_enable6
 W$E0FA,2;21 masked_sprite_plotter_24_wide_enable7
; These two look different. Unused?
 W$E0FC,2;21 masked_sprite_plotter_16_wide_vischar
 W$E0FE,2;21 masked_sprite_plotter_24_wide_vischar

; Unused word?
;
; Unsure if related to the above masked_sprite_plotter_24_enables table.
uW$E100,2

; Sprite plotter for 24-pixel-wide sprites. Used for characters and objects.
;
; Used by the routine at #R$B866.
;
; I:IY Pointer to visible character.
@label=masked_sprite_plotter_24_wide_vischar
cC$E102,3;21 {if ((A = (IY[24] & 7)) >= 4) goto unaligned;
 C$E105,4;21
 C$E109,3;21 }
; Shift right?
 C$E10C,1;21 {A = (~A & 3) * 8; // jump table offset (on input, A is 0..3)
 C$E10D,4;21
 C$E111,1;21 }
 C$E112,3;21 ($E160 + 1) = A; // self-modify: jump into mask rotate
 C$E115,3;21 ($E142 + 1) = A; // self-modify: jump into bitmap rotate
 C$E118,1;21 {maskptr = mask_pointer;
 C$E119,3;21 }
 C$E11C,1;21 {bitmapptr = bitmap_pointer;
 C$E11D,3;21 }
@label=masked_sprite_plotter_24_wide_height_iters
 C$E120,2;21 iters = 32; // iterations // clipped_height & 0xFF // self modified
; Load bitmap bytes into B,C,E.
*C$E122,1;21 {do <% bm0 = *bitmapptr++; // bitmap bytes
 C$E123,1;21
 C$E124,1;21 }
 C$E125,1;21 {  bm1 = *bitmapptr++;
 C$E126,1;21 }
 C$E127,1;21 {  bm2 = *bitmapptr++;
 C$E128,2;21
 C$E12A,1;21 }
; Load mask bytes into B',C',E'.
 C$E12B,1;21 {  mask0 = *maskptr++; // mask bytes
 C$E12C,1;21 }
 C$E12D,1;21 {  mask1 = *maskptr++;
 C$E12E,1;21 }
 C$E12F,1;21 {  mask2 = *maskptr++;
 C$E130,1;21
 C$E131,1;21 }
 C$E132,3;21 {  if (flip_sprite & (1<<7)) flip_24_masked_pixels();
 C$E135,1;21
 C$E136,3;21 }
 C$E139,3;21 {  foremaskptr = foreground_mask_pointer;
 C$E13C,1;21 }
@nowarn
 C$E13D,3;21 screenptr = ($81A2); // moved compared to the other routines
; Shift bitmap.
 C$E140,2;21 bm3 = 0;
@label=masked_sprite_plotter_24_wide_jump0
 C$E142,2;21 goto $E144; // self-modified // jump table
*C$E144,2;21 SRL bm0 // 0 // carry = bm0 & 1; bm0 >>= 1;
 C$E146,2;21 RR bm1       // new_carry = bm1 & 1; bm1 = (bm1 >> 1) | (carry << 7); carry = new_carry;
 C$E148,2;21 RR bm2       // new_carry = bm2 & 1; bm2 = (bm2 >> 1) | (carry << 7); carry = new_carry;
 C$E14A,2;21 RR bm3       // new_carry = bm3 & 1; bm3 = (bm3 >> 1) | (carry << 7); carry = new_carry;
 C$E14C,2;21 SRL bm0 // 1
 C$E14E,2;21 RR bm1
 C$E150,2;21 RR bm2
 C$E152,2;21 RR bm3
 C$E154,2;21 SRL bm0 // 2
 C$E156,2;21 RR bm1
 C$E158,2;21 RR bm2
 C$E15A,2;21 {  RR bm3
 C$E15C,1;21 }
; Shift mask.
 C$E15D,2;21 mask3 = 0xFF;
 C$E15F,1;21 carry = 1;
@label=masked_sprite_plotter_24_wide_jump1
 C$E160,2;21 goto $E162; // self-modified // jump table
*C$E162,2;21 RR mask0 // 0 // new_carry = mask0 & 1; mask0 = (mask0 >> 1) | (carry << 7); carry = new_carry;
 C$E164,2;21 RR mask1      // new_carry = mask1 & 1; mask1 = (mask1 >> 1) | (carry << 7); carry = new_carry;
 C$E166,2;21 RR mask2      // new_carry = mask2 & 1; mask2 = (mask2 >> 1) | (carry << 7); carry = new_carry;
 C$E168,2;21 RR mask3      // new_carry = mask3 & 1; mask3 = (mask3 >> 1) | (carry << 7); carry = new_carry;
 C$E16A,2;21 RR mask0 // 1
 C$E16C,2;21 RR mask1
 C$E16E,2;21 RR mask2
 C$E170,2;21 RR mask3
 C$E172,2;21 RR mask0 // 2
 C$E174,2;21 RR mask1
 C$E176,2;21 RR mask2
 C$E178,2;21 RR mask3
;   Plot, using foreground mask.
 C$E17A,1;21 {  A = ((~*foremaskptr | mask0) & *screenptr) | (bm0 & *foremaskptr);
 C$E17B,10;21
 C$E185,1;21 }
 C$E186,1;21 {  foremaskptr++;
 C$E187,1;21 }
@label=masked_sprite_plotter_24_wide_enable0
 C$E188,1;21 {  *screenptr++ = A;          // enable/disable 0
 C$E189,1;21
 C$E18A,1;21 }
 C$E18B,1;21 {  A = ((~*foremaskptr | mask1) & *screenptr) | (bm1 & *foremaskptr);
 C$E18C,2;21
 C$E18E,1
 C$E18F,1;21
 C$E190,1
 C$E191,1;21
 C$E192,1
 C$E193,2;21
 C$E195,1
 C$E196,1;21 }
 C$E197,1;21 {  foremaskptr++;
 C$E198,1;21 }
@label=masked_sprite_plotter_24_wide_enable2
 C$E199,1;21 {  *screenptr++ = A;          // enable/disable 2
 C$E19A,1;21
 C$E19B,1;21 }
 C$E19C,1;21 {  A = ((~*foremaskptr | mask2) & *screenptr) | (bm2 & *foremaskptr);
 C$E19D,2;21
 C$E19F,1
 C$E1A0,1;21
 C$E1A1,1
 C$E1A2,1;21
 C$E1A3,1
 C$E1A4,2;21
 C$E1A6,1
 C$E1A7,1;21 }
 C$E1A8,1;21 {  foremaskptr++;
 C$E1A9,1;21 }
@label=masked_sprite_plotter_24_wide_enable4
 C$E1AA,1;21 {  *screenptr++ = A;          // enable/disable 4
 C$E1AB,1;21
 C$E1AC,1;21 }
 C$E1AD,1;21 {  A = ((~*foremaskptr | mask3) & *screenptr) | (bm3 & *foremaskptr);
 C$E1AE,2;21
 C$E1B0,1
 C$E1B1,1;21
 C$E1B2,1
 C$E1B3,1;21
 C$E1B4,1
 C$E1B5,2;21
 C$E1B7,1
 C$E1B8,1;21 }
 C$E1B9,1;21 foremaskptr++;
 C$E1BA,3;21 {  foreground_mask_pointer = foremaskptr;
 C$E1BD,1;21
 C$E1BE,1;21 }
@label=masked_sprite_plotter_24_wide_enable6
 C$E1BF,1;21 *screenptr = A;            // enable/disable 6
 C$E1C0,3;21 {  screenptr += 21; // stride (24 - 3)
 C$E1C3,1;21 }
@nowarn
 C$E1C4,3;21 {  ($81A2) = screenptr;
 C$E1C7,1;21 }
 C$E1C8,1;21 {%> while (--iters);
 C$E1C9,1;21
 C$E1CA,3;21 }
 C$E1CD,1;21 return;
; Shift left?
@label=masked_sprite_plotter_24_wide_unaligned
*C$E1CE,2;21 unaligned: A -= 4;
 C$E1D0,1;21 RLCA
 C$E1D1,1;21 RLCA
 C$E1D2,1;21 RLCA
 C$E1D3,3;21 ($E229 + 1) = A; // self-modify: jump into mask rotate
 C$E1D6,3;21 ($E203 + 1) = A; // self-modify: jump into bitmap rotate
 C$E1D9,1;21 {HLdash = mask_pointer;
 C$E1DA,3;21 }
 C$E1DD,1;21 {HL = bitmap_pointer;
 C$E1DE,3;21 }
@label=masked_sprite_plotter_24_wide_unaligned_height_iters
 C$E1E1,2;21 B = 32; // iterations // clipped_height & 0xFF // self modified
; Load bitmap bytes into B,C,E.
*C$E1E3,1;21 do <%
 C$E1E4,1;21 {  B = *HL++;
 C$E1E5,1;21 }
 C$E1E6,1;21 {  C = *HL++;
 C$E1E7,1;21 }
 C$E1E8,1;21 {  E = *HL++;
 C$E1E9,1;21 }
 C$E1EA,2
; Load mask bytes into B',C',E'.
 C$E1EC,1;21 {  B = *HL++;
 C$E1ED,1;21 }
 C$E1EE,1;21 {  C = *HL++;
 C$E1EF,1;21 }
 C$E1F0,1;21 {  E = *HL++;
 C$E1F1,1;21 }
 C$E1F2,1
 C$E1F3,3;21 {  if (flip_sprite & (1<<7)) flip_24_masked_pixels();
 C$E1F6,1;21
 C$E1F7,3;21 }
 C$E1FA,3;21 HL = foreground_mask_pointer;
 C$E1FD,1
@nowarn
 C$E1FE,3;21 HL = ($81A2); // screen pointer
; Shift bitmap.
 C$E201,2;21 D = 0;
@label=masked_sprite_plotter_24_wide_jump2
 C$E203,2;21 goto $E205; // self-modified to jump into ...;
*C$E205,2;21 SLA E
 C$E207,2;21 RL C
 C$E209,2;21 RL B
 C$E20B,2;21 RL D
 C$E20D,2;21 SLA E
 C$E20F,2;21 RL C
 C$E211,2;21 RL B
 C$E213,2;21 RL D
 C$E215,2;21 SLA E
 C$E217,2;21 RL C
 C$E219,2;21 RL B
 C$E21B,2;21 RL D
 C$E21D,2;21 SLA E
 C$E21F,2;21 RL C
 C$E221,2;21 RL B
 C$E223,2;21 RL D
 C$E225,1
; Shift mask.
 C$E226,2;21 D = 255;
 C$E228,1;21 SCF
@label=masked_sprite_plotter_24_wide_jump3
 C$E229,2;21 goto $E22B; // self-modified to jump into ...;
*C$E22B,2;21 RL E
 C$E22D,2;21 RL C
 C$E22F,2;21 RL B
 C$E231,2;21 RL D
 C$E233,2;21 RL E
 C$E235,2;21 RL C
 C$E237,2;21 RL B
 C$E239,2;21 RL D
 C$E23B,2;21 RL E
 C$E23D,2;21 RL C
 C$E23F,2;21 RL B
 C$E241,2;21 RL D
 C$E243,2;21 RL E
 C$E245,2;21 RL C
 C$E247,2;21 RL B
 C$E249,2;21 RL D
; Plot, using foreground mask.
 C$E24B,1;21 {  A = ~*HL | D;       // 1
 C$E24C,1;21
 C$E24D,1;21 }
 C$E24E,1
 C$E24F,1;21 A &= *HL;
 C$E250,1
 C$E251,1;21 A = D;
 C$E252,1
 C$E253,1;21 A &= *HL;
 C$E254,1;21 D = A;
 C$E255,1
 C$E256,1;21 A |= D;
 C$E257,1;21 L++;
 C$E258,1
@label=masked_sprite_plotter_24_wide_enable1
 C$E259,1;21 {  *HL++ = A;          // enable/disable 1
 C$E25A,1;21 }
 C$E25B,1
 C$E25C,1;21 {  A = ~*HL | B;       // 2
 C$E25D,1;21
 C$E25E,1;21 }
 C$E25F,1
 C$E260,1;21 A &= *HL;
 C$E261,1
 C$E262,1;21 A = B;
 C$E263,1
 C$E264,1;21 A &= *HL;
 C$E265,1;21 B = A;
 C$E266,1
 C$E267,1;21 A |= B;
 C$E268,1;21 L++;
 C$E269,1
@label=masked_sprite_plotter_24_wide_enable3
 C$E26A,1;21 {  *HL++ = A;          // enable/disable 3
 C$E26B,1;21 }
 C$E26C,1
 C$E26D,1;21 {  A = ~*HL | C;       // 3
 C$E26E,1;21
 C$E26F,1;21 }
 C$E270,1
 C$E271,1;21 A &= *HL;
 C$E272,1
 C$E273,1;21 A = C;
 C$E274,1
 C$E275,1;21 A &= *HL;
 C$E276,1;21 C = A;
 C$E277,1
 C$E278,1;21 A |= C;
 C$E279,1;21 L++;
 C$E27A,1
@label=masked_sprite_plotter_24_wide_enable5
 C$E27B,1;21 {  *HL++ = A;          // enable/disable 5
 C$E27C,1;21 }
 C$E27D,1
 C$E27E,1;21 {  A = ~*HL | E;       // 4
 C$E27F,1;21
 C$E280,1;21 }
 C$E281,1
 C$E282,1;21 A &= *HL;
 C$E283,1
 C$E284,1;21 A = E;
 C$E285,1
 C$E286,1;21 A &= *HL;
 C$E287,1;21 E = A;
 C$E288,1
 C$E289,1;21 A |= E;
 C$E28A,1;21 L++;
 C$E28B,3;21 foreground_mask_pointer = HL;
 C$E28E,2
@label=masked_sprite_plotter_24_wide_enable7
 C$E290,1;21 *HL = A;            // enable/disable 7
 C$E291,3;21 {  HL += 21;
 C$E294,1;21 }
@nowarn
 C$E295,3;21 ($81A2) = HL;
 C$E298,2
 C$E29A,1;21 {%> while (--B);
 C$E29B,3;21 }
 C$E29E,1;21 return;

; Entry point for masked_sprite_plotter_16_wide_left which assumes A == 0. (+
; no vischar passed).
;
; Used by the routine at #R$B866.
@label=masked_sprite_plotter_16_wide_item
cC$E29F,1;21 A = 0;
 C$E2A0,2;21 goto masked_sprite_plotter_16_wide_left;

; Sprite plotter. Used for characters and objects.
;
; Used by the routine at #R$B866.
; .
; Looks like it plots a two byte-wide sprite with mask into a three byte-wide
; destination.
;
; I:IY Pointer to visible character.
@label=masked_sprite_plotter_16_wide_vischar
cC$E2A2,3;21 {if ((A = IY[24] & 7) >= 4) goto masked_sprite_plotter_16_wide_right.
 C$E2A5,4;21
 C$E2A9,3;21 }
; FALL THROUGH into masked_sprite_plotter_16_wide_left.

; Sprite plotter "left" case.
;
; Used by the routine at #R$E29F.
; .
; Shifts left/right (unsure which atm).
; .
; Shifts left/right (unsure which atm).
@label=masked_sprite_plotter_16_wide_left
cC$E2AC,1;21 {A = (~A & 3) * 6; // jump table offset
 C$E2AD,5;21
 C$E2B2,1;21 }
 C$E2B3,3;21 ($E2DB + 1) = A; // self-modify: jump into mask rotate
 C$E2B6,3;21 ($E2F3 + 1) = A; // self-modify: jump into bitmap rotate
 C$E2B9,1;21 {maskptr = mask_pointer; // maskptr = HL'  // observed: $D505 (a mask)
 C$E2BA,3;21
 C$E2BD,1;21 }
 C$E2BE,3;21 bitmapptr = bitmap_pointer; // bitmapptr = HL  // observed: $D256 (a bitmap)
@label=masked_sprite_plotter_16_wide_case_1_height_iters
 C$E2C1,2;21 B = 32; // iterations // height? // self modified
; Load bitmap bytes into D,E.
*C$E2C3,1;21 {do <% bm0 = *bitmapptr++; // D
 C$E2C4,1;21 }
 C$E2C5,1;21 {  bm1 = *bitmapptr++; // E
 C$E2C6,1;21 }
; Load mask bytes into D',E'.
 C$E2C7,1;21 {  mask0 = *maskptr++; // D'
 C$E2C8,1
 C$E2C9,1;21
 C$E2CA,1;21 }
 C$E2CB,1;21 {  mask1 = *maskptr++; // E'
 C$E2CC,1;21
 C$E2CD,1;21 }
 C$E2CE,3;21 {  if (flip_sprite & (1<<7)) flip_16_masked_pixels();
 C$E2D1,1;21
 C$E2D2,3;21 }
 C$E2D5,3;21 foremaskptr = foreground_mask_pointer;  // observed: $8100 = mask_buffer
; Shift mask.
; .
; 24 version does bitmap rotates then mask rotates. Is this the opposite way
; around to save a bank switch?
 C$E2D8,2;21 mask2 = 0xFF; // all bits set => mask OFF (that would match the observed stored mask format)
 C$E2DA,1;21 carry = 1; // mask OFF
@label=masked_sprite_plotter_16_wide_case_1_jump0
 C$E2DB,2;21 goto $E2DD; // self modified // jump table
*C$E2DD,2;21 RR mask0 // 0 // new_carry = mask0 & 1; mask0 = (mask0 >> 1) | (carry << 7); carry = new_carry;
 C$E2DF,2;21 RR mask1      // new_carry = mask1 & 1; mask1 = (mask1 >> 1) | (carry << 7); carry = new_carry;
 C$E2E1,2;21 RR mask2      // new_carry = mask2 & 1; mask2 = (mask2 >> 1) | (carry << 7); carry = new_carry;
 C$E2E3,2;21 RR mask0 // 1
 C$E2E5,2;21 RR mask1
 C$E2E7,2;21 RR mask2
 C$E2E9,2;21 RR mask0 // 2
 C$E2EB,2;21 RR mask1
 C$E2ED,2;21 RR mask2
; Shift bitmap.
 C$E2EF,1;21 {  bm2 = 0; // all bits clear => pixels OFF
 C$E2F0,2;21 }
 C$E2F2,1;21 A &= A; // I do not grok this. Setting carry flag?
@label=masked_sprite_plotter_16_wide_case_1_jump1
 C$E2F3,2;21 goto $E2F5; // self modified // jump table
*C$E2F5,2;21 SRL bm0 // 0 // carry = bm0 & 1; bm0 >>= 1;
 C$E2F7,2;21 RR bm1       // new_carry = bm1 & 1; bm1 = (bm1 >> 1) | (carry << 7); carry = new_carry;
 C$E2F9,2;21 RR bm2       // new_carry = bm2 & 1; bm2 = (bm2 >> 1) | (carry << 7); carry = new_carry;
 C$E2FB,2;21 SRL bm0 // 1
 C$E2FD,2;21 RR bm1
 C$E2FF,2;21 RR bm2
 C$E301,2;21 SRL bm0 // 2
 C$E303,2;21 RR bm1
 C$E305,2;21 RR bm2
; Plot, using foreground mask.
@nowarn
 C$E307,3;21 screenptr = ($81A2);
 C$E30A,1;21 {  A = ((~*foremaskptr | mask0) & *screenptr) | (bm0 & *foremaskptr);
 C$E30B,3;21
 C$E30E,1
 C$E30F,1;21
 C$E310,1
 C$E311,1;21
 C$E312,1
 C$E313,2;21
 C$E315,1
 C$E316,1;21 }
 C$E317,1;21 {  foremaskptr++;
 C$E318,1;21 }
@label=masked_sprite_plotter_16_wide_case_1_enable0
 C$E319,1;21 {  *screenptr++ = A; // entry point jump0
 C$E31A,1;21 }
 C$E31B,1;21 {  A = ((~*foremaskptr | mask1) & *screenptr) | (bm1 & *foremaskptr);
 C$E31C,3;21
 C$E31F,1
 C$E320,1;21
 C$E321,1
 C$E322,1;21
 C$E323,1
 C$E324,2;21
 C$E326,1
 C$E327,1;21 }
 C$E328,1;21 {  foremaskptr++;
 C$E329,1;21 }
@label=masked_sprite_plotter_16_wide_case_1_enable2
 C$E32A,1;21 {  *screenptr++ = A; // entry point jump2
 C$E32B,1;21 }
 C$E32C,1;21 {  A = ((~*foremaskptr | mask2) & *screenptr) | (bm2 & *foremaskptr);
 C$E32D,3;21
 C$E330,1
 C$E331,1;21
 C$E332,1
 C$E333,1;21
 C$E334,1
 C$E335,2;21
 C$E337,1
 C$E338,1;21 }
 C$E339,1;21 {  foremaskptr += 2;
 C$E33A,1;21 }
 C$E33B,3;21 {  foreground_mask_pointer = foremaskptr;
 C$E33E,1;21
 C$E33F,1;21 }
@label=masked_sprite_plotter_16_wide_case_1_enable4
 C$E340,1;21 *screenptr = A; // entry point jump4
 C$E341,3;21 {  screenptr += 22; // stride (24 - 2)
 C$E344,1;21 }
@nowarn
 C$E345,3;21 ($81A2) = screenptr;
 C$E348,1;21 {%> while (--B);
 C$E349,1;21
 C$E34A,3;21 }
 C$E34D,1;21 return;

; Sprite plotter "right" case.
;
; Used by the routine at #R$E2A2.
; .
; Counterpart of above routine.
@label=masked_sprite_plotter_16_wide_right
cC$E34E,2;21 {A = (A - 4) * 6; // jump table offset
 C$E350,3;21
 C$E353,1;21 }
 C$E354,3;21 ($E399 + 1) = A; // self-modify - first jump
 C$E357,3;21 ($E37C + 1) = A; // self-modify - second jump
 C$E35A,1;21 {maskptr = mask_pointer;
 C$E35B,3;21 }
 C$E35E,1;21 {bitmapptr = bitmap_pointer;
 C$E35F,3;21 }
@label=masked_sprite_plotter_16_wide_case_2_height_iters
 C$E362,2;21 B = 32; // iterations // height? // self modified
*C$E364,1;21 {do <% bm1 = *bitmapptr++; // numbering of the masks ... unsure
 C$E365,1;21 }
 C$E366,1;21 {  bm2 = *bitmapptr++;
 C$E367,1;21 }
 C$E368,1;21 {  mask1 = *maskptr++;
 C$E369,1
 C$E36A,1;21
 C$E36B,1;21 }
 C$E36C,1;21 {  mask2 = *maskptr++;
 C$E36D,1;21 }
 C$E36E,1;21 {  if (flip_sprite & (1<<7)) flip_16_masked_pixels();
 C$E36F,4;21
 C$E373,3;21 }
 C$E376,3;21 foremaskptr = foreground_mask_pointer;
;   Shift mask.
 C$E379,2;21 mask0 = 0xFF; // all bits set => mask OFF (that would match the observed stored mask format)
 C$E37B,1;21 carry = 1; // mask OFF
@label=masked_sprite_plotter_16_wide_case_2_jump0
 C$E37C,2;21 goto $E37E; // self modified // jump table
*C$E37E,2;21 RL mask2 // 0 // new_carry = mask2 >> 7; mask2 = (mask2 << 1) | (carry << 0); carry = new_carry;
 C$E380,2;21 RL mask1      // new_carry = mask1 >> 7; mask1 = (mask1 << 1) | (carry << 0); carry = new_carry;
 C$E382,2;21 RL mask0      // new_carry = mask0 >> 7; mask0 = (mask0 << 1) | (carry << 0); carry = new_carry;
 C$E384,2;21 RL mask2 // 1
 C$E386,2;21 RL mask1
 C$E388,2;21 RL mask0
 C$E38A,2;21 RL mask2 // 2
 C$E38C,2;21 RL mask1
 C$E38E,2;21 RL mask0
 C$E390,2;21 RL mask2 // 3 // four groups of shifting in this routine, compared to three above.
 C$E392,2;21 RL mask1
 C$E394,2;21 RL mask0
; Shift bitmap.
 C$E396,1;21 {  bm0 = 0; // all bits clear => pixels OFF
 C$E397,1;21
 C$E398,1;21 }
@label=masked_sprite_plotter_16_wide_case_2_jump1
 C$E399,2;21 goto $E39B; // self modified // jump table
*C$E39B,2;21 SLA bm2 // 0 // carry = bm2 >> 7; bm2 <<= 1;
 C$E39D,2;21 RL bm1       // new_carry = bm1 >> 7; bm1 = (bm1 << 1) | (carry << 0); carry = new_carry;
 C$E39F,2;21 RL bm0       // new_carry = bm0 >> 7; bm0 = (bm0 << 1) | (carry << 0); carry = new_carry;
 C$E3A1,2;21 SLA bm2
 C$E3A3,2;21 RL bm1
 C$E3A5,2;21 RL bm0
 C$E3A7,2;21 SLA bm2
 C$E3A9,2;21 RL bm1
 C$E3AB,2;21 RL bm0
 C$E3AD,2;21 SLA bm2
 C$E3AF,2;21 RL bm1
 C$E3B1,2;21 RL bm0
; Plot, using foreground mask.
@nowarn
 C$E3B3,3;21 screenptr = ($81A2);
 C$E3B6,1;21 {  A = ((~*foremaskptr | mask0) & *screenptr) | (bm0 & *foremaskptr);
 C$E3B7,3;21
 C$E3BA,1
 C$E3BB,1;21
 C$E3BC,1
 C$E3BD,1;21
 C$E3BE,1
 C$E3BF,2;21
 C$E3C1,1
 C$E3C2,1;21 }
 C$E3C3,1;21 {  foremaskptr++;
 C$E3C4,1;21 }
@label=masked_sprite_plotter_16_wide_case_2_enable1
 C$E3C5,1;21 {  *screenptr++ = A; // entry point jump1
 C$E3C6,1;21 }
 C$E3C7,1;21 {  A = ((~*foremaskptr | mask1) & *screenptr) | (bm1 & *foremaskptr);
 C$E3C8,3;21
 C$E3CB,1
 C$E3CC,1;21
 C$E3CD,1
 C$E3CE,1;21
 C$E3CF,1
 C$E3D0,2;21
 C$E3D2,1
 C$E3D3,1;21 }
 C$E3D4,1;21 {  foremaskptr++;
 C$E3D5,1;21 }
@label=masked_sprite_plotter_16_wide_case_2_enable3
 C$E3D6,1;21 {  *screenptr++ = A; // entry point jump3
 C$E3D7,1;21 }
 C$E3D8,1;21 {  A = ((~*foremaskptr | mask2) & *screenptr) | (bm2 & *foremaskptr);
 C$E3D9,3;21
 C$E3DC,1
 C$E3DD,1;21
 C$E3DE,1
 C$E3DF,1;21
 C$E3E0,1
 C$E3E1,2;21
 C$E3E3,1
 C$E3E4,1;21 }
 C$E3E5,1;21 {  foremaskptr += 2;
 C$E3E6,1;21 }
 C$E3E7,3;21 {  foreground_mask_pointer = foremaskptr;
 C$E3EA,1;21
 C$E3EB,1;21 }
@label=masked_sprite_plotter_16_wide_case_2_enable5
 C$E3EC,1;21 *screenptr = A; // entry point jump5
 C$E3ED,3;21 {  screenptr += 22; // stride (24 - 2)
 C$E3F0,1;21 }
@nowarn
 C$E3F1,3;21 ($81A2) = screenptr;
 C$E3F4,1;21 {%> while (--B);
 C$E3F5,1;21
 C$E3F6,3;21 }
 C$E3F9,1;21 return;

; Reverses the 24 pixels in E,C,B and E',C',B'.
;
; Used by the routine at #R$E102.
;
; I:E  First 8 pixels.
; I:BC Second 16 pixels.
; O:E  Reversed pixels.
; O:BC Reversed pixels.
;
; Reverse the bitmap bytes.
@label=flip_24_masked_pixels
cC$E3FA,2;21 H = 0x7F;  // HL = 0x7F00 | (DE & 0x00FF); // 0x7F00 -> table of bit reversed bytes
 C$E3FC,1;21 L = E;
 C$E3FD,1;21 E = B;     // DE = (DE & 0xFF00) | (BC >> 8);
 C$E3FE,1;21 B = *HL;   // BC = (*HL << 8) | (BC & 0xFF);
 C$E3FF,1;21 L = E;     // HL = (HL & 0xFF00) | (DE & 0xFF);
 C$E400,1;21 E = *HL;   // DE = (DE & 0xFF00) | *HL;
 C$E401,1;21 L = C;     // HL = (HL & 0xFF00) | (BC & 0xFF);
 C$E402,1;21 C = *HL;   // BC = (BC & 0xFF00) | *HL;
 C$E403,1
; Reverse the mask bytes.
 C$E404,2;21 Hdash = 0x7F;
 C$E406,1;21 Ldash = Edash;
 C$E407,1;21 Edash = Bdash;
 C$E408,1;21 Bdash = *HLdash;
 C$E409,1;21 Ldash = Edash;
 C$E40A,1;21 Edash = *HLdash;
 C$E40B,1;21 Ldash = Cdash;
 C$E40C,1;21 Cdash = *HLdash;
 C$E40D,1
 C$E40E,1;21 return;

; Reverses the 16 pixels in D,E and D',E'.
;
; Used by the routines at #R$E2AC and #R$E34E.
;
; I:DE 16 pixels to reverse.
; O:DE Reversed pixels.
;
; Reverse the bitmap bytes.
@label=flip_16_masked_pixels
cC$E40F,2;21 H = 0x7F;  // HL = 0x7F00 | (DE >> 8); // 0x7F00 -> table of bit reversed bytes
 C$E411,1;21 L = D;
 C$E412,1;21 D = E;     // DE = (E << 8) | *HL;
 C$E413,1;21 E = *HL;
 C$E414,1;21 L = D;     // HL = (HL & 0xFF00) | (DE >> 8);
 C$E415,1;21 D = *HL;   // DE = (*HL << 8) | (DE & 0x00FF);
 C$E416,1
; Reverse the mask bytes.
 C$E417,2;21 Hdash = 0x7F;
 C$E419,1;21 Ldash = Ddash;
 C$E41A,1;21 Ddash = Edash;
 C$E41B,1;21 Edash = *HLdash;
 C$E41C,1;21 Ldash = Ddash;
 C$E41D,1;21 Ddash = *HLdash;
 C$E41E,1
 C$E41F,1;21 return;

; Set up vischar plotting.
;
; Used by the routine at #R$B866.
;
; I:HL Pointer to ? // observed: always the same as IY
; I:IY Pointer to visible character.
@label=setup_vischar_plotting
cC$E420,2;21 {HL = &vischar->mi.pos;
 C$E422,1;21
 C$E423,1;21 }
 C$E424,3;21 DE = &tinypos_stash;
 C$E427,3;21 {if (room_index > room_0_OUTDOORS) <%
 C$E42A,1;21
 C$E42B,2;21 }
; Indoors.
 C$E42D,2;21 *DE++ = *HL++;
 C$E42F,1;21 HL++;
 C$E430,2;21 *DE++ = *HL++;
 C$E432,1;21 HL++;
 C$E433,2;21 *DE++ = *HL++;
 C$E435,1;21 HL++; %>
 C$E436,2;21 else <%
; Outdoors.
*C$E438,1;21 {  A = *HL++;
 C$E439,1;21 }
 C$E43A,1;21 C = *HL;
 C$E43B,3;21 divide_by_8_with_rounding(C,A);
 C$E43E,1;21 *DE++ = A;
 C$E43F,1;21 {  HL++;
 C$E440,1;21 }
 C$E441,2;21 B = 2; // 2 iterations
*C$E443,1;21 {  do <% A = *HL++;
 C$E444,1;21 }
 C$E445,1;21 C = *HL;
 C$E446,3;21 divide_by_8(C,A);
 C$E449,1;21 *DE++ = A;
 C$E44A,1;21 {    HL++;
 C$E44B,1;21 }
 C$E44C,2;21 %> while (--B); %>
*C$E44E,1;21 {C = *HL++;
 C$E44F,1;21 }
 C$E450,1;21 B = *HL++;
 C$E451,2
 C$E453,1;21 {sprite_index = *HL++; // set left/right flip flag / sprite offset
 C$E454,3;21 }
 C$E457,2
 C$E459,2;21 B = 2; // 2 iterations
*C$E45B,1;21 {do <% Adash = *HL++;
 C$E45C,1;21 }
 C$E45D,1;21 C = *HL++;
 C$E45E,3;21 divide_by_8(C,Adash);
 C$E461,1;21 {  *DE++ = Adash;
 C$E462,1;21
 C$E463,1;21 }
 C$E464,2;21 %> while (--B);
 C$E466,2
 C$E468,1;21 {DE += A * 6; // point into sprite[] array
 C$E469,7;21
 C$E470,1;21 }
*C$E471,1;21 {L += 2; // skip over room, unused bytes
 C$E472,1;21 }
 C$E473,1
 C$E474,2;21 *DE++ = *HL++; // width in bytes
 C$E476,2;21 *DE++ = *HL++; // height in rows
 C$E478,3;21 {memcpy(bitmap_pointer, HL, 4); // copy bitmap pointer and mask pointer
 C$E47B,3;21
 C$E47E,2;21 }
 C$E480,3;21 vischar_visible();
 C$E483,1;21 {if (A) return; /* invisible */
 C$E484,1;21 }
 C$E485,1;21 // PUSH clipped_width
 C$E486,1;21 // PUSH clipped_height
 C$E487,3;21 A = IY[30]; // vischar width_bytes
 C$E48A,2;21 {if (A == 3) <% // 3 => 16 wide (4 => 24 wide)
 C$E48C,2;21 }
 C$E48E,1;21 {  ($E2C1 + 1) = E; // self modify masked_sprite_plotter_16_wide_left
 C$E48F,3;21 }
 C$E492,3;21 ($E362 + 1) = E; // self-modify masked_sprite_plotter_16_wide_right
 C$E495,2;21 A = 3;
 C$E497,3;21 HL = masked_sprite_plotter_16_enables; %>
 C$E49A,2;21 else <%
*C$E49C,1
 C$E49D,3;21 ($E120 + 1) = E; // self-modify masked_sprite_plotter_24_wide_vischar (shift right case)
 C$E4A0,3;21 ($E1E1 + 1) = E; // self-modify masked_sprite_plotter_24_wide_vischar (shift left case)
 C$E4A3,2;21 A = 4;
 C$E4A5,3;21 HL = masked_sprite_plotter_24_enables; %>
*C$E4A8,1;21 PUSH enables
 C$E4A9,3;21 ($E4BF + 1) = A; // self-modify
 C$E4AC,1;21 E = A;
 C$E4AD,1;21 A = B; // clipped width top byte (lefthand skip)
 C$E4AE,1;21 {if (A == 0) <%
 C$E4AF,2;21 }
 C$E4B1,2;21 A = 0x77; /* opcode of 'LD (HL),A' */
 C$E4B3,1
 C$E4B4,1;21 Adash = C; %>
 C$E4B5,2;21 else <%
*C$E4B7,1;21 A = 0; /* opcode of 'LD (HL),A' */
 C$E4B8,1
 C$E4B9,1;21 {  Adash = E - C; %>
 C$E4BA,1;21 }
*C$E4BB,1
 C$E4BC,1;21 POP enables
 C$E4BD,1;21 Cdash = Adash;
 C$E4BE,1
; Set the addresses in the jump table to NOP or LD (HL),A.
@label=setup_vischar_plotting_enables_iters
 C$E4BF,2;21 Bdash = 3; // 3 iterations // self modified by $E4A9
*C$E4C1,1;21 {do <% Edash = *HLdash++;
 C$E4C2,1;21 }
 C$E4C3,1;21 Ddash = *HLdash++;
 C$E4C4,1;21 {  *DEdash = A;
 C$E4C5,1;21 }
 C$E4C6,1;21 {  Edash = *HLdash++;
 C$E4C7,1;21 }
 C$E4C8,1;21 {  Ddash = *HLdash++;
 C$E4C9,1;21 }
 C$E4CA,1;21 *DEdash = A;
 C$E4CB,1;21 Cdash--;
 C$E4CC,2;21 {  if (Z) A ^= 0x77; /* Toggle between LD and NOP. */
 C$E4CE,2;21 }
*C$E4D0,2;21 %> while (--Bdash);
 C$E4D2,1
 C$E4D3,1;21 A = D;
 C$E4D4,1;21 A &= A;
 C$E4D5,3;21 DE = 0;
 C$E4D8,2;21 if (Z) <%
 C$E4DA,3;21 {  HL = $81BC * 8; // &map_position + 1;
 C$E4DD,5;21
 C$E4E2,1;21 }
 C$E4E3,1
 C$E4E4,3;21 L = IY[26];
 C$E4E7,3;21 H = IY[27];
 C$E4EA,1;21 A &= A;
 C$E4EB,2;21
 C$E4ED,1;21 {  HL *= 24;
 C$E4EE,5;21
 C$E4F3,1;21 }
 C$E4F4,1;21 %>
*C$E4F5,3;21 {HL = screenpos.x - map_position.x; // subtract + extend to 16-bit
 C$E4F8,5;21
 C$E4FD,2;21 }
 C$E4FF,2;21 {if (HL < 0) H = 0xFF; // sign extend
 C$E501,2;21 }
*C$E503,1;21 {HL += DE + 0xF290; // &state->window_buf[x + y];
 C$E504,3;21
 C$E507,1;21 }
@nowarn
 C$E508,3;21 ($81A2) = HL;
@nowarn
 C$E50B,3;21 HL = mask_buffer;
 C$E50E,2
 C$E510,1;21 {L += D * 4 + (IY[26] & 7) * 4;
 C$E511,12;21
 C$E51D,1;21 }
 C$E51E,3;21 foreground_mask_pointer = HL;
 C$E521,1
 C$E522,1;21 A = D;
 C$E523,1;21 {if (A) <%
 C$E524,2;21 }
; Generic multiply loop.
 C$E526,1;21 D = A;
 C$E527,1;21 A = 0;
 C$E528,3;21 {  E = IY[30] - 1;
 C$E52B,1;21 }
; D ends up as zero either way.
*C$E52C,1;21 {  do <% A += E; %> while (--D); %>
 C$E52D,1;21
 C$E52E,3;21 }
*C$E531,1;21 E = A;
 C$E532,3;21 {bitmap_pointer += DE;
 C$E535,1;21
 C$E536,3;21 }
 C$E539,3;21 {mask_pointer += DE;
 C$E53C,1;21
 C$E53D,3;21 }
 C$E540,1
 C$E541,1;21 return; /* visible */

; Scale down a pos_t and assign result to a tinypos_t.
;
; Used by the routines at #R$7BB5, #R$9F21, #R$C5D3, #R$C918 and #R$CC37.
; .
; Divides the three input 16-bit words by 8, with rounding to nearest, storing
; the result as bytes.
;
; I:HL Pointer to input words.
; I:DE Pointer to output bytes.
; O:HL Updated.
; O:DE Updated.
@label=pos_to_tinypos
cC$E542,2;21 B = 3;
*C$E544,1;21 {do <% A = *HL++;
 C$E545,1;21 }
 C$E546,1;21 C = *HL++;
 C$E547,3;21 divide_by_8_with_rounding(C,A);
 C$E54A,1;21 {  *DE++ = A;
 C$E54B,1;21
 C$E54C,1;21 }
 C$E54D,2;21 %> while (--B);
 C$E54F,1;21 return;

; Divide AC by 8, with rounding to nearest.
;
; Used by the routines at #R$7BF2, #R$C47E, #R$E420 and #R$E542.
;
; I:A Low.
; I:C High.
; O:A Result.
@label=divide_by_8_with_rounding
cC$E550,2;21 A += 4;
 C$E552,2;21 {if (carry) C++;
 C$E554,1;21 }
; FALL THROUGH into divide_by_8.

; Divide AC by 8.
;
; Used by the routines at #R$B2FC, #R$C47E, #R$E420 and #R$E550.
@label=divide_by_8
cC$E555,2;21 {A = (A >> 3) | (C << 5); C >>= 3;
 C$E557,6;21
 C$E55D,1;21 }
 C$E55E,1;21 return;

; Masks
;
; Mask encoding: A top-bit-set byte indicates a repetition, the count of which
; is in the bottom seven bits. The subsequent byte is the value to repeat.
; .
; { byte count+flags; ... }
@label=masks
@label=exterior_mask_0
bB$E55F,8;44 {exterior_mask_0
 B$E567,8*18
 B$E5F7,8;44 }
@label=exterior_mask_1
 B$E5FF,8;44 {exterior_mask_1
 B$E607,8*2
 B$E617,7;44 }
@label=exterior_mask_2
 B$E61E,8;44 {exterior_mask_2
 B$E626,8*20
 B$E6C6,4;44 }
@label=exterior_mask_3
 B$E6CA,8;44 {exterior_mask_3
 B$E6D2,8*15
 B$E74A,1;44 }
@label=exterior_mask_4
 B$E74B,8;44 {exterior_mask_4
 B$E753,5;44 }
@label=exterior_mask_5
 B$E758,8;44 {exterior_mask_5
 B$E760,8*3
 B$E778,7;44 }
@label=exterior_mask_6
 B$E77F,8;44 {exterior_mask_6
 B$E787,8
 B$E78F,7;44 }
@label=exterior_mask_7
 B$E796,8;44 {exterior_mask_7
 B$E79E,8*2
 B$E7AE,1;44 }
@label=exterior_mask_8
 B$E7AF,8;44 {exterior_mask_8
 B$E7B7,8*20
 B$E857,5;44 }
@label=exterior_mask_9
 B$E85C,8;44 {exterior_mask_9
 B$E864,8*7
 B$E89C,7;44 }
@label=exterior_mask_10
 B$E8A3,8;44 {exterior_mask_10
 B$E8AB,8*8
 B$E8EB,5;44 }
@label=exterior_mask_11
 B$E8F0,8;44 {exterior_mask_11
 B$E8F8,8*6
 B$E928,7;44 }
@label=exterior_mask_12
 B$E92F,8;44 {exterior_mask_12
 B$E937,8
 B$E93F,1;44 }
@label=exterior_mask_13
 B$E940,8;44 {exterior_mask_13
 B$E948,8*5
 B$E970,2;44 }
@label=exterior_mask_14
 B$E972,8;44 {exterior_mask_14
 B$E97A,8*3
 B$E992,8;44 }
@label=interior_mask_15
 B$E99A,5;44 interior_mask_15
@label=interior_mask_16
 B$E99F,8;44 {interior_mask_16
 B$E9A7,8*2
 B$E9B7,2;44 }
@label=interior_mask_17
 B$E9B9,8;44 {interior_mask_17
 B$E9C1,5;44 }
@label=interior_mask_18
 B$E9C6,5;44 interior_mask_18
@label=interior_mask_19
 B$E9CB,8;44 {interior_mask_19
 B$E9D3,8*2
 B$E9E3,3;44 }
@label=interior_mask_20
 B$E9E6,8;44 {interior_mask_20
 B$E9EE,7;44 }
@label=interior_mask_21
 B$E9F5,8;44 {interior_mask_21
 B$E9FD,8*2
 B$EA0D,1;44 }
@label=interior_mask_22
 B$EA0E,8;44 {interior_mask_22
 B$EA16,8*2
 B$EA26,5;44 }
@label=interior_mask_23
 B$EA2B,8;44 {interior_mask_23
 B$EA33,2;44 }
@label=interior_mask_24
 B$EA35,8;44 {interior_mask_24
 B$EA3D,6;44 }
@label=interior_mask_25
 B$EA43,7;44 interior_mask_25
@label=interior_mask_26
 B$EA4A,8;44 {interior_mask_26
 B$EA52,1;44 }
@label=interior_mask_27
 B$EA53,8;44 {interior_mask_27
 B$EA5B,2;44 }
@label=interior_mask_28
 B$EA5D,8;44 {interior_mask_28
 B$EA65,2;44 }
@label=interior_mask_29
 B$EA67,8;44 {interior_mask_29
 B$EA6F,8
 B$EA77,5;44 }

; Interior masking data.
;
; Used only by setup_room.
; .
; 47 mask structs with the constant final height byte omitted.
; .
; Copied to $81DB by setup_room.
@label=interior_mask_data_source
bB$EA7C,7;40 $1B, { $7B, $7F, $F1, $F3 }, { $36, $28 }
 B$EA83,7;40 $1B, { $77, $7B, $F3, $F5 }, { $36, $18 }
 B$EA8A,7;40 $1B, { $7C, $80, $F1, $F3 }, { $32, $2A }
 B$EA91,7;40 $19, { $83, $86, $F2, $F7 }, { $18, $24 }
 B$EA98,7;40 $19, { $81, $84, $F4, $F9 }, { $18, $1A }
 B$EA9F,7;40 $19, { $81, $84, $F3, $F8 }, { $1C, $17 }
 B$EAA6,7;40 $19, { $83, $86, $F4, $F8 }, { $16, $20 }
 B$EAAD,7;40 $18, { $7D, $80, $F4, $F9 }, { $18, $1A }
 B$EAB4,7;40 $18, { $7B, $7E, $F3, $F8 }, { $22, $1A }
 B$EABB,7;40 $18, { $79, $7C, $F4, $F9 }, { $22, $10 }
 B$EAC2,7;40 $18, { $7B, $7E, $F4, $F9 }, { $1C, $17 }
 B$EAC9,7;40 $18, { $79, $7C, $F1, $F6 }, { $2C, $1E }
 B$EAD0,7;40 $18, { $7D, $80, $F2, $F7 }, { $24, $22 }
 B$EAD7,7;40 $1D, { $7F, $82, $F6, $F7 }, { $1C, $1E }
 B$EADE,7;40 $1D, { $82, $85, $F2, $F3 }, { $23, $30 }
 B$EAE5,7;40 $1D, { $86, $89, $F2, $F3 }, { $1C, $37 }
 B$EAEC,7;40 $1D, { $86, $89, $F4, $F5 }, { $18, $30 }
 B$EAF3,7;40 $1D, { $80, $83, $F1, $F2 }, { $28, $30 }
 B$EAFA,7;40 $1C, { $81, $82, $F4, $F6 }, { $1C, $20 }
 B$EB01,7;40 $1C, { $83, $84, $F4, $F6 }, { $1C, $2E }
 B$EB08,7;40 $1A, { $7E, $80, $F5, $F7 }, { $1C, $20 }
 B$EB0F,7;40 $12, { $7A, $7B, $F2, $F3 }, { $3A, $28 }
 B$EB16,7;40 $12, { $7A, $7B, $EF, $F0 }, { $45, $35 }
 B$EB1D,7;40 $17, { $80, $85, $F4, $F6 }, { $1C, $24 }
 B$EB24,7;40 $14, { $80, $84, $F3, $F5 }, { $26, $28 }
 B$EB2B,7;40 $15, { $84, $85, $F6, $F7 }, { $1A, $1E }
 B$EB32,7;40 $15, { $7E, $7F, $F3, $F4 }, { $2E, $26 }
 B$EB39,7;40 $16, { $7C, $85, $EF, $F3 }, { $32, $22 }
 B$EB40,7;40 $16, { $79, $82, $F0, $F4 }, { $34, $1A }
 B$EB47,7;40 $16, { $7D, $86, $F2, $F6 }, { $24, $1A }
 B$EB4E,7;40 $10, { $76, $78, $F5, $F7 }, { $36, $0A }
 B$EB55,7;40 $10, { $7A, $7C, $F3, $F5 }, { $36, $0A }
 B$EB5C,7;40 $10, { $7E, $80, $F1, $F3 }, { $36, $0A }
 B$EB63,7;40 $10, { $82, $84, $EF, $F1 }, { $36, $0A }
 B$EB6A,7;40 $10, { $86, $88, $ED, $EF }, { $36, $0A }
 B$EB71,7;40 $10, { $8A, $8C, $EB, $ED }, { $36, $0A }
 B$EB78,7;40 $11, { $73, $75, $EB, $ED }, { $0A, $30 }
 B$EB7F,7;40 $11, { $77, $79, $ED, $EF }, { $0A, $30 }
 B$EB86,7;40 $11, { $7B, $7D, $EF, $F1 }, { $0A, $30 }
 B$EB8D,7;40 $11, { $7F, $81, $F1, $F3 }, { $0A, $30 }
 B$EB94,7;40 $11, { $83, $85, $F3, $F5 }, { $0A, $30 }
 B$EB9B,7;40 $11, { $87, $89, $F5, $F7 }, { $0A, $30 }
 B$EBA2,7;40 $10, { $84, $86, $F4, $F7 }, { $0A, $30 }
 B$EBA9,7;40 $11, { $87, $89, $ED, $EF }, { $0A, $30 }
 B$EBB0,7;40 $11, { $7B, $7D, $F3, $F5 }, { $0A, $0A }
 B$EBB7,7;40 $11, { $79, $7B, $F4, $F6 }, { $0A, $0A }
 B$EBBE,7;40 $0F, { $88, $8C, $F5, $F8 }, { $0A, $0A }

; Pointers to run-length encoded mask data.
;
; The first half is outdoor masks, the second is indoor masks.
;
; 30 pointers to byte arrays.
@label=mask_pointers
wW$EBC5,2;18 exterior_mask
 W$EBC7,2;18 exterior_mask
 W$EBC9,2;18 exterior_mask
 W$EBCB,2;18 exterior_mask
 W$EBCD,2;18 exterior_mask
 W$EBCF,2;18 exterior_mask
 W$EBD1,2;18 exterior_mask
 W$EBD3,2;18 exterior_mask
 W$EBD5,2;18 exterior_mask
 W$EBD7,2;18 exterior_mask
 W$EBD9,2;18 exterior_mask
 W$EBDB,2;18 exterior_mask
 W$EBDD,2;18 exterior_mask
 W$EBDF,2;18 exterior_mask
 W$EBE1,2;18 exterior_mask
;
 W$EBE3,2;18 interior_mask
 W$EBE5,2;18 interior_mask
 W$EBE7,2;18 interior_mask
 W$EBE9,2;18 interior_mask
 W$EBEB,2;18 interior_mask
 W$EBED,2;18 interior_mask
 W$EBEF,2;18 interior_mask
 W$EBF1,2;18 interior_mask
 W$EBF3,2;18 interior_mask
 W$EBF5,2;18 interior_mask
 W$EBF7,2;18 interior_mask
 W$EBF9,2;18 interior_mask
 W$EBFB,2;18 interior_mask
 W$EBFD,2;18 interior_mask
 W$EBFF,2;18 interior_mask

; mask_t structs for the exterior scene.
;
; 58 mask_t structs.
; .
; Used by render_mask_buffer. Used in outdoor mode only.
@label=exterior_mask_data
bB$EC01,8*58

; Saved stack pointer.
;
; Used by plot_game_window and wipe_game_window.
@label=saved_sp
gW$EDD1,2

; Game screen start addresses.
;
; 128 screen pointers.
@label=game_window_start_addresses
wW$EDD3,2*128

; Plot the game screen.
;
; Used by the routines at #R$9D7B and #R$A50B.
@label=plot_game_window
cC$EED3,4;21 saved_sp = SP;
 C$EED7,3;21 A = *(&game_window_offset + 1);
 C$EEDA,1;21 {if (A) goto unaligned;
 C$EEDB,3;21 }
@nowarn
 C$EEDE,3;21 {HL = $F291 + game_window_offset;
 C$EEE1,7;21
*C$EEE8,1;21 }
 C$EEE9,3;21 SP = game_window_start_addresses;
 C$EEEC,2;21 A = 128; // 128 rows
*C$EEEE,1;21 do <% DE = *SP++; // output address
 C$EEEF,2;21 *DE++ = *HL++; /* unrolled: 23 copies */
 C$EEF1,2;21 *DE++ = *HL++;
 C$EEF3,2;21 *DE++ = *HL++;
 C$EEF5,2;21 *DE++ = *HL++;
 C$EEF7,2;21 *DE++ = *HL++;
 C$EEF9,2;21 *DE++ = *HL++;
 C$EEFB,2;21 *DE++ = *HL++;
 C$EEFD,2;21 *DE++ = *HL++;
 C$EEFF,2;21 *DE++ = *HL++;
 C$EF01,2;21 *DE++ = *HL++;
 C$EF03,2;21 *DE++ = *HL++;
 C$EF05,2;21 *DE++ = *HL++;
 C$EF07,2;21 *DE++ = *HL++;
 C$EF09,2;21 *DE++ = *HL++;
 C$EF0B,2;21 *DE++ = *HL++;
 C$EF0D,2;21 *DE++ = *HL++;
 C$EF0F,2;21 *DE++ = *HL++;
 C$EF11,2;21 *DE++ = *HL++;
 C$EF13,2;21 *DE++ = *HL++;
 C$EF15,2;21 *DE++ = *HL++;
 C$EF17,2;21 *DE++ = *HL++;
 C$EF19,2;21 *DE++ = *HL++;
 C$EF1B,2;21 *DE++ = *HL++;
 C$EF1D,1;21 HL++; // skip 24th
 C$EF1E,1;21 {%> while (--A);
 C$EF1F,3;21 }
 C$EF22,4;21 SP = saved_sp;
 C$EF26,1;21 return;
*C$EF27,3;21 {unaligned: HL = $F290 + game_window_offset; // screen buffer start address
 C$EF2A,7;21
*C$EF31,1;21 }
 C$EF32,1;21 {A = *HL++; // prime A
 C$EF33,1;21 }
 C$EF34,3;21 SP = game_window_start_addresses;
 C$EF37,1;21 {Bdash = 128; // 128 rows
 C$EF38,2;21 }
*C$EF3A,1;21 do <%
 C$EF3B,1;21 // output address
 C$EF3C,2;21 B = 4; // 4 iterations of 5 plus 3 at the end == 23
*C$EF3E,1;21 do <% C = *HL;
 C$EF3F,2;21 RRD does this: tmp = *HL & 0x0F; *HL = (*HL >> 4) | (A << 4); A = (A & 0xF0) | tmp;
 C$EF41,1;21
 C$EF42,1;21 Adash = *HL;
 C$EF43,1;21 *DE++ = Adash;
 C$EF44,1;21 {    *HL++ = C;
 C$EF45,1
 C$EF46,1;21
 C$EF47,1;21 }
 C$EF48,1;21 C = *HL;
 C$EF49,2;21 {    RRD
 C$EF4B,1;21 }
 C$EF4C,1;21 Adash = *HL;
 C$EF4D,1;21 *DE++ = Adash;
 C$EF4E,1;21 {    *HL++ = C;
 C$EF4F,1
 C$EF50,1;21
 C$EF51,1;21 }
 C$EF52,1;21 C = *HL;
 C$EF53,2;21 {    RRD
 C$EF55,1;21 }
 C$EF56,1;21 Adash = *HL;
 C$EF57,1;21 *DE++ = Adash;
 C$EF58,1;21 {    *HL++ = C;
 C$EF59,1
 C$EF5A,1;21
 C$EF5B,1;21 }
 C$EF5C,1;21 C = *HL;
 C$EF5D,2;21 {    RRD
 C$EF5F,1;21 }
 C$EF60,1;21 Adash = *HL;
 C$EF61,1;21 *DE++ = Adash;
 C$EF62,1;21 {    *HL++ = C;
 C$EF63,1
 C$EF64,1;21
 C$EF65,1;21 }
 C$EF66,1;21 C = *HL;
 C$EF67,2;21 {    RRD
 C$EF69,1;21 }
 C$EF6A,1;21 Adash = *HL;
 C$EF6B,1;21 *DE++ = Adash;
 C$EF6C,1;21 {    *HL++ = C;
 C$EF6D,1
 C$EF6E,1;21
 C$EF6F,1;21 }
 C$EF70,2;21 %> while (--B);
 C$EF72,1;21 C = *HL;
 C$EF73,2;21 {  RRD
 C$EF75,1;21 }
 C$EF76,1;21 Adash = *HL;
 C$EF77,1;21 *DE++ = Adash;
 C$EF78,1;21 {  *HL++ = C;
 C$EF79,1
 C$EF7A,1;21
 C$EF7B,1;21 }
 C$EF7C,1;21 C = *HL;
 C$EF7D,2;21 {  RRD
 C$EF7F,1;21 }
 C$EF80,1;21 Adash = *HL;
 C$EF81,1;21 *DE++ = Adash;
 C$EF82,1;21 {  *HL++ = C;
 C$EF83,1
 C$EF84,1;21
 C$EF85,1;21 }
 C$EF86,1;21 C = *HL;
 C$EF87,2;21 {  RRD
 C$EF89,1;21 }
 C$EF8A,1;21 Adash = *HL;
 C$EF8B,1;21 *DE++ = Adash;
 C$EF8C,1;21 {  *HL++ = C;
 C$EF8D,1
 C$EF8E,1;21
 C$EF8F,1;21 }
 C$EF90,1;21 {  A = *HL++;
 C$EF91,1;21
 C$EF92,1;21 }
 C$EF93,2;21 %> while (--Bdash);
 C$EF95,4;21 SP = saved_sp;
 C$EF99,1;21 return;

; Event: roll call.
;
; Range checking. X in (0x72..0x7C) and Y in (0x6A..0x72).
;
; .
;
; Is the hero within the roll call area bounds?
@label=event_roll_call
@keep
cC$EF9A,3;21 DE = map_ROLL_CALL_X;
 C$EF9D,3;21 HL = &hero_map_position.x;
 C$EFA0,2;21 B = 2; // iterations
*C$EFA2,1;21 do <% A = *HL++;
 C$EFA3,1;21 {  if (A < D || A >= E) goto not_at_roll_call;
 C$EFA4,5;21
 C$EFA9,1;21 }
@keep
 C$EFAA,3;21 DE = map_ROLL_CALL_Y;
 C$EFAD,2;21 %> while (--B);
; All visible characters turn forward.
@nowarn
 C$EFAF,3;21 HL = $800D;
 C$EFB2,2;21 B = 8; // iterations
*C$EFB4,2;21 {do <% *HL++ = input_KICK;
 C$EFB6,1;21 }
 C$EFB7,2;21 *HL = 0x03; // direction (3 => face bottom left)
 C$EFB9,1;21 {  HL += 31;
 C$EFBA,2;21
 C$EFBC,1;21 }
 C$EFBD,2;21 %> while (--B);
 C$EFBF,1;21 return;
*C$EFC0,1;21 {not_at_roll_call: bell = bell_RING_PERPETUAL;
 C$EFC1,3;21 }
 C$EFC4,1;21 {queue_message(message_MISSED_ROLL_CALL);
 C$EFC5,3;21 }
 C$EFC8,3;21 hostiles_pursue(); // exit via

; Use papers.
;
; Is the hero within the main gate bounds?
; .
; Range checking. X in (0x69..0x6D) and Y in (0x49..0x4B).
@label=action_papers
@keep
cC$EFCB,3;24 DE = map_MAIN_GATE_X;
 C$EFCE,3;24 HL = &hero_map_position.y;
 C$EFD1,2;24 B = 2; // iterations
*C$EFD3,1;24 do <% A = *HL++;
 C$EFD4,1;24 {  if (A < D || A >= E) return;
 C$EFD5,3;24
 C$EFD8,1;24 }
@keep
 C$EFD9,3;24 DE = map_MAIN_GATE_Y;
 C$EFDC,2;24 %> while (--B);
; Using the papers at the main gate when not in uniform causes the hero to be
; sent to solitary.
 C$EFDE,3;24 {if ($8015 != sprite_guard) goto solitary; // exit via
 C$EFE1,4;24
 C$EFE5,3;24 }
 C$EFE8,3;24 increase_morale_by_10_score_by_50();
 C$EFEB,1;24 {$801C = room_0_OUTDOORS; // set room index
 C$EFEC,3;24 }
; Transition to outside the main gate.
@nowarn
 C$EFEF,3;24 HL = &outside_main_gate; // pointer to location
 C$EFF2,4;24 IY = $8000; // hero character
 C$EFF6,3;24 transition(); return; // doesn't return: exits with goto main_loop
; Position outside the main gate.
@label=outside_main_gate
 B$EFF9,3;24 static const tinypos_t outside_main_gate = <% 0xD6, 0x8A, 0x06 %>;

; Wait for the user to press 'Y' or 'N'.
;
; Used by the routines at #R$9DE5 and #R$F350.
;
; O:F 'Y'/'N' pressed => return Z/NZ
@label=user_confirm
cC$EFFC,3;21 HL = &screenlocstring_confirm_y_or_n[0];
 C$EFFF,3;21 screenlocstring_plot();
*C$F002,3;21 for (;;) <% BC = port_KEYBOARD_POIUY;
 C$F005,2;21
 C$F007,2;21 {  if ((A & (1<<4)) == 0) return; // is 'Y' pressed? return Z
 C$F009,1;21 }
 C$F00A,2;21 BC = port_KEYBOARD_SPACESYMSHFTMNB;
 C$F00C,2;21
 C$F00E,1;21 A = ~A;
 C$F00F,2;21 {  if ((A & (1<<3)) != 0) return; // is 'N' pressed? return NZ
 C$F011,1;21 }
 C$F012,2;21 %>

; Confirm query.
tB$F014,18;84 "CONFIRM. Y OR N" #HTML[/ #CALL:decode_screenlocstring($F014)]

; Further game messages.
@label=more_messages_he_takes_the_bribe
tB$F026,19;88 "HE TAKES THE BRIBE" #HTML[/ #CALL:decode_stringFF($F026)]
@label=more_messages_and_acts_as_decoy
 B$F039,18;88 "AND ACTS AS DECOY" #HTML[/ #CALL:decode_stringFF($F039)]
@label=more_messages_another_day_dawns
 B$F04B,18;88 "ANOTHER DAY DAWNS" #HTML[/ #CALL:decode_stringFF($F04B)]

; Locked gates and doors.
@label=locked_doors
bB$F05D,2;40 gates
 B$F05F,7;40 doors
 B$F066,2;40 unused

; Jump to main.
;
; Used by the routine at #R$FDE1.
@label=jump_to_main
cC$F068,3;21

; User-defined keys.
;
; Pairs of (port, key mask).
@label=keydefs
gB$F06B,10


; Everything from $F0F8 onwards is potentially overwritten by the game once the main menu is exited.
;
; Memory Map
; ----------
; $F0F8..$F28F - 24x17 = 408 bytes of tile_buf
; $F290..$FF4F - 24x17x8 = 3,264 bytes of window_buf
; $FF50..$FF57 - seems to be an extra UDG's worth of window_buf to allow overspills
; $FF58..$FF7A - 7x5 = 35 bytes of map_buf
; $FF80..$FFFF - the stack


; Static tiles plot direction.
;
; #TABLE(default,centre)
; { =h Value | =h Meaning }
; { 0 | Horizontal }
; { 255 | Vertical }
; TABLE#
@label=static_tiles_plot_direction
gB$F075,1

; Definitions of fixed graphic elements.
;
; Only used by #R$F1E0.
; .
; struct: w(addr), flags+length, attrs[length]
@label=static_graphic_defs
@label=statics_flagpole
bB$F076,23
@label=statics_game_window_left_border
 B$F08D,23
@label=statics_game_window_right_border
 B$F0A4,23
@label=statics_game_window_top_border
 B$F0BB,26
@label=statics_game_window_bottom
 B$F0D5,26
@label=statics_flagpole_grass
 B$F0EF,8
@label=statics_medals_row0
 B$F0F7,16
@label=statics_medals_row1
 B$F107,14
@label=statics_medals_row2
 B$F115,14
@label=statics_medals_row3
 B$F123,14
@label=statics_medals_row4
 B$F131,13
@label=statics_bell_row0
 B$F13E,6
@label=statics_bell_row1
 B$F144,6
@label=statics_bell_row2
 B$F14A,5
@label=statics_corner_tl
 B$F14F,5
@label=statics_corner_tr
 B$F154,5
@label=statics_corner_bl
 B$F159,5
@label=statics_corner_br
 B$F15E,5

; The game starts here.
;
; Used by the routine at #R$F068.
@label=main
cC$F163,1;30 Disable interrupts.
 C$F164,3;30 Set up stack pointer. Why is this $FFFE when squash_stack_goto_main sets it to $FFFF?
; Set up screen.
 C$F167,3;30 wipe_full_screen_and_attributes();
 C$F16A,2;30 {set_morale_flag_screen_attributes(attribute_BRIGHT_GREEN_OVER_BLACK);
 C$F16C,3;30 }
 C$F16F,2;30 {set_menu_item_attributes(attribute_BRIGHT_YELLOW_OVER_BLACK);
 C$F171,3;30 }
 C$F174,3;30 plot_statics_and_menu_text();
 C$F177,3;30 plot_score();
 C$F17A,3;30 menu_screen();
; Construct a table of 256 bit-reversed bytes at 0x7F00.
 C$F17D,3;30 HL = 0x7F00;
*C$F180,1;30 do <% A = L;
 C$F181,2;30 C = 0;
 C$F183,2;30 B = 8; // iterations
*C$F185,1;30 do <% carry = A & 1; A >>= 1; // flips a byte
 C$F186,2;30 C = (C << 1) | carry;
 C$F188,2;30 %> while (--B);
 C$F18A,1;30 {  *HL++ = C;
 C$F18B,1;30
 C$F18C,3;30 }
 C$F18F,1;30 %> while ((HL & 0xFF) != 0);
; Initialise visible characters (HL is $8000).
@nowarn
 C$F190,3;30 DE = &vischar_initial;
 C$F193,2;30 B = 8; // iterations
*C$F195,1;30 do <%
 C$F196,1;30 {
 C$F197,1;30 }
 C$F198,3;30 {  memcpy(HL, DE, 23);
 C$F19B,1
 C$F19C,2;30 }
 C$F19E,1
 C$F19F,2;30 {  HL += 32;
 C$F1A1,1;30
 C$F1A2,1;30 }
 C$F1A3,1
 C$F1A4,1;30 {%> while (--B);
 C$F1A5,2;30 }
; Write 0xFF 0xFF at 0x8020 and every 32 bytes after.
 C$F1A7,2;30 B = 7; // iterations
@nowarn
 C$F1A9,3;30 HL = 0x8020; // iterate over non-player characters
 C$F1AC,5
*C$F1B1,1;30 {do <% HL[0] = character_NONE;
 C$F1B2,1;30 }
 C$F1B3,1;30 HL[1] = 0xFF; // flags
 C$F1B4,1;30 HL += 32;
 C$F1B5,2;30 %> while (--B);
; Zero 0x118 bytes at HL (== $8100 == mask_buffer) onwards.
; .
; This is likely wiping everything up until the start of tiles ($8218).
 C$F1B7,3;30 BC = 0x118;
*C$F1BA,2;30 {do <% *HL++ = 0; %> while (--BC != 0); // turn into memset
 C$F1BC,4;30
 C$F1C0,3;30 }
 C$F1C3,3;30 reset_game();
 C$F1C6,3;30 goto main_loop_setup;
; Initial state of a visible character.
@label=vischar_initial
 B$F1C9,1;30 character
 B$F1CA,1;30 flags
 W$F1CB,2;30 route
 B$F1CD,3;30 pos
 B$F1D0,1;30 b07
 W$F1D1,2;30 w08
 W$F1D3,2;30 w0A
 B$F1D5,1;30 animindex
 B$F1D6,1;30 b0D
 B$F1D7,1;30 b0E
 W$F1D8,6;30 mi.pos
 W$F1DE,2;30 mi.spriteset

; Plot statics and menu text.
;
; Used by the routine at #R$F163.
@label=plot_statics_and_menu_text
cC$F1E0,3;21 HL = &static_graphic_defs[0];
 C$F1E3,2;21 B = NELEMS(static_graphic_defs); // 18 iterations
*C$F1E5,1;21 do <%
; Fetch screen address.
 C$F1E6,1;21 {  E = *HL++;
 C$F1E7,1;21 }
 C$F1E8,1;21 {  D = *HL++;
 C$F1E9,1;21 }
 C$F1EA,2;21 {  if (*HL & statictiles_VERTICAL)
 C$F1EC,2;21 }
 C$F1EE,3;21 plot_static_tiles_vertical();
 C$F1F1,2;21 else
*C$F1F3,3;21 plot_static_tiles_horizontal();
*C$F1F6,1
 C$F1F7,2;21 %> while (--B);
; Plot menu text.
 C$F1F9,2;21 B = 8; // 8 iterations
 C$F1FB,3;21 HL = &key_choice_screenlocstrings;
*C$F1FE,1;21 do <%
 C$F1FF,3;21 screenlocstring_plot();
 C$F202,1
 C$F203,2;21 %> while (--B);
 C$F205,1;21 return;

; Plot static tiles horizontally.
;
; Used by the routine at #R$F1E0.
;
; I:DE Pointer to screen address.
; I:HL Pointer to [count, tile indices, ...].
@label=plot_static_tiles_horizontal
cC$F206,1;21 A = 0;
 C$F207,2;21 goto plot_static_tiles;

; Plot static tiles vertically.
;
; Used by the routine at #R$F1E0.
;
; I:DE Pointer to screen address.
; I:HL Pointer to [count, tile indices, ...].
; I:HL Pointer to [count, tile indices, ...].
; I:A Orientation: 0/255 = horizontal/vertical.
@label=plot_static_tiles_vertical
cC$F209,2;21 A = 255;

; Plot static tiles.
;
; Used by the routine at #R$F206.
;
; I:DE Pointer to screen address.
@label=plot_static_tiles
cC$F20B,3;21 static_tiles_plot_direction = A;
 C$F20E,1;21 {B = *HL++ & statictiles_COUNT_MASK; // loop iterations
 C$F20F,3;21
 C$F212,1;21 }
 C$F213,2
 C$F215,1;21 POP DEdash
 C$F216,1
*C$F217,1;21 do <% A = *HL;
 C$F218,1
 C$F219,1;21 {  HLdash = &static_tiles[A]; // elements: 9 bytes each
 C$F21A,12;21
 C$F226,1;21 }
 C$F227,2;21 Bdash = 8; // 8 iterations
; Plot a tile.
*C$F229,1;21 {  do <% *DEdash = *HLdash++;
 C$F22A,1;21 }
 C$F22B,1;21 {    DEdash += 256; // next row
 C$F22C,1;21 }
 C$F22D,2;21 %> while (--Bdash);
 C$F22F,1;21 DEdash -= 256;
 C$F230,1;21 PUSH DEdash
; Calculate screen attribute address of tile.
 C$F231,1;21 A = Ddash;
 C$F232,2;21 Ddash = 0x58; // screen attributes base
 C$F234,2;21 {  if (A >= 0x48) DEdash += 256;
 C$F236,2;21
 C$F238,1;21 }
 C$F239,2;21 {  if (A >= 0x50) DEdash += 256;
 C$F23B,2;21
 C$F23D,1;21 }
*C$F23E,1;21 {  *DEdash = *HLdash; // copy attribute byte
 C$F23F,1;21 }
 C$F240,1;21 POP HLdash
 C$F241,3;21 A = static_tiles_plot_direction;
 C$F244,1;21 {  if (A == 0) <% // horizontal
 C$F245,2;21 }
 C$F247,1;21 {    Hdash -= 7;  // HLdash -= 7 * 256;
 C$F248,2;21
 C$F24A,1;21 }
 C$F24B,1;21 Ldash++; %>
 C$F24C,2;21 else <% // vertical
*C$F24E,3;21 next_scanline_down(); %>
*C$F251,1;21 EX DEdash,HLdash
 C$F252,1
 C$F253,1;21 HL++;
 C$F254,2;21 %> while (--B);
 C$F256,1;21 return;

; Clear the screen and attributes and set the screen border to black.
;
; Used by the routine at #R$F163.
@label=wipe_full_screen_and_attributes
cC$F257,3;21 {memset(screen, 0, 0x1800);
 C$F25A,10;21
 C$F264,1;21 }
 C$F265,1;21 {memset(atttributes, attribute_WHITE_OVER_BLACK, 0x300);
 C$F266,5;21
 C$F26B,2;21 }
 C$F26D,1;21 {border = 0; // black
 C$F26E,2;21 }
 C$F270,1;21 return;

; Menu screen key handling.
;
; Used by the routine at #R$F4B7.
; .
; Scan for a keypress which either starts the game or selects an input device.
; If an input device is chosen, update the menu highlight to match and record
; which input device was chosen.
; .
; If the game is started then copy the input routine to $F075. If the chosen
; input device is keyboard, then exit via choose_keys.
@label=check_menu_keys
cC$F271,3;21 A = menu_keyscan();
 C$F274,2;21 {if (A == 0xFF) return; /* no keypress */
 C$F276,1;21 }
 C$F277,1;21 {if (A) <%
 C$F278,2;21 }
 C$F27A,1;21 A--; // 1..4 -> 0..3
; Clear old selection.
 C$F27B,1
 C$F27C,3;21 A = chosen_input_device;
 C$F27F,2;21 {
 C$F281,3;21 set_menu_item_attributes(attribute_WHITE_OVER_BLACK);}
 C$F284,1
; Highlight new selection.
 C$F285,3;21 chosen_input_device = A;
 C$F288,2;21 {
 C$F28A,3;21 set_menu_item_attributes(attribute_BRIGHT_YELLOW_OVER_BLACK);}
 C$F28D,1;21 return; %>
; Zero pressed to start game.
*C$F28E,3;21 {else <% A = chosen_input_device;
 C$F291,1;21 }
; This is tricky. A' is left with the low byte of the inputroutine address. In
; the case of the keyboard, it's zero. choose_keys relies on that in a
; nonobvious way.
 C$F292,1;21 {  memcpy($F075, inputroutine[A], 0x4A); // copy input routine to $F075, length 0x4A
 C$F293,2;21
 C$F295,1
 C$F296,16;21
 C$F2A6,1;21 }
 C$F2A7,1;21 {  if (A == inputdevice_KEYBOARD) { choose_keys(); }
 C$F2A8,3;21 }
 C$F2AB,1;21 /* Discard previous frame and resume at main:$F17D. */
 C$F2AC,1;21 return; %>

; Key choice prompt strings.
;
@label=define_key_prompts
tB$F2AD,12:T1:1;68 "CHOOSE KEYS" #HTML[/ #CALL:decode_screenlocstring($F2AD)]
 B$F2BB,7:T1;68 "LEFT." #HTML[/ #CALL:decode_screenlocstring($F2BB)]
 B$F2C3,8:T1;68 "RIGHT." #HTML[/ #CALL:decode_screenlocstring($F2C3)]
 B$F2CC,5:T1;68 "UP." #HTML[/ #CALL:decode_screenlocstring($F2CC)]
 B$F2D2,7:T1;68 "DOWN." #HTML[/ #CALL:decode_screenlocstring($F2D2)]
 B$F2DA,7;68 "FIRE." #HTML[/ #CALL:decode_screenlocstring($F2DA)]

; byte_F2E1
;
; Unsure if anything reads this byte for real, but its address is taken prior
; to accessing keyboard_port_hi_bytes.
; .
; (<- choose_keys)
@label=byte_F2E1
bB$F2E1,1

; Table of keyscan high bytes.
;
; Zero terminated.
; .
; (<- choose_keys)
@label=keyboard_port_hi_bytes
bB$F2E2,9

; Table of special key name strings, prefixed by their length.
;
@label=special_key_names
tB$F2EB,6;40 "ENTER" #HTML[/ #CALL:decode_stringcounted($F2EB)]
 B$F2F1,5;40 "CAPS" #HTML[/ #CALL:decode_stringcounted($F2F1)]
 B$F2F6,7;40 "SYMBOL" #HTML[/ #CALL:decode_stringcounted($F2F6)]
 B$F2FD,6;40 "SPACE" #HTML[/ #CALL:decode_stringcounted($F2FD)]

; Table mapping key codes to glyph indices.
;
; Each table entry is a character (in original code: a glyph index) OR if its
; top bit is set then bottom seven bits are an index into special_key_names.
@label=key_tables
bB$F303,5;32 table_12345
 B$F308,5;32 table_09876
 B$F30D,5;32 table_QWERT
 B$F312,5;32 table_POIUY
 B$F317,5;32 table_ASDFG
 B$F31C,5;32 table_ENTERLKJH
 B$F321,5;32 table_SHIFTZXCV
 B$F326,5;32 table_SPACESYMSHFTMNB

; Screen addresses where chosen key names are plotted.
@label=key_name_screen_addrs
wW$F32B,2*5

; Wipe the game screen.
;
; Used by the routine at #R$F350.
@label=wipe_game_window
cC$F335,1;21 DI
 C$F336,4;21 saved_sp = SP;
 C$F33A,3;21 sp = game_window_start_addresses;
 C$F33D,2;21 A = 128; // 128 rows
*C$F33F,1;21 do <% // start address
 C$F340,2;21 B = 23; // 23 columns
*C$F342,2;21 do <% *HL = 0;
 C$F344,1;21 HL++;
 C$F345,2;21 %> while (--B);
 C$F347,1;21 {%> while (--A);
 C$F348,3;21 }
 C$F34B,4;21 SP = saved_sp;
 C$F34F,1;21 return;

; Choose keys.
;
; Used by the routine at #R$F271.
;
; .
;
; Loop while the user does not confirm.
; .
; Clear the game window.
@label=choose_keys
cC$F350,3;21 for (;;) <% wipe_game_window();
 C$F353,2;21 {
 C$F355,3;21 set_game_window_attributes(attribute_WHITE_OVER_BLACK);}
; Draw key choice prompt strings.
 C$F358,2;21 B = 6; // iterations
 C$F35A,3;21 HL = &define_key_prompts[0];
*C$F35D,1;21 do <%
 C$F35E,1;21 {    E = *HL++;
 C$F35F,1;21 }
 C$F360,1;21 {    D = *HL++;
 C$F361,1;21 }
 C$F362,1;21 {    B = *HL++; // iterations
 C$F363,1;21 }
*C$F364,1;21 do <%
 C$F365,1;21 A = *HL; // redundant
 C$F366,3;21 plot_glyph();
 C$F369,1;21 HL++;
 C$F36A,1
 C$F36B,2;21 %> while (--B);
 C$F36D,1
 C$F36E,2;21 %> while (--B);
; Wipe keydefs.
 C$F370,3;21 HL = &keydefs[0];
 C$F373,2;21 B = 10; // iterations
 C$F375,1;21 A = 0;
*C$F376,1;21 {  do <% *HL++ = A;
 C$F377,1;21 }
 C$F378,2;21 %> while (--B);
 C$F37A,2;21 B = 5; // iterations L/R/U/D/F
 C$F37C,3;21 HL = &key_name_screen_addrs[0];
*C$F37F,1;21 do <%
 C$F380,1;21 {    E = *HL++;
 C$F381,1;21 }
 C$F382,1;21 {    D = *HL++;
 C$F383,1;21 }
 C$F384,1
 C$F385,4;21 ($F3E9) = DE; // self modify screen addr
 C$F389,2;21 A = 0xFF;
*C$F38B,1;21 for (;;) <%
 C$F38C,3;21 HL = &keyboard_port_hi_bytes[-1]; // &byte_F2E1
 C$F38F,2;21 D = 0xFF;
*C$F391,1;21 do <% HL++;
 C$F392,1;21 D++;
 C$F393,1;21 Adash = *HL;
 C$F394,1;21 {        if (Adash == 0) goto $F38B; // end of keyboard_port_hi_bytes
 C$F395,2;21 }
 C$F397,1;21 B = Adash;
 C$F398,2;21 C = 0xFE;
 C$F39A,2;21 IN Adash,(C)
 C$F39C,1;21 Adash = ~Adash;
 C$F39D,1;21 E = Adash;
 C$F39E,2;21 C = 0x20; // mask
*C$F3A0,2;21 C >>= 1;
 C$F3A2,2;21 %> while (carry);  // loop structure is not quite right
 C$F3A4,1;21 {      Adash = C & E;
 C$F3A5,1;21 }
 C$F3A6,2;21 if (Adash == 0) goto $F3A0;
 C$F3A8,1
 C$F3A9,1;21 {      if (A) goto $F38B;
 C$F3AA,2;21 }
 C$F3AC,1;21 A = D;
 C$F3AD,1
 C$F3AE,3;21 HL = 0xF06A;
*C$F3B1,1;21 HL++;
 C$F3B2,1;21 Adash = *HL;
 C$F3B3,1;21 {      if (Adash == 0) goto $F3C1;
 C$F3B4,2;21 }
 C$F3B6,1;21 if (A != B) ...
 C$F3B7,1;21 HL++; // interleaved
 C$F3B8,2;21 ... goto $F3B1;
 C$F3BA,1;21 Adash = *HL;
 C$F3BB,1;21 {      if (A != C) goto $F3B1;
 C$F3BC,2;21 }
 C$F3BE,3;21 %>
; Assign key def.
@label=assign_keydef
*C$F3C1,1;21 {    *HL++ = B;
 C$F3C2,1;21 }
 C$F3C3,1;21 *HL = C;
 C$F3C4,1
 C$F3C5,1;21 {    A *= 5;
 C$F3C6,2;21
 C$F3C8,1;21 }
@nowarn
 C$F3C9,3;21 HL = 0xF302;  // &key_tables[0] - 1 byte + A // strange: off by one
 C$F3CC,1;21 {    HL += A;
 C$F3CD,3;21
 C$F3D0,1;21 }
*C$F3D1,1;21 HL++;
 C$F3D2,2;21 RR C
 C$F3D4,2;21 JR NC,$F3D1
 C$F3D6,2;21 B = 1;
 C$F3D8,1;21 A = *HL;
 C$F3D9,1;21 A |= A;
 C$F3DA,3;21 JP P,$F3E8
; If the top bit was set then it's a modifier key.
 C$F3DD,2;21 A &= 0x7F;
 C$F3DF,3;21 {    HL = &special_key_names[0] + A;
 C$F3E2,3;21
 C$F3E5,1;21 }
 C$F3E6,1;21 {    B = *HL++;
 C$F3E7,1;21 }
; Plot.
*C$F3E8,3;21 DE = 0x40D5; // self modified // screen address
*C$F3EB,1;21 do <%
 C$F3EC,1;21 A = *HL; // Bug: Redundant.
 C$F3ED,3;21 plot_glyph();
 C$F3F0,1;21 HL++;
 C$F3F1,1
 C$F3F2,2;21 %> while (--B);
 C$F3F4,2
 C$F3F6,1;21 {  %> while (--B);
 C$F3F7,2;21 }
; Delay loop.
 C$F3F9,3;21 BC = 0xFFFF;
*C$F3FC,1;21 {  while (--BC);
 C$F3FD,2;21
 C$F3FF,2;21 }
; Wait for user's input.
 C$F401,3;21 user_confirm();
 C$F404,1;21 if (Z) return; // confirmed
 C$F405,3;21 %>

; Set the screen attributes of the specified menu item.
;
; Used by the routines at #R$F163 and #R$F271.
;
; I:A Item index.
; I:E Attributes.
@label=set_menu_item_attributes
cC$F408,3;21 HL = 0x590D; // initial screen attribute address
; Skip to the item's row.
 C$F40B,1;21 {if (A) <%
 C$F40C,2;21 }
 C$F40E,1;21 B = A;
*C$F40F,1;21 {  do <% L += 32 * 2; %> while (--B); %> // skip two rows per iteration
 C$F410,3;21
 C$F413,2;21 }
; Draw.
*C$F415,2;21 B = 10;
*C$F417,1;21 {do <% *HL++ = E; %> while (--B);
 C$F418,1;21
 C$F419,2;21 }
 C$F41B,1;21 return;

; Scan for keys to select an input device.
;
; Used by the routine at #R$F271.
;
; O:A 0/1/2/3/4 = keypress, or 255 = no keypress.
@label=menu_keyscan
cC$F41C,3;21 BC = port_KEYBOARD_12345;
 C$F41F,2;21 E = 0;
 C$F421,2;21
 C$F423,1;21 {A = ~A & 0x0F;
 C$F424,2;21 }
 C$F426,2;21 if (A) <%
 C$F428,2;21 B = 4; /* iterations */
*C$F42A,1;21 do <% A >>= 1;
 C$F42B,1;21 E++;
 C$F42C,2;21 if (carry) goto found;
 C$F42E,2;21 %> while (--B);
*C$F430,1;21 found: A = E;
 C$F431,1;21 return; %> /* 1..4 */
*C$F432,2;21 else <% B = 0xEF; /* port_KEYBOARD_09876 */
 C$F434,2;21
 C$F436,2;21 A &= 1;
 C$F438,1;21 A = E; /* interleaved */
 C$F439,1;21 if (Z) return; /* always zero */
 C$F43A,2;21 A = 0xFF; /* no keypress */
 C$F43C,1;21 return; %>

; Available input routines.
;
; Array [4] of pointers to input routines.
@label=inputroutines
wW$F43D,2;21 &inputroutine_keyboard,
 W$F43F,2;21 &inputroutine_kempston,
 W$F441,2;21 &inputroutine_sinclair,
 W$F443,2;21 &inputroutine_protek,

; Chosen input device.
;
; #TABLE(default,centre)
; { =h Value | =h Meaning }
; { 0 | Keyboard }
; { 1 | Kempston }
; { 2 | Sinclair }
; { 3 | Protek }
; TABLE#
@label=chosen_input_device
gB$F445,1

; Key choice screenlocstrings.
;
@label=key_choice_screenlocstrings
tB$F446,11;116 "CONTROLS" #HTML[/ #CALL:decode_screenlocstring($F446)]
 B$F451,11;116 "0 SELECT" #HTML[/ #CALL:decode_screenlocstring($F451)]
 B$F45C,13;116 "1 KEYBOARD" #HTML[/ #CALL:decode_screenlocstring($F45C)]
 B$F469,13;116 "2 KEMPSTON" #HTML[/ #CALL:decode_screenlocstring($F469)]
 B$F476,13;116 "3 SINCLAIR" #HTML[/ #CALL:decode_screenlocstring($F476)]
 B$F483,11;116 "4 PROTEK" #HTML[/ #CALL:decode_screenlocstring($F483)]
 B$F48E,26;116 "BREAK OR CAPS AND SPACE" #HTML[/ #CALL:decode_screenlocstring($F48E)]
 B$F4A8,15;116 "FOR NEW GAME" #HTML[/ #CALL:decode_screenlocstring($F4A8)]


; Runs the menu screen.
;
; Used by the routine at #R$F163.
; .
; While waiting for user to select an input device this waves the morale flag
; and plays the title tune.
@label=menu_screen
cC$F4B7,3;21 for (;;) <% check_menu_keys();
 C$F4BA,3;21 wave_morale_flag();
; Play music.
 C$F4BD,3;21 {  HL = music_channel0_index + 1;
 C$F4C0,1;21 }
; Loop until the end marker is encountered.
*C$F4C1,3;21 for (;;) <% music_channel0_index = HL;
 C$F4C4,3;21 {    A = music_channel0_data[HL];
 C$F4C7,1;21
 C$F4C8,1;21 }
 C$F4C9,2;21 {    if (A != 0xFF) break; /* end marker */
 C$F4CB,2;21 }
 C$F4CD,3;21 HL = 0;
 C$F4D0,2;21 %>
*C$F4D2,3;21 get_tuning();
 C$F4D5,1
; Loop until the end marker is encountered.
 C$F4D6,3;21 {  HLdash = music_channel1_index + 1;
 C$F4D9,1;21 }
*C$F4DA,3;21 for (;;) <% music_channel1_index = HLdash;
 C$F4DD,3;21 {    A = music_channel1_data[HLdash];
 C$F4E0,1;21
 C$F4E1,1;21 }
 C$F4E2,2;21 {    if (A != 0xFF) break; /* end marker */
 C$F4E4,2;21 }
 C$F4E6,3;21 HLdash = 0;
 C$F4E9,2;21 %>
*C$F4EB,3;21 get_tuning(); /* using banked registers */
 C$F4EE,1;21 A = Bdash;
 C$F4EF,2
 C$F4F1,2;21 {  if (A == 0xFF) <%
 C$F4F3,2;21 }
 C$F4F5,1
 C$F4F6,1;21 POP BCdash
 C$F4F7,1;21 {    DEdash = BCdash;
 C$F4F8,1;21 }
 C$F4F9,1;21 - %>
 C$F4FA,2;21 else <%
*C$F4FC,1;21 %>
*C$F4FD,2;21 A = 24; /* overall tune speed (a delay: lower values are faster) */
*C$F4FF,1;21 do <%
 C$F500,2;21 H = 0xFF; /* iterations */
*C$F502,2;21 do <% if (--B == 0) <%
 C$F504,1;21 {        if (--C == 0) <%
 C$F505,3;21 }
 C$F508,1;21 {          L ^= 16;
 C$F509,2;21
 C$F50B,1;21 }
 C$F50C,2;21 OUT ($FE),L
 C$F50E,1;21 {          BC = DE; %> %>
 C$F50F,1;21 }
*C$F510,1
 C$F511,2;21 if (--Bdash == 0) <%
 C$F513,1;21 {        if (--Cdash == 0) <%
 C$F514,3;21 }
 C$F517,1;21 {          Ldash ^= 16;
 C$F518,2;21
 C$F51A,1;21 }
 C$F51B,2;21 OUT ($FE),Ldash
 C$F51D,1;21 {          BCdash = DEdash; %> %>
 C$F51E,1;21 }
*C$F51F,1
 C$F520,1;21 {    %> while (--H);
 C$F521,3;21 }
 C$F524,1
 C$F525,1;21 {  %> while (--A);
 C$F526,3;21 }
 C$F529,3;21 %>

; Get tuning.
;
; Used by the routine at #R$F4B7.
;
; I:A Index (never larger than 42?).
; O:BC ...
; O:DE ...
; O:HL ...
@label=get_tuning
cC$F52C,1;21 {BC = music_tuning_table[A];
 C$F52D,9;21
 C$F536,1;21 }
 C$F537,1;21 C++;
 C$F538,1;21 B++;
 C$F539,2;21 {if (B == 0) C++;
 C$F53B,1;21 }
*C$F53C,2;21 L = 0;
 C$F53E,1;21 {DE = BC;
 C$F53F,1;21 }
 C$F540,1;21 return;

; Music channel indices.
@label=music_channel0_index
gW$F541,2
@label=music_channel1_index
 W$F543,2

; Unreferenced byte.
uB$F545,1

; Music data.
@label=music_channel0_data
bB$F546,8;44 {music_channel0_data
 B$F54E,8*79
 B$F7C6,1;44 }
@label=music_channel1_data
 B$F7C7,8;44 {music_channel1_data
 B$F7CF,8*79
 B$FA47,1;44 }
@label=music_tuning_table
 W$FA48,2;44 {music_tuning_table
 W$FA4A,2*74
 W$FADE,2;44 }

; 769 bytes of apparently unreferenced bytes.
uB$FAE0,8*96,1

; Loaded.
;
; Very first entry point used to shunt the game image down into its proper
; position.
@label=loaded
cC$FDE1,1;21 Disable interrupts.
 C$FDE2,3;21 SP = 0xFFFF;
 C$FDE5,3;21 {memmove(0x5B00, 0x5E00, 0x9FE0);
@nowarn
 C$FDE8,6;21
 C$FDEE,2;21 }
 C$FDF0,3;21 goto jump_to_main; /* exit via */

; Unreferenced bytes.
uB$FDF3,8,5

; Keyboard input routine.
;
; .
;
; O:A Input value (as per enum input).
@label=inputroutine_keyboard
cC$FE00,3;21 HL = keydefs; /* A list of (port high byte, key mask) */
; Left or right?
 C$FE03,2;21 C = 0xFE; /* Port 0xXXFE */
 C$FE05,1;21 {B = *HL++;
 C$FE06,1;21 }
 C$FE07,2;21
 C$FE09,1;21 {A = ~A & *HL++;
 C$FE0A,1;21
 C$FE0B,1;21 }
 C$FE0C,2;21 if (A) <%
 C$FE0E,1;21 {  HL += 2; /* Skip right keydef */
 C$FE0F,1;21 }
 C$FE10,2;21 E = input_LEFT;
 C$FE12,2;21 %>
; Right.
*C$FE14,1;21 {else <% B = *HL++;
 C$FE15,1;21 }
 C$FE16,2;21
 C$FE18,1;21 {  A = ~A & *HL++;
 C$FE19,1;21
 C$FE1A,1;21 }
 C$FE1B,2;21 if (A) <%
 C$FE1D,2;21 E = input_RIGHT;
 C$FE1F,2;21 %>
*C$FE21,1;21 else <% E = A; /* == 0 */ %> %>
; Up or down?
*C$FE22,1;21 {B = *HL++;
 C$FE23,1;21 }
 C$FE24,2;21
 C$FE26,1;21 {A = ~A & *HL++;
 C$FE27,1;21
 C$FE28,1;21 }
 C$FE29,2;21 if (A) <%
 C$FE2B,1;21 {  HL += 2; /* Skip down keydef */
 C$FE2C,1;21 }
 C$FE2D,1;21 E += input_UP;
 C$FE2E,2;21 %>
; Down.
*C$FE30,1;21 {else <% B = *HL++;
 C$FE31,1;21 }
 C$FE32,2;21
 C$FE34,1;21 {  A = ~A & *HL++;
 C$FE35,1;21
 C$FE36,1;21 }
 C$FE37,2;21 if (A) <%
 C$FE39,1;21 {    E += input_DOWN; %> %>
 C$FE3A,1;21 }
; Fire?
*C$FE3B,1;21 {B = *HL++;
 C$FE3C,1;21 }
 C$FE3D,2;21
 C$FE3F,1;21 {A = ~A & *HL++;
 C$FE40,1;21
 C$FE41,1;21 }
 C$FE42,1;21 A = E;
 C$FE43,1;21 if (A)
 C$FE44,2;21 A += input_FIRE;
 C$FE46,1;21 return;

; Protek (cursor) joystick input routine.
;
; .
;
; O:A Input value (as per enum input).
;
; Horizontal.
@label=inputroutine_protek
cC$FE47,3;21 BC = port_KEYBOARD_12345;
 C$FE4A,2;21
 C$FE4C,1;21 {A = ~A & (1<<4); /* 5 == left */
 C$FE4D,2;21 }
 C$FE4F,2;21 E = input_LEFT;
 C$FE51,2;21 B = 0xEF; /* port_KEYBOARD_09876 */
 C$FE53,2;21 if (Z) <%
 C$FE55,2;21
 C$FE57,1;21 {  A = ~A & (1<<2);
 C$FE58,2;21 }
 C$FE5A,2;21 E = input_RIGHT;
 C$FE5C,2;21 if (Z)
 C$FE5E,2;21 E = 0; %>
; Vertical.
*C$FE60,2;21
 C$FE62,1;21 A = ~A;
 C$FE63,1;21 D = A;
 C$FE64,2;21 A &= (1<<3);
 C$FE66,2;21 A = input_UP; /* interleaved */
 C$FE68,2;21 if (Z) <%
 C$FE6A,1;21 A = D;
 C$FE6B,2;21 A &= (1<<4);
 C$FE6D,2;21 A = input_DOWN; /* interleaved */
 C$FE6F,2;21 if (Z)
 C$FE71,1;21 A = input_NONE; %>
*C$FE72,1;21 {E += A; /* Combine axis */
 C$FE73,1;21 }
; Fire.
 C$FE74,1;21 {A = D & (1<<0);
 C$FE75,2;21 }
 C$FE77,2;21 A = input_FIRE; /* interleaved */
 C$FE79,2;21 {if (Z) A = 0;
 C$FE7B,1;21 }
*C$FE7C,1;21 A += E; /* Combine axis */
 C$FE7D,1;21 return;

; Kempston joystick input routine.
;
; Reading port 0x1F yields 000FUDLR active high.
;
; O:A Input value (as per enum input).
@label=inputroutine_kempston
cC$FE7E,3;21 BC = 0x001F;
 C$FE81,2;21
 C$FE83,3;21 BC = 0;
 C$FE86,1;21 carry = A & 1; A >>= 1;
 C$FE87,2;21 {if (carry) B = input_RIGHT;
 C$FE89,2;21 }
*C$FE8B,1;21 carry = A & 1; A >>= 1;
 C$FE8C,2;21 {if (carry) B = input_LEFT;
 C$FE8E,2;21 }
*C$FE90,1;21 carry = A & 1; A >>= 1;
 C$FE91,2;21 {if (carry) C = input_DOWN;
 C$FE93,2;21 }
*C$FE95,1;21 carry = A & 1; A >>= 1;
 C$FE96,2;21 {if (carry) C = input_UP;
 C$FE98,2;21 }
*C$FE9A,1;21 carry = A & 1; A >>= 1;
 C$FE9B,2;21 A = input_FIRE;
 C$FE9D,2;21 {if (!carry) A = 0;
 C$FE9F,1;21 }
*C$FEA0,1;21 {A += B + C;
 C$FEA1,1;21 }
 C$FEA2,1;21 return; /* Combine axis */

; Fuller joystick input routine.
;
; Reading port 0x7F yields F---RLDU active low.
;
;   This is unused by the game.
; O:A Input value (as per enum input).
@label=inputroutine_fuller
cC$FEA3,3;21 BC = 0x007F;
 C$FEA6,2;21
 C$FEA8,3;21 BC = 0;
 C$FEAB,2;21 {if (A & (1<<4)) A = ~A;
 C$FEAD,2;21
 C$FEAF,1;21 }
*C$FEB0,1;21 carry = A & 1; A >>= 1;
 C$FEB1,2;21 {if (carry) C = input_UP;
 C$FEB3,2;21 }
*C$FEB5,1;21 carry = A & 1; A >>= 1;
 C$FEB6,2;21 {if (carry) C = input_DOWN;
 C$FEB8,2;21 }
*C$FEBA,1;21 carry = A & 1; A >>= 1;
 C$FEBB,2;21 {if (carry) B = input_LEFT;
 C$FEBD,2;21 }
*C$FEBF,1;21 carry = A & 1; A >>= 1;
 C$FEC0,2;21 {if (carry) B = input_RIGHT;
 C$FEC2,2;21 }
*C$FEC4,2;21 {if (A & (1<<3)) A = input_FIRE; /* otherwise A is zero */
 C$FEC6,2;21
 C$FEC8,2;21 }
*C$FECA,1;21 {A += B + C; /* Combine axis */
 C$FECB,1;21 }
 C$FECC,1;21 return;

; Sinclair joystick input routine.
;
; Up/Down/Left/Right/Fire = keys 9/8/6/7/0.
;
; O:A Input value (as per enum input).
@label=inputroutine_sinclair
cC$FECD,3;21 BC = port_KEYBOARD_09876;
 C$FED0,2;21
 C$FED2,1;21 A = ~A; /* xxx67890 */
 C$FED3,3;21 BC = 0;
 C$FED6,1;21 RRCA /* 0xxx6789 */
 C$FED7,1;21 RRCA /* 90xxx678 */
 C$FED8,2;21 {if (carry) C = input_UP;
 C$FEDA,2;21 }
*C$FEDC,1;21 RRCA /* 890xxx67 */
 C$FEDD,2;21 {if (carry) C = input_DOWN;
 C$FEDF,2;21 }
*C$FEE1,1;21 RRCA /* 7890xxx6 */
 C$FEE2,2;21 {if (carry) B = input_RIGHT;
 C$FEE4,2;21 }
*C$FEE6,1;21 RRCA /* 67890xxx */
 C$FEE7,2;21 {if (carry) B = input_LEFT;
 C$FEE9,2;21 }
*C$FEEB,2;21 {if ((A & (1<<3)) == 0) A = input_FIRE;
 C$FEED,2;21
 C$FEEF,2;21 }
*C$FEF1,1;21 {A += B + C; /* Combine axis */
 C$FEF2,1;21 }
 C$FEF3,1;21 return;

; Data block at FEF4.
;
; The final standard speed data block on the tape is loaded at $FC60..$FF81.
; The bytes from here up to $FF81 come from that block.
;
bB$FEF4,8*12,4
; UDGs 'A' to 'E' follow, with 'F' truncated at its second byte.
@label=map_buf
 B$FF58,8;44 A #HTML[#UDG$FF58]
 B$FF60,8;44 B #HTML[#UDG$FF60]
 B$FF68,8;44 C #HTML[#UDG$FF68]
 B$FF70,8;44 D #HTML[#UDG$FF70]
 B$FF78,8;44 E #HTML[#UDG$FF78]
 B$FF80,2;20 Truncated F
; NUL bytes
 B$FF82,2,8*15,4
